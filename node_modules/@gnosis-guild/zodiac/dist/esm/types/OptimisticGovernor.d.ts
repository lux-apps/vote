import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, EventFragment, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers";
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedLogDescription, TypedListener, TypedContractMethod } from "./common";
export declare namespace OptimisticGovernor {
    type TransactionStruct = {
        to: AddressLike;
        operation: BigNumberish;
        value: BigNumberish;
        data: BytesLike;
    };
    type TransactionStructOutput = [
        to: string,
        operation: bigint,
        value: bigint,
        data: string
    ] & {
        to: string;
        operation: bigint;
        value: bigint;
        data: string;
    };
    type ProposalStruct = {
        transactions: OptimisticGovernor.TransactionStruct[];
        requestTime: BigNumberish;
    };
    type ProposalStructOutput = [
        transactions: OptimisticGovernor.TransactionStructOutput[],
        requestTime: bigint
    ] & {
        transactions: OptimisticGovernor.TransactionStructOutput[];
        requestTime: bigint;
    };
}
export interface OptimisticGovernorInterface extends Interface {
    getFunction(nameOrSignature: "EXPLANATION_KEY" | "PROPOSAL_HASH_KEY" | "RULES_KEY" | "assertionDisputedCallback" | "assertionIds" | "assertionResolvedCallback" | "avatar" | "bondAmount" | "collateral" | "deleteProposalOnUpgrade" | "escalationManager" | "executeProposal" | "finder" | "getCurrentTime" | "getGuard" | "getProposalBond" | "guard" | "identifier" | "liveness" | "optimisticOracleV3" | "owner" | "proposalHashes" | "proposeTransactions" | "renounceOwnership" | "rules" | "setAvatar" | "setCollateralAndBond" | "setEscalationManager" | "setGuard" | "setIdentifier" | "setLiveness" | "setRules" | "setTarget" | "setUp" | "sync" | "target" | "transferOwnership"): FunctionFragment;
    getEvent(nameOrSignatureOrTopic: "AvatarSet" | "ChangedGuard" | "Initialized" | "OptimisticGovernorDeployed" | "OptimisticOracleChanged" | "OwnershipTransferred" | "ProposalDeleted" | "ProposalExecuted" | "SetCollateralAndBond" | "SetEscalationManager" | "SetIdentifier" | "SetLiveness" | "SetRules" | "TargetSet" | "TransactionExecuted" | "TransactionsProposed"): EventFragment;
    encodeFunctionData(functionFragment: "EXPLANATION_KEY", values?: undefined): string;
    encodeFunctionData(functionFragment: "PROPOSAL_HASH_KEY", values?: undefined): string;
    encodeFunctionData(functionFragment: "RULES_KEY", values?: undefined): string;
    encodeFunctionData(functionFragment: "assertionDisputedCallback", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "assertionIds", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "assertionResolvedCallback", values: [BytesLike, boolean]): string;
    encodeFunctionData(functionFragment: "avatar", values?: undefined): string;
    encodeFunctionData(functionFragment: "bondAmount", values?: undefined): string;
    encodeFunctionData(functionFragment: "collateral", values?: undefined): string;
    encodeFunctionData(functionFragment: "deleteProposalOnUpgrade", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "escalationManager", values?: undefined): string;
    encodeFunctionData(functionFragment: "executeProposal", values: [OptimisticGovernor.TransactionStruct[]]): string;
    encodeFunctionData(functionFragment: "finder", values?: undefined): string;
    encodeFunctionData(functionFragment: "getCurrentTime", values?: undefined): string;
    encodeFunctionData(functionFragment: "getGuard", values?: undefined): string;
    encodeFunctionData(functionFragment: "getProposalBond", values?: undefined): string;
    encodeFunctionData(functionFragment: "guard", values?: undefined): string;
    encodeFunctionData(functionFragment: "identifier", values?: undefined): string;
    encodeFunctionData(functionFragment: "liveness", values?: undefined): string;
    encodeFunctionData(functionFragment: "optimisticOracleV3", values?: undefined): string;
    encodeFunctionData(functionFragment: "owner", values?: undefined): string;
    encodeFunctionData(functionFragment: "proposalHashes", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "proposeTransactions", values: [OptimisticGovernor.TransactionStruct[], BytesLike]): string;
    encodeFunctionData(functionFragment: "renounceOwnership", values?: undefined): string;
    encodeFunctionData(functionFragment: "rules", values?: undefined): string;
    encodeFunctionData(functionFragment: "setAvatar", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "setCollateralAndBond", values: [AddressLike, BigNumberish]): string;
    encodeFunctionData(functionFragment: "setEscalationManager", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "setGuard", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "setIdentifier", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "setLiveness", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "setRules", values: [string]): string;
    encodeFunctionData(functionFragment: "setTarget", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "setUp", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "sync", values?: undefined): string;
    encodeFunctionData(functionFragment: "target", values?: undefined): string;
    encodeFunctionData(functionFragment: "transferOwnership", values: [AddressLike]): string;
    decodeFunctionResult(functionFragment: "EXPLANATION_KEY", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "PROPOSAL_HASH_KEY", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "RULES_KEY", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "assertionDisputedCallback", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "assertionIds", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "assertionResolvedCallback", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "avatar", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "bondAmount", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "collateral", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "deleteProposalOnUpgrade", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "escalationManager", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "executeProposal", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "finder", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getCurrentTime", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getGuard", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getProposalBond", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "guard", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "identifier", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "liveness", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "optimisticOracleV3", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "proposalHashes", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "proposeTransactions", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "renounceOwnership", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "rules", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setAvatar", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setCollateralAndBond", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setEscalationManager", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setGuard", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setIdentifier", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setLiveness", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setRules", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setTarget", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setUp", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "sync", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "target", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferOwnership", data: BytesLike): Result;
}
export declare namespace AvatarSetEvent {
    type InputTuple = [
        previousAvatar: AddressLike,
        newAvatar: AddressLike
    ];
    type OutputTuple = [previousAvatar: string, newAvatar: string];
    interface OutputObject {
        previousAvatar: string;
        newAvatar: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace ChangedGuardEvent {
    type InputTuple = [guard: AddressLike];
    type OutputTuple = [guard: string];
    interface OutputObject {
        guard: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace InitializedEvent {
    type InputTuple = [version: BigNumberish];
    type OutputTuple = [version: bigint];
    interface OutputObject {
        version: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace OptimisticGovernorDeployedEvent {
    type InputTuple = [
        owner: AddressLike,
        avatar: AddressLike,
        target: AddressLike
    ];
    type OutputTuple = [owner: string, avatar: string, target: string];
    interface OutputObject {
        owner: string;
        avatar: string;
        target: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace OptimisticOracleChangedEvent {
    type InputTuple = [newOptimisticOracleV3: AddressLike];
    type OutputTuple = [newOptimisticOracleV3: string];
    interface OutputObject {
        newOptimisticOracleV3: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace OwnershipTransferredEvent {
    type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
    type OutputTuple = [previousOwner: string, newOwner: string];
    interface OutputObject {
        previousOwner: string;
        newOwner: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace ProposalDeletedEvent {
    type InputTuple = [proposalHash: BytesLike, assertionId: BytesLike];
    type OutputTuple = [proposalHash: string, assertionId: string];
    interface OutputObject {
        proposalHash: string;
        assertionId: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace ProposalExecutedEvent {
    type InputTuple = [proposalHash: BytesLike, assertionId: BytesLike];
    type OutputTuple = [proposalHash: string, assertionId: string];
    interface OutputObject {
        proposalHash: string;
        assertionId: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace SetCollateralAndBondEvent {
    type InputTuple = [collateral: AddressLike, bondAmount: BigNumberish];
    type OutputTuple = [collateral: string, bondAmount: bigint];
    interface OutputObject {
        collateral: string;
        bondAmount: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace SetEscalationManagerEvent {
    type InputTuple = [escalationManager: AddressLike];
    type OutputTuple = [escalationManager: string];
    interface OutputObject {
        escalationManager: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace SetIdentifierEvent {
    type InputTuple = [identifier: BytesLike];
    type OutputTuple = [identifier: string];
    interface OutputObject {
        identifier: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace SetLivenessEvent {
    type InputTuple = [liveness: BigNumberish];
    type OutputTuple = [liveness: bigint];
    interface OutputObject {
        liveness: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace SetRulesEvent {
    type InputTuple = [rules: string];
    type OutputTuple = [rules: string];
    interface OutputObject {
        rules: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace TargetSetEvent {
    type InputTuple = [
        previousTarget: AddressLike,
        newTarget: AddressLike
    ];
    type OutputTuple = [previousTarget: string, newTarget: string];
    interface OutputObject {
        previousTarget: string;
        newTarget: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace TransactionExecutedEvent {
    type InputTuple = [
        proposalHash: BytesLike,
        assertionId: BytesLike,
        transactionIndex: BigNumberish
    ];
    type OutputTuple = [
        proposalHash: string,
        assertionId: string,
        transactionIndex: bigint
    ];
    interface OutputObject {
        proposalHash: string;
        assertionId: string;
        transactionIndex: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace TransactionsProposedEvent {
    type InputTuple = [
        proposer: AddressLike,
        proposalTime: BigNumberish,
        assertionId: BytesLike,
        proposal: OptimisticGovernor.ProposalStruct,
        proposalHash: BytesLike,
        explanation: BytesLike,
        rules: string,
        challengeWindowEnds: BigNumberish
    ];
    type OutputTuple = [
        proposer: string,
        proposalTime: bigint,
        assertionId: string,
        proposal: OptimisticGovernor.ProposalStructOutput,
        proposalHash: string,
        explanation: string,
        rules: string,
        challengeWindowEnds: bigint
    ];
    interface OutputObject {
        proposer: string;
        proposalTime: bigint;
        assertionId: string;
        proposal: OptimisticGovernor.ProposalStructOutput;
        proposalHash: string;
        explanation: string;
        rules: string;
        challengeWindowEnds: bigint;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export interface OptimisticGovernor extends BaseContract {
    connect(runner?: ContractRunner | null): OptimisticGovernor;
    waitForDeployment(): Promise<this>;
    interface: OptimisticGovernorInterface;
    queryFilter<TCEvent extends TypedContractEvent>(event: TCEvent, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    queryFilter<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    listeners<TCEvent extends TypedContractEvent>(event: TCEvent): Promise<Array<TypedListener<TCEvent>>>;
    listeners(eventName?: string): Promise<Array<Listener>>;
    removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>;
    EXPLANATION_KEY: TypedContractMethod<[], [string], "view">;
    PROPOSAL_HASH_KEY: TypedContractMethod<[], [string], "view">;
    RULES_KEY: TypedContractMethod<[], [string], "view">;
    assertionDisputedCallback: TypedContractMethod<[
        assertionId: BytesLike
    ], [
        void
    ], "nonpayable">;
    assertionIds: TypedContractMethod<[arg0: BytesLike], [string], "view">;
    assertionResolvedCallback: TypedContractMethod<[
        assertionId: BytesLike,
        assertedTruthfully: boolean
    ], [
        void
    ], "nonpayable">;
    avatar: TypedContractMethod<[], [string], "view">;
    bondAmount: TypedContractMethod<[], [bigint], "view">;
    collateral: TypedContractMethod<[], [string], "view">;
    deleteProposalOnUpgrade: TypedContractMethod<[
        proposalHash: BytesLike
    ], [
        void
    ], "nonpayable">;
    escalationManager: TypedContractMethod<[], [string], "view">;
    executeProposal: TypedContractMethod<[
        transactions: OptimisticGovernor.TransactionStruct[]
    ], [
        void
    ], "nonpayable">;
    finder: TypedContractMethod<[], [string], "view">;
    getCurrentTime: TypedContractMethod<[], [bigint], "view">;
    getGuard: TypedContractMethod<[], [string], "view">;
    getProposalBond: TypedContractMethod<[], [bigint], "view">;
    guard: TypedContractMethod<[], [string], "view">;
    identifier: TypedContractMethod<[], [string], "view">;
    liveness: TypedContractMethod<[], [bigint], "view">;
    optimisticOracleV3: TypedContractMethod<[], [string], "view">;
    owner: TypedContractMethod<[], [string], "view">;
    proposalHashes: TypedContractMethod<[arg0: BytesLike], [string], "view">;
    proposeTransactions: TypedContractMethod<[
        transactions: OptimisticGovernor.TransactionStruct[],
        explanation: BytesLike
    ], [
        void
    ], "nonpayable">;
    renounceOwnership: TypedContractMethod<[], [void], "nonpayable">;
    rules: TypedContractMethod<[], [string], "view">;
    setAvatar: TypedContractMethod<[_avatar: AddressLike], [void], "nonpayable">;
    setCollateralAndBond: TypedContractMethod<[
        _collateral: AddressLike,
        _bondAmount: BigNumberish
    ], [
        void
    ], "nonpayable">;
    setEscalationManager: TypedContractMethod<[
        _escalationManager: AddressLike
    ], [
        void
    ], "nonpayable">;
    setGuard: TypedContractMethod<[_guard: AddressLike], [void], "nonpayable">;
    setIdentifier: TypedContractMethod<[
        _identifier: BytesLike
    ], [
        void
    ], "nonpayable">;
    setLiveness: TypedContractMethod<[
        _liveness: BigNumberish
    ], [
        void
    ], "nonpayable">;
    setRules: TypedContractMethod<[_rules: string], [void], "nonpayable">;
    setTarget: TypedContractMethod<[_target: AddressLike], [void], "nonpayable">;
    setUp: TypedContractMethod<[
        initializeParams: BytesLike
    ], [
        void
    ], "nonpayable">;
    sync: TypedContractMethod<[], [void], "nonpayable">;
    transferOwnership: TypedContractMethod<[
        newOwner: AddressLike
    ], [
        void
    ], "nonpayable">;
    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;
    getFunction(nameOrSignature: "EXPLANATION_KEY"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "PROPOSAL_HASH_KEY"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "RULES_KEY"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "assertionDisputedCallback"): TypedContractMethod<[assertionId: BytesLike], [void], "nonpayable">;
    getFunction(nameOrSignature: "assertionIds"): TypedContractMethod<[arg0: BytesLike], [string], "view">;
    getFunction(nameOrSignature: "assertionResolvedCallback"): TypedContractMethod<[
        assertionId: BytesLike,
        assertedTruthfully: boolean
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "avatar"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "bondAmount"): TypedContractMethod<[], [bigint], "view">;
    getFunction(nameOrSignature: "collateral"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "deleteProposalOnUpgrade"): TypedContractMethod<[proposalHash: BytesLike], [void], "nonpayable">;
    getFunction(nameOrSignature: "escalationManager"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "executeProposal"): TypedContractMethod<[
        transactions: OptimisticGovernor.TransactionStruct[]
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "finder"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "getCurrentTime"): TypedContractMethod<[], [bigint], "view">;
    getFunction(nameOrSignature: "getGuard"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "getProposalBond"): TypedContractMethod<[], [bigint], "view">;
    getFunction(nameOrSignature: "guard"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "identifier"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "liveness"): TypedContractMethod<[], [bigint], "view">;
    getFunction(nameOrSignature: "optimisticOracleV3"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "owner"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "proposalHashes"): TypedContractMethod<[arg0: BytesLike], [string], "view">;
    getFunction(nameOrSignature: "proposeTransactions"): TypedContractMethod<[
        transactions: OptimisticGovernor.TransactionStruct[],
        explanation: BytesLike
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "renounceOwnership"): TypedContractMethod<[], [void], "nonpayable">;
    getFunction(nameOrSignature: "rules"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "setAvatar"): TypedContractMethod<[_avatar: AddressLike], [void], "nonpayable">;
    getFunction(nameOrSignature: "setCollateralAndBond"): TypedContractMethod<[
        _collateral: AddressLike,
        _bondAmount: BigNumberish
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "setEscalationManager"): TypedContractMethod<[
        _escalationManager: AddressLike
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "setGuard"): TypedContractMethod<[_guard: AddressLike], [void], "nonpayable">;
    getFunction(nameOrSignature: "setIdentifier"): TypedContractMethod<[_identifier: BytesLike], [void], "nonpayable">;
    getFunction(nameOrSignature: "setLiveness"): TypedContractMethod<[_liveness: BigNumberish], [void], "nonpayable">;
    getFunction(nameOrSignature: "setRules"): TypedContractMethod<[_rules: string], [void], "nonpayable">;
    getFunction(nameOrSignature: "setTarget"): TypedContractMethod<[_target: AddressLike], [void], "nonpayable">;
    getFunction(nameOrSignature: "setUp"): TypedContractMethod<[initializeParams: BytesLike], [void], "nonpayable">;
    getFunction(nameOrSignature: "sync"): TypedContractMethod<[], [void], "nonpayable">;
    getFunction(nameOrSignature: "target"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "transferOwnership"): TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;
    getEvent(key: "AvatarSet"): TypedContractEvent<AvatarSetEvent.InputTuple, AvatarSetEvent.OutputTuple, AvatarSetEvent.OutputObject>;
    getEvent(key: "ChangedGuard"): TypedContractEvent<ChangedGuardEvent.InputTuple, ChangedGuardEvent.OutputTuple, ChangedGuardEvent.OutputObject>;
    getEvent(key: "Initialized"): TypedContractEvent<InitializedEvent.InputTuple, InitializedEvent.OutputTuple, InitializedEvent.OutputObject>;
    getEvent(key: "OptimisticGovernorDeployed"): TypedContractEvent<OptimisticGovernorDeployedEvent.InputTuple, OptimisticGovernorDeployedEvent.OutputTuple, OptimisticGovernorDeployedEvent.OutputObject>;
    getEvent(key: "OptimisticOracleChanged"): TypedContractEvent<OptimisticOracleChangedEvent.InputTuple, OptimisticOracleChangedEvent.OutputTuple, OptimisticOracleChangedEvent.OutputObject>;
    getEvent(key: "OwnershipTransferred"): TypedContractEvent<OwnershipTransferredEvent.InputTuple, OwnershipTransferredEvent.OutputTuple, OwnershipTransferredEvent.OutputObject>;
    getEvent(key: "ProposalDeleted"): TypedContractEvent<ProposalDeletedEvent.InputTuple, ProposalDeletedEvent.OutputTuple, ProposalDeletedEvent.OutputObject>;
    getEvent(key: "ProposalExecuted"): TypedContractEvent<ProposalExecutedEvent.InputTuple, ProposalExecutedEvent.OutputTuple, ProposalExecutedEvent.OutputObject>;
    getEvent(key: "SetCollateralAndBond"): TypedContractEvent<SetCollateralAndBondEvent.InputTuple, SetCollateralAndBondEvent.OutputTuple, SetCollateralAndBondEvent.OutputObject>;
    getEvent(key: "SetEscalationManager"): TypedContractEvent<SetEscalationManagerEvent.InputTuple, SetEscalationManagerEvent.OutputTuple, SetEscalationManagerEvent.OutputObject>;
    getEvent(key: "SetIdentifier"): TypedContractEvent<SetIdentifierEvent.InputTuple, SetIdentifierEvent.OutputTuple, SetIdentifierEvent.OutputObject>;
    getEvent(key: "SetLiveness"): TypedContractEvent<SetLivenessEvent.InputTuple, SetLivenessEvent.OutputTuple, SetLivenessEvent.OutputObject>;
    getEvent(key: "SetRules"): TypedContractEvent<SetRulesEvent.InputTuple, SetRulesEvent.OutputTuple, SetRulesEvent.OutputObject>;
    getEvent(key: "TargetSet"): TypedContractEvent<TargetSetEvent.InputTuple, TargetSetEvent.OutputTuple, TargetSetEvent.OutputObject>;
    getEvent(key: "TransactionExecuted"): TypedContractEvent<TransactionExecutedEvent.InputTuple, TransactionExecutedEvent.OutputTuple, TransactionExecutedEvent.OutputObject>;
    getEvent(key: "TransactionsProposed"): TypedContractEvent<TransactionsProposedEvent.InputTuple, TransactionsProposedEvent.OutputTuple, TransactionsProposedEvent.OutputObject>;
    filters: {
        "AvatarSet(address,address)": TypedContractEvent<AvatarSetEvent.InputTuple, AvatarSetEvent.OutputTuple, AvatarSetEvent.OutputObject>;
        AvatarSet: TypedContractEvent<AvatarSetEvent.InputTuple, AvatarSetEvent.OutputTuple, AvatarSetEvent.OutputObject>;
        "ChangedGuard(address)": TypedContractEvent<ChangedGuardEvent.InputTuple, ChangedGuardEvent.OutputTuple, ChangedGuardEvent.OutputObject>;
        ChangedGuard: TypedContractEvent<ChangedGuardEvent.InputTuple, ChangedGuardEvent.OutputTuple, ChangedGuardEvent.OutputObject>;
        "Initialized(uint8)": TypedContractEvent<InitializedEvent.InputTuple, InitializedEvent.OutputTuple, InitializedEvent.OutputObject>;
        Initialized: TypedContractEvent<InitializedEvent.InputTuple, InitializedEvent.OutputTuple, InitializedEvent.OutputObject>;
        "OptimisticGovernorDeployed(address,address,address)": TypedContractEvent<OptimisticGovernorDeployedEvent.InputTuple, OptimisticGovernorDeployedEvent.OutputTuple, OptimisticGovernorDeployedEvent.OutputObject>;
        OptimisticGovernorDeployed: TypedContractEvent<OptimisticGovernorDeployedEvent.InputTuple, OptimisticGovernorDeployedEvent.OutputTuple, OptimisticGovernorDeployedEvent.OutputObject>;
        "OptimisticOracleChanged(address)": TypedContractEvent<OptimisticOracleChangedEvent.InputTuple, OptimisticOracleChangedEvent.OutputTuple, OptimisticOracleChangedEvent.OutputObject>;
        OptimisticOracleChanged: TypedContractEvent<OptimisticOracleChangedEvent.InputTuple, OptimisticOracleChangedEvent.OutputTuple, OptimisticOracleChangedEvent.OutputObject>;
        "OwnershipTransferred(address,address)": TypedContractEvent<OwnershipTransferredEvent.InputTuple, OwnershipTransferredEvent.OutputTuple, OwnershipTransferredEvent.OutputObject>;
        OwnershipTransferred: TypedContractEvent<OwnershipTransferredEvent.InputTuple, OwnershipTransferredEvent.OutputTuple, OwnershipTransferredEvent.OutputObject>;
        "ProposalDeleted(bytes32,bytes32)": TypedContractEvent<ProposalDeletedEvent.InputTuple, ProposalDeletedEvent.OutputTuple, ProposalDeletedEvent.OutputObject>;
        ProposalDeleted: TypedContractEvent<ProposalDeletedEvent.InputTuple, ProposalDeletedEvent.OutputTuple, ProposalDeletedEvent.OutputObject>;
        "ProposalExecuted(bytes32,bytes32)": TypedContractEvent<ProposalExecutedEvent.InputTuple, ProposalExecutedEvent.OutputTuple, ProposalExecutedEvent.OutputObject>;
        ProposalExecuted: TypedContractEvent<ProposalExecutedEvent.InputTuple, ProposalExecutedEvent.OutputTuple, ProposalExecutedEvent.OutputObject>;
        "SetCollateralAndBond(address,uint256)": TypedContractEvent<SetCollateralAndBondEvent.InputTuple, SetCollateralAndBondEvent.OutputTuple, SetCollateralAndBondEvent.OutputObject>;
        SetCollateralAndBond: TypedContractEvent<SetCollateralAndBondEvent.InputTuple, SetCollateralAndBondEvent.OutputTuple, SetCollateralAndBondEvent.OutputObject>;
        "SetEscalationManager(address)": TypedContractEvent<SetEscalationManagerEvent.InputTuple, SetEscalationManagerEvent.OutputTuple, SetEscalationManagerEvent.OutputObject>;
        SetEscalationManager: TypedContractEvent<SetEscalationManagerEvent.InputTuple, SetEscalationManagerEvent.OutputTuple, SetEscalationManagerEvent.OutputObject>;
        "SetIdentifier(bytes32)": TypedContractEvent<SetIdentifierEvent.InputTuple, SetIdentifierEvent.OutputTuple, SetIdentifierEvent.OutputObject>;
        SetIdentifier: TypedContractEvent<SetIdentifierEvent.InputTuple, SetIdentifierEvent.OutputTuple, SetIdentifierEvent.OutputObject>;
        "SetLiveness(uint64)": TypedContractEvent<SetLivenessEvent.InputTuple, SetLivenessEvent.OutputTuple, SetLivenessEvent.OutputObject>;
        SetLiveness: TypedContractEvent<SetLivenessEvent.InputTuple, SetLivenessEvent.OutputTuple, SetLivenessEvent.OutputObject>;
        "SetRules(string)": TypedContractEvent<SetRulesEvent.InputTuple, SetRulesEvent.OutputTuple, SetRulesEvent.OutputObject>;
        SetRules: TypedContractEvent<SetRulesEvent.InputTuple, SetRulesEvent.OutputTuple, SetRulesEvent.OutputObject>;
        "TargetSet(address,address)": TypedContractEvent<TargetSetEvent.InputTuple, TargetSetEvent.OutputTuple, TargetSetEvent.OutputObject>;
        TargetSet: TypedContractEvent<TargetSetEvent.InputTuple, TargetSetEvent.OutputTuple, TargetSetEvent.OutputObject>;
        "TransactionExecuted(bytes32,bytes32,uint256)": TypedContractEvent<TransactionExecutedEvent.InputTuple, TransactionExecutedEvent.OutputTuple, TransactionExecutedEvent.OutputObject>;
        TransactionExecuted: TypedContractEvent<TransactionExecutedEvent.InputTuple, TransactionExecutedEvent.OutputTuple, TransactionExecutedEvent.OutputObject>;
        "TransactionsProposed(address,uint256,bytes32,tuple,bytes32,bytes,string,uint256)": TypedContractEvent<TransactionsProposedEvent.InputTuple, TransactionsProposedEvent.OutputTuple, TransactionsProposedEvent.OutputObject>;
        TransactionsProposed: TypedContractEvent<TransactionsProposedEvent.InputTuple, TransactionsProposedEvent.OutputTuple, TransactionsProposedEvent.OutputObject>;
    };
}

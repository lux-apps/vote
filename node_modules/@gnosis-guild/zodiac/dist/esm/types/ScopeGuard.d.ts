import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, EventFragment, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers";
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedLogDescription, TypedListener, TypedContractMethod } from "./common";
export interface ScopeGuardInterface extends Interface {
    getFunction(nameOrSignature: "allowedTargets" | "checkAfterExecution" | "checkTransaction" | "isAllowedFunction" | "isAllowedTarget" | "isAllowedToDelegateCall" | "isScoped" | "isValueAllowed" | "isfallbackAllowed" | "owner" | "renounceOwnership" | "setAllowedFunction" | "setDelegateCallAllowedOnTarget" | "setFallbackAllowedOnTarget" | "setScoped" | "setTargetAllowed" | "setUp" | "setValueAllowedOnTarget" | "supportsInterface" | "transferOwnership"): FunctionFragment;
    getEvent(nameOrSignatureOrTopic: "OwnershipTransferred" | "ScopeGuardSetup" | "SetDelegateCallAllowedOnTarget" | "SetFallbackAllowedOnTarget" | "SetFunctionAllowedOnTarget" | "SetTargetAllowed" | "SetTargetScoped" | "SetValueAllowedOnTarget"): EventFragment;
    encodeFunctionData(functionFragment: "allowedTargets", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "checkAfterExecution", values: [BytesLike, boolean]): string;
    encodeFunctionData(functionFragment: "checkTransaction", values: [
        AddressLike,
        BigNumberish,
        BytesLike,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        BigNumberish,
        AddressLike,
        AddressLike,
        BytesLike,
        AddressLike
    ]): string;
    encodeFunctionData(functionFragment: "isAllowedFunction", values: [AddressLike, BytesLike]): string;
    encodeFunctionData(functionFragment: "isAllowedTarget", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "isAllowedToDelegateCall", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "isScoped", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "isValueAllowed", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "isfallbackAllowed", values: [AddressLike]): string;
    encodeFunctionData(functionFragment: "owner", values?: undefined): string;
    encodeFunctionData(functionFragment: "renounceOwnership", values?: undefined): string;
    encodeFunctionData(functionFragment: "setAllowedFunction", values: [AddressLike, BytesLike, boolean]): string;
    encodeFunctionData(functionFragment: "setDelegateCallAllowedOnTarget", values: [AddressLike, boolean]): string;
    encodeFunctionData(functionFragment: "setFallbackAllowedOnTarget", values: [AddressLike, boolean]): string;
    encodeFunctionData(functionFragment: "setScoped", values: [AddressLike, boolean]): string;
    encodeFunctionData(functionFragment: "setTargetAllowed", values: [AddressLike, boolean]): string;
    encodeFunctionData(functionFragment: "setUp", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "setValueAllowedOnTarget", values: [AddressLike, boolean]): string;
    encodeFunctionData(functionFragment: "supportsInterface", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "transferOwnership", values: [AddressLike]): string;
    decodeFunctionResult(functionFragment: "allowedTargets", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "checkAfterExecution", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "checkTransaction", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isAllowedFunction", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isAllowedTarget", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isAllowedToDelegateCall", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isScoped", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isValueAllowed", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isfallbackAllowed", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "renounceOwnership", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setAllowedFunction", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setDelegateCallAllowedOnTarget", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setFallbackAllowedOnTarget", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setScoped", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setTargetAllowed", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setUp", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setValueAllowedOnTarget", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "supportsInterface", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "transferOwnership", data: BytesLike): Result;
}
export declare namespace OwnershipTransferredEvent {
    type InputTuple = [previousOwner: AddressLike, newOwner: AddressLike];
    type OutputTuple = [previousOwner: string, newOwner: string];
    interface OutputObject {
        previousOwner: string;
        newOwner: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace ScopeGuardSetupEvent {
    type InputTuple = [initiator: AddressLike, owner: AddressLike];
    type OutputTuple = [initiator: string, owner: string];
    interface OutputObject {
        initiator: string;
        owner: string;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace SetDelegateCallAllowedOnTargetEvent {
    type InputTuple = [target: AddressLike, allowed: boolean];
    type OutputTuple = [target: string, allowed: boolean];
    interface OutputObject {
        target: string;
        allowed: boolean;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace SetFallbackAllowedOnTargetEvent {
    type InputTuple = [target: AddressLike, allowed: boolean];
    type OutputTuple = [target: string, allowed: boolean];
    interface OutputObject {
        target: string;
        allowed: boolean;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace SetFunctionAllowedOnTargetEvent {
    type InputTuple = [
        target: AddressLike,
        functionSig: BytesLike,
        allowed: boolean
    ];
    type OutputTuple = [
        target: string,
        functionSig: string,
        allowed: boolean
    ];
    interface OutputObject {
        target: string;
        functionSig: string;
        allowed: boolean;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace SetTargetAllowedEvent {
    type InputTuple = [target: AddressLike, allowed: boolean];
    type OutputTuple = [target: string, allowed: boolean];
    interface OutputObject {
        target: string;
        allowed: boolean;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace SetTargetScopedEvent {
    type InputTuple = [target: AddressLike, scoped: boolean];
    type OutputTuple = [target: string, scoped: boolean];
    interface OutputObject {
        target: string;
        scoped: boolean;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export declare namespace SetValueAllowedOnTargetEvent {
    type InputTuple = [target: AddressLike, allowed: boolean];
    type OutputTuple = [target: string, allowed: boolean];
    interface OutputObject {
        target: string;
        allowed: boolean;
    }
    type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>;
    type Filter = TypedDeferredTopicFilter<Event>;
    type Log = TypedEventLog<Event>;
    type LogDescription = TypedLogDescription<Event>;
}
export interface ScopeGuard extends BaseContract {
    connect(runner?: ContractRunner | null): ScopeGuard;
    waitForDeployment(): Promise<this>;
    interface: ScopeGuardInterface;
    queryFilter<TCEvent extends TypedContractEvent>(event: TCEvent, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    queryFilter<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TypedEventLog<TCEvent>>>;
    on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
    once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>;
    listeners<TCEvent extends TypedContractEvent>(event: TCEvent): Promise<Array<TypedListener<TCEvent>>>;
    listeners(eventName?: string): Promise<Array<Listener>>;
    removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>;
    allowedTargets: TypedContractMethod<[
        arg0: AddressLike
    ], [
        [
            boolean,
            boolean,
            boolean,
            boolean,
            boolean
        ] & {
            allowed: boolean;
            scoped: boolean;
            delegateCallAllowed: boolean;
            fallbackAllowed: boolean;
            valueAllowed: boolean;
        }
    ], "view">;
    checkAfterExecution: TypedContractMethod<[
        arg0: BytesLike,
        arg1: boolean
    ], [
        void
    ], "view">;
    checkTransaction: TypedContractMethod<[
        to: AddressLike,
        value: BigNumberish,
        data: BytesLike,
        operation: BigNumberish,
        arg4: BigNumberish,
        arg5: BigNumberish,
        arg6: BigNumberish,
        arg7: AddressLike,
        arg8: AddressLike,
        arg9: BytesLike,
        arg10: AddressLike
    ], [
        void
    ], "view">;
    isAllowedFunction: TypedContractMethod<[
        target: AddressLike,
        functionSig: BytesLike
    ], [
        boolean
    ], "view">;
    isAllowedTarget: TypedContractMethod<[
        target: AddressLike
    ], [
        boolean
    ], "view">;
    isAllowedToDelegateCall: TypedContractMethod<[
        target: AddressLike
    ], [
        boolean
    ], "view">;
    isScoped: TypedContractMethod<[target: AddressLike], [boolean], "view">;
    isValueAllowed: TypedContractMethod<[target: AddressLike], [boolean], "view">;
    isfallbackAllowed: TypedContractMethod<[
        target: AddressLike
    ], [
        boolean
    ], "view">;
    owner: TypedContractMethod<[], [string], "view">;
    renounceOwnership: TypedContractMethod<[], [void], "nonpayable">;
    setAllowedFunction: TypedContractMethod<[
        target: AddressLike,
        functionSig: BytesLike,
        allow: boolean
    ], [
        void
    ], "nonpayable">;
    setDelegateCallAllowedOnTarget: TypedContractMethod<[
        target: AddressLike,
        allow: boolean
    ], [
        void
    ], "nonpayable">;
    setFallbackAllowedOnTarget: TypedContractMethod<[
        target: AddressLike,
        allow: boolean
    ], [
        void
    ], "nonpayable">;
    setScoped: TypedContractMethod<[
        target: AddressLike,
        scoped: boolean
    ], [
        void
    ], "nonpayable">;
    setTargetAllowed: TypedContractMethod<[
        target: AddressLike,
        allow: boolean
    ], [
        void
    ], "nonpayable">;
    setUp: TypedContractMethod<[
        initializeParams: BytesLike
    ], [
        void
    ], "nonpayable">;
    setValueAllowedOnTarget: TypedContractMethod<[
        target: AddressLike,
        allow: boolean
    ], [
        void
    ], "nonpayable">;
    supportsInterface: TypedContractMethod<[
        interfaceId: BytesLike
    ], [
        boolean
    ], "view">;
    transferOwnership: TypedContractMethod<[
        newOwner: AddressLike
    ], [
        void
    ], "nonpayable">;
    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;
    getFunction(nameOrSignature: "allowedTargets"): TypedContractMethod<[
        arg0: AddressLike
    ], [
        [
            boolean,
            boolean,
            boolean,
            boolean,
            boolean
        ] & {
            allowed: boolean;
            scoped: boolean;
            delegateCallAllowed: boolean;
            fallbackAllowed: boolean;
            valueAllowed: boolean;
        }
    ], "view">;
    getFunction(nameOrSignature: "checkAfterExecution"): TypedContractMethod<[arg0: BytesLike, arg1: boolean], [void], "view">;
    getFunction(nameOrSignature: "checkTransaction"): TypedContractMethod<[
        to: AddressLike,
        value: BigNumberish,
        data: BytesLike,
        operation: BigNumberish,
        arg4: BigNumberish,
        arg5: BigNumberish,
        arg6: BigNumberish,
        arg7: AddressLike,
        arg8: AddressLike,
        arg9: BytesLike,
        arg10: AddressLike
    ], [
        void
    ], "view">;
    getFunction(nameOrSignature: "isAllowedFunction"): TypedContractMethod<[
        target: AddressLike,
        functionSig: BytesLike
    ], [
        boolean
    ], "view">;
    getFunction(nameOrSignature: "isAllowedTarget"): TypedContractMethod<[target: AddressLike], [boolean], "view">;
    getFunction(nameOrSignature: "isAllowedToDelegateCall"): TypedContractMethod<[target: AddressLike], [boolean], "view">;
    getFunction(nameOrSignature: "isScoped"): TypedContractMethod<[target: AddressLike], [boolean], "view">;
    getFunction(nameOrSignature: "isValueAllowed"): TypedContractMethod<[target: AddressLike], [boolean], "view">;
    getFunction(nameOrSignature: "isfallbackAllowed"): TypedContractMethod<[target: AddressLike], [boolean], "view">;
    getFunction(nameOrSignature: "owner"): TypedContractMethod<[], [string], "view">;
    getFunction(nameOrSignature: "renounceOwnership"): TypedContractMethod<[], [void], "nonpayable">;
    getFunction(nameOrSignature: "setAllowedFunction"): TypedContractMethod<[
        target: AddressLike,
        functionSig: BytesLike,
        allow: boolean
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "setDelegateCallAllowedOnTarget"): TypedContractMethod<[
        target: AddressLike,
        allow: boolean
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "setFallbackAllowedOnTarget"): TypedContractMethod<[
        target: AddressLike,
        allow: boolean
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "setScoped"): TypedContractMethod<[
        target: AddressLike,
        scoped: boolean
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "setTargetAllowed"): TypedContractMethod<[
        target: AddressLike,
        allow: boolean
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "setUp"): TypedContractMethod<[initializeParams: BytesLike], [void], "nonpayable">;
    getFunction(nameOrSignature: "setValueAllowedOnTarget"): TypedContractMethod<[
        target: AddressLike,
        allow: boolean
    ], [
        void
    ], "nonpayable">;
    getFunction(nameOrSignature: "supportsInterface"): TypedContractMethod<[interfaceId: BytesLike], [boolean], "view">;
    getFunction(nameOrSignature: "transferOwnership"): TypedContractMethod<[newOwner: AddressLike], [void], "nonpayable">;
    getEvent(key: "OwnershipTransferred"): TypedContractEvent<OwnershipTransferredEvent.InputTuple, OwnershipTransferredEvent.OutputTuple, OwnershipTransferredEvent.OutputObject>;
    getEvent(key: "ScopeGuardSetup"): TypedContractEvent<ScopeGuardSetupEvent.InputTuple, ScopeGuardSetupEvent.OutputTuple, ScopeGuardSetupEvent.OutputObject>;
    getEvent(key: "SetDelegateCallAllowedOnTarget"): TypedContractEvent<SetDelegateCallAllowedOnTargetEvent.InputTuple, SetDelegateCallAllowedOnTargetEvent.OutputTuple, SetDelegateCallAllowedOnTargetEvent.OutputObject>;
    getEvent(key: "SetFallbackAllowedOnTarget"): TypedContractEvent<SetFallbackAllowedOnTargetEvent.InputTuple, SetFallbackAllowedOnTargetEvent.OutputTuple, SetFallbackAllowedOnTargetEvent.OutputObject>;
    getEvent(key: "SetFunctionAllowedOnTarget"): TypedContractEvent<SetFunctionAllowedOnTargetEvent.InputTuple, SetFunctionAllowedOnTargetEvent.OutputTuple, SetFunctionAllowedOnTargetEvent.OutputObject>;
    getEvent(key: "SetTargetAllowed"): TypedContractEvent<SetTargetAllowedEvent.InputTuple, SetTargetAllowedEvent.OutputTuple, SetTargetAllowedEvent.OutputObject>;
    getEvent(key: "SetTargetScoped"): TypedContractEvent<SetTargetScopedEvent.InputTuple, SetTargetScopedEvent.OutputTuple, SetTargetScopedEvent.OutputObject>;
    getEvent(key: "SetValueAllowedOnTarget"): TypedContractEvent<SetValueAllowedOnTargetEvent.InputTuple, SetValueAllowedOnTargetEvent.OutputTuple, SetValueAllowedOnTargetEvent.OutputObject>;
    filters: {
        "OwnershipTransferred(address,address)": TypedContractEvent<OwnershipTransferredEvent.InputTuple, OwnershipTransferredEvent.OutputTuple, OwnershipTransferredEvent.OutputObject>;
        OwnershipTransferred: TypedContractEvent<OwnershipTransferredEvent.InputTuple, OwnershipTransferredEvent.OutputTuple, OwnershipTransferredEvent.OutputObject>;
        "ScopeGuardSetup(address,address)": TypedContractEvent<ScopeGuardSetupEvent.InputTuple, ScopeGuardSetupEvent.OutputTuple, ScopeGuardSetupEvent.OutputObject>;
        ScopeGuardSetup: TypedContractEvent<ScopeGuardSetupEvent.InputTuple, ScopeGuardSetupEvent.OutputTuple, ScopeGuardSetupEvent.OutputObject>;
        "SetDelegateCallAllowedOnTarget(address,bool)": TypedContractEvent<SetDelegateCallAllowedOnTargetEvent.InputTuple, SetDelegateCallAllowedOnTargetEvent.OutputTuple, SetDelegateCallAllowedOnTargetEvent.OutputObject>;
        SetDelegateCallAllowedOnTarget: TypedContractEvent<SetDelegateCallAllowedOnTargetEvent.InputTuple, SetDelegateCallAllowedOnTargetEvent.OutputTuple, SetDelegateCallAllowedOnTargetEvent.OutputObject>;
        "SetFallbackAllowedOnTarget(address,bool)": TypedContractEvent<SetFallbackAllowedOnTargetEvent.InputTuple, SetFallbackAllowedOnTargetEvent.OutputTuple, SetFallbackAllowedOnTargetEvent.OutputObject>;
        SetFallbackAllowedOnTarget: TypedContractEvent<SetFallbackAllowedOnTargetEvent.InputTuple, SetFallbackAllowedOnTargetEvent.OutputTuple, SetFallbackAllowedOnTargetEvent.OutputObject>;
        "SetFunctionAllowedOnTarget(address,bytes4,bool)": TypedContractEvent<SetFunctionAllowedOnTargetEvent.InputTuple, SetFunctionAllowedOnTargetEvent.OutputTuple, SetFunctionAllowedOnTargetEvent.OutputObject>;
        SetFunctionAllowedOnTarget: TypedContractEvent<SetFunctionAllowedOnTargetEvent.InputTuple, SetFunctionAllowedOnTargetEvent.OutputTuple, SetFunctionAllowedOnTargetEvent.OutputObject>;
        "SetTargetAllowed(address,bool)": TypedContractEvent<SetTargetAllowedEvent.InputTuple, SetTargetAllowedEvent.OutputTuple, SetTargetAllowedEvent.OutputObject>;
        SetTargetAllowed: TypedContractEvent<SetTargetAllowedEvent.InputTuple, SetTargetAllowedEvent.OutputTuple, SetTargetAllowedEvent.OutputObject>;
        "SetTargetScoped(address,bool)": TypedContractEvent<SetTargetScopedEvent.InputTuple, SetTargetScopedEvent.OutputTuple, SetTargetScopedEvent.OutputObject>;
        SetTargetScoped: TypedContractEvent<SetTargetScopedEvent.InputTuple, SetTargetScopedEvent.OutputTuple, SetTargetScopedEvent.OutputObject>;
        "SetValueAllowedOnTarget(address,bool)": TypedContractEvent<SetValueAllowedOnTargetEvent.InputTuple, SetValueAllowedOnTargetEvent.OutputTuple, SetValueAllowedOnTargetEvent.OutputObject>;
        SetValueAllowedOnTarget: TypedContractEvent<SetValueAllowedOnTargetEvent.InputTuple, SetValueAllowedOnTargetEvent.OutputTuple, SetValueAllowedOnTargetEvent.OutputObject>;
    };
}

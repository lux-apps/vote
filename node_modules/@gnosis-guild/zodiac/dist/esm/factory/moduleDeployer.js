var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Contract, getCreate2Address, AbiCoder, solidityPackedKeccak256, keccak256, } from "ethers";
import { ContractAddresses, ContractAbis, ContractFactories, } from "../contracts";
import { ModuleProxyFactory__factory } from "../types";
/**
 * Get the transaction for deploying a module proxy through the Module Proxy Factory.
 * This will also initialize the module proxy by calling the setup function.
 *
 * @param moduleName Name of the module to deploy (must be present in `KnownContracts`)
 * @param setupArgs The arguments for the setup function of the module
 * @param provider
 * @param chainId
 * @param saltNonce
 * @returns the transaction and the expected address of the module proxy
 */
export const deployAndSetUpModule = (moduleName, setupArgs, provider, chainId, saltNonce) => __awaiter(void 0, void 0, void 0, function* () {
    const { moduleFactory, moduleMastercopy } = getModuleFactoryAndMasterCopy(moduleName, provider, chainId);
    return getDeployAndSetupTx(moduleFactory, moduleMastercopy, setupArgs, saltNonce);
});
/**
 * Get the transaction for deploying a module proxy through the Module Proxy Factory.
 * This will also initialize the module proxy by calling the setup function.
 *
 * This method is for modules that do not have a mastercopy listed in the `KnownContracts`
 * @param mastercopyAddress address of the mastercopy to use
 * @param abi abi of the module
 * @param setupArgs The arguments for the setup function of the module
 * @param provider
 * @param chainId
 * @param saltNonce
 * @returns the transaction and the expected address of the module proxy
 */
export const deployAndSetUpCustomModule = (mastercopyAddress, abi, setupArgs, provider, chainId, saltNonce) => __awaiter(void 0, void 0, void 0, function* () {
    const chainContracts = ContractAddresses[chainId];
    const moduleFactoryAddress = chainContracts.factory;
    const moduleFactory = new Contract(moduleFactoryAddress, ContractAbis.factory, provider);
    const moduleMastercopy = new Contract(mastercopyAddress, abi, provider);
    const deployAndSetupTx = yield getDeployAndSetupTx(moduleFactory, moduleMastercopy, setupArgs, saltNonce);
    return deployAndSetupTx;
});
const getDeployAndSetupTx = (moduleFactory, moduleMastercopy, setupArgs, saltNonce) => __awaiter(void 0, void 0, void 0, function* () {
    const encodedInitParams = AbiCoder.defaultAbiCoder().encode(setupArgs.types, setupArgs.values);
    const moduleSetupData = moduleMastercopy.interface.encodeFunctionData("setUp", [encodedInitParams]);
    const expectedModuleAddress = yield calculateProxyAddress(moduleFactory, yield moduleMastercopy.getAddress(), moduleSetupData, saltNonce);
    const deployData = moduleFactory.interface.encodeFunctionData("deployModule", [yield moduleMastercopy.getAddress(), moduleSetupData, saltNonce]);
    const transaction = {
        data: deployData,
        to: yield moduleFactory.getAddress(),
        value: BigInt(0),
    };
    return {
        transaction,
        expectedModuleAddress,
    };
});
export const calculateProxyAddress = (moduleFactory, mastercopyAddress, initData, saltNonce) => __awaiter(void 0, void 0, void 0, function* () {
    const mastercopyAddressFormatted = mastercopyAddress
        .toLowerCase()
        .replace(/^0x/, "");
    const byteCode = "0x602d8060093d393df3363d3d373d3d3d363d73" +
        mastercopyAddressFormatted +
        "5af43d82803e903d91602b57fd5bf3";
    const salt = solidityPackedKeccak256(["bytes32", "uint256"], [solidityPackedKeccak256(["bytes"], [initData]), saltNonce]);
    return getCreate2Address(yield moduleFactory.getAddress(), salt, keccak256(byteCode));
});
export const getModuleInstance = (moduleName, moduleAddress, provider) => {
    const moduleIsNotSupported = !Object.keys(ContractFactories).includes(moduleName);
    if (moduleIsNotSupported) {
        throw new Error("Module " + moduleName + " not supported");
    }
    return ContractFactories[moduleName].connect(moduleAddress, provider);
};
export const getModuleFactoryAndMasterCopy = (moduleName, provider, chainId) => {
    const chainContracts = ContractAddresses[chainId];
    const masterCopyAddress = chainContracts[moduleName];
    const factoryAddress = chainContracts.factory;
    const moduleMastercopy = getModuleInstance(moduleName, masterCopyAddress, provider);
    const moduleFactory = ModuleProxyFactory__factory.connect(factoryAddress, provider);
    return {
        moduleFactory,
        moduleMastercopy,
    };
};

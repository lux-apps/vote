import { Variables } from "graphql-request";
import type { Hat, Tree, HatPropsConfig, TreePropsConfig, WearerPropsConfig, Wearer, EndpointsConfig } from "./types";
export declare class HatsSubgraphClient {
    protected readonly _config: EndpointsConfig;
    constructor({ config }: {
        config?: EndpointsConfig;
    });
    protected _makeGqlRequest<ResponseType>(chainId: number, query: string, variables?: Variables): Promise<ResponseType>;
    /**
     * Get a Hat by its ID.
     * The Hat's properties to fetch are configurable, including nested objects.
     *
     * @param chainId Id of the chain to fetch from.
     * @param hatId ID of the Hat to fetch.
     * @param props Hat's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
     * @param filters Optional filters to include in the query.
     * @returns A Hat object.
     *
     * @throws InputValidationError
     * Thrown if the provided properties are invalid.
     *
     * @throws SubgraphHatNotExistError
     * Thrown if the Hat does not exist in the subgraph.
     */
    getHat({ chainId, hatId, props, }: {
        chainId: number;
        hatId: bigint;
        props: HatPropsConfig;
    }): Promise<Hat>;
    /**
     * Get Hats by their IDs.
     * The properties to fetch for each Hat are configurable, including nested objects.
     *
     * @param chainId Id of the chain to fetch from.
     * @param hatIds IDs of the Hats to fetch.
     * @param props Hat's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
     * @param filters Optional filters to include in the query.
     * @returns An array of Hat objects.
     *
     * @throws InputValidationError
     * Thrown if the provided properties are invalid.
     *
     * @throws SubgraphHatNotExistError
     * Thrown if one or more of the Hats do not exist in the subgraph.
     */
    getHatsByIds({ chainId, hatIds, props, }: {
        chainId: number;
        hatIds: bigint[];
        props: HatPropsConfig;
    }): Promise<Hat[]>;
    /**
     * Get a Tree by its ID.
     * The Tree's properties to fetch are configurable, including nested objects.
     *
     * @param chainId Id of the chain to fetch from.
     * @param treeId ID of the Tree to fetch (the tree's top-hat domain - first 4 bytes of the top-hat ID).
     * @param props Tree's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
     * @param filters Optional filters to include in the query.
     * @returns A Tree object.
     *
     * @throws InputValidationError
     * Thrown if the provided properties are invalid.
     *
     * @throws SubgraphTreeNotExistError
     * Thrown if the Tree does not exist in the subgraph.
     */
    getTree({ chainId, treeId, props, }: {
        chainId: number;
        treeId: number;
        props: TreePropsConfig;
    }): Promise<Tree>;
    /**
     * Get Trees by their IDs.
     * The properties to fetch for each Tree are configurable, including nested objects.
     *
     * @param chainId Id of the chain to fetch from.
     * @param treeIds ID of the Trees to fetch (the tree's top-hat domain - first 4 bytes of the top-hat ID).
     * @param props Tree's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
     * @param filters Optional filters to include in the query.
     * @returns An array of Tree objects.
     *
     * @throws InputValidationError
     * Thrown if the provided properties are invalid.
     *
     * @throws SubgraphTreeNotExistError
     * Thrown if one or more of the Trees do not exist in the subgraph.
     */
    getTreesByIds({ chainId, treeIds, props, }: {
        chainId: number;
        treeIds: number[];
        props: TreePropsConfig;
    }): Promise<Tree[]>;
    /**
     * Paginate over all existing Trees.
     * The properties to fetch for each Tree are configurable, including nested objects.
     *
     * @param chainId Id of the chain to fetch from.
     * @param props Tree's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
     * @param page Number of page to fetch.
     * @param perPage Number of Trees to fetch in each page.
     * @param filters - Optional filters to include in the query.
     * @returns An array of Tree objects.
     *
     * @throws InputValidationError
     * Thrown if the provided properties are invalid.
     */
    getTreesPaginated({ chainId, props, page, perPage, }: {
        chainId: number;
        props: TreePropsConfig;
        page: number;
        perPage: number;
    }): Promise<Tree[]>;
    /**
     * Get Wearer by its address.
     * The properties to fetch for each Wearer are configurable, including nested objects.
     *
     * @param chainId Id of the chain to fetch from.
     * @param wearerAddress Address of the wearer.
     * @param props Wearer's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
     * @param filters Optional filters to include in the query.
     * @returns A Wearer object.
     *
     * @throws InputValidationError
     * Thrown if the provided properties are invalid.
     *
     * @throws SubgraphWearerNotExistError
     * Thrown if the Wearer does not exist in the subgraph.
     */
    getWearer({ chainId, wearerAddress, props, }: {
        chainId: number;
        wearerAddress: `0x${string}`;
        props: WearerPropsConfig;
    }): Promise<Wearer>;
    /**
     * Paginate over the Wearers of a Hat.
     * The properties to fetch for each Wearer are configurable, including nested objects.
     *
     * @param chainId Id of the chain to fetch from.
     * @param hatId ID of the Hat for which Wearers to fetch.
     * @param props Wearer's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
     * @param page Number of page to fetch.
     * @param perPage Number of Wearers to fetch in each page.
     * @param filters Optional filters to include in the query.
     * @returns A Wearer object.
     *
     * @throws InputValidationError
     * Thrown if the provided properties are invalid.
     *
     * @throws SubgraphHatNotExistError
     * Thrown if the Hat does not exist in the subgraph.
     */
    getWearersOfHatPaginated({ chainId, hatId, props, page, perPage, }: {
        chainId: number;
        hatId: bigint;
        props: WearerPropsConfig;
        page: number;
        perPage: number;
    }): Promise<Wearer[]>;
    /**
     * Search Hat, Tree or Wearer by ID.
     * The properties to fetch for each object are configurable, including nested objects.
     *
     * @param chainId Id of the chain to fetch from.
     * @param search ID to search for (Hat ID or pretty ID, Tree ID or Wearer address).
     * @param treeProps Tree's properties to fetch (if Tree was found), including the properties of nested objects. Pass an empty object to include only the object's ID.
     * @param hatProps Hat's properties to fetch (if Hat was found), including the properties of nested objects. Pass an empty object to include only the object's ID.
     * @param wearerProps Wearer's properties to fetch (if Wearer was found), including the properties of nested objects. Pass an empty object to include only the object's ID.
     * @param filters Optional filters to include in the query.
     * @returns An object containing the search result.
     *
     * @throws InputValidationError
     * Thrown if the provided properties are invalid.
     */
    searchTreesHatsWearers({ chainId, search, treeProps, hatProps, wearerProps, }: {
        chainId: number;
        search: string;
        treeProps: TreePropsConfig;
        hatProps: HatPropsConfig;
        wearerProps: WearerPropsConfig;
    }): Promise<{
        trees: Tree[];
        hats: Hat[];
        wearers: Wearer[];
    }>;
}
//# sourceMappingURL=client.d.ts.map
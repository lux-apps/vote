// src/utils.ts
function hatIdDecimalToHex(hatId) {
  return "0x" + BigInt(hatId).toString(16).padStart(64, "0");
}
function treeIdDecimalToHex(treeId) {
  return "0x" + treeId.toString(16).padStart(8, "0");
}
function normalizeProps(config) {
  const fields = ["id"];
  for (const [key, value] of Object.entries(config)) {
    if (typeof value !== "object" && value === true) {
      fields.push(key);
    }
    if (typeof value === "object") {
      const withPropsAndFilters = "props" in value ? true : false;
      const subFields = normalizeProps(
        withPropsAndFilters ? value.props : value
      );
      const obj = {
        objName: key,
        objProps: subFields
      };
      if (withPropsAndFilters && value.filters !== void 0 && value.filters.first !== void 0) {
        obj["objFilters"] = { first: value.filters.first };
      }
      fields.push(obj);
    }
  }
  return fields;
}
function normalizedPropsToQueryFields(props) {
  let fields = "";
  for (let i = 0; i < props.length; i++) {
    if (i > 0) {
      fields += ", ";
    }
    const elem = props[i];
    if (typeof elem === "string") {
      fields = fields + `${elem}`;
    }
    if (typeof elem === "object") {
      const name = elem["objName"];
      const props2 = elem["objProps"];
      const first = elem["objFilters"] !== void 0 ? elem["objFilters"]["first"] : void 0;
      if (first !== void 0) {
        if (name === "events") {
          fields = fields + `${name} (orderBy: timestamp, orderDirection: desc, first: ${first}) { ${normalizedPropsToQueryFields(
            props2
          )} 
            __typename 
            ... on HatCreatedEvent { hatDetails hatMaxSupply hatEligibility hatToggle hatMutable hatImageUri } 
            ... on HatMintedEvent { wearer { id } operator } 
            ... on HatBurnedEvent { wearer { id } operator } 
            ... on HatStatusChangedEvent { hatNewStatus } 
            ... on HatDetailsChangedEvent { hatNewDetails } 
            ... on HatEligibilityChangedEvent { hatNewEligibility } 
            ... on HatToggleChangedEvent { hatNewToggle } 
            ... on HatMaxSupplyChangedEvent { hatNewMaxSupply } 
            ... on HatImageURIChangedEvent { hatNewImageURI } 
            ... on TopHatLinkRequestedEvent { newAdmin } 
            ... on TopHatLinkedEvent { newAdmin } 
            ... on WearerStandingChangedEvent { wearer { id } wearerStanding } 
          }`;
        } else {
          fields = fields + `${name} (first: ${first}) { ${normalizedPropsToQueryFields(
            props2
          )} }`;
        }
      } else {
        if (name === "events") {
          fields = fields + `${name} (orderBy: timestamp, orderDirection: desc) { 
              ${normalizedPropsToQueryFields(props2)} 
              __typename 
              ... on HatCreatedEvent { hatDetails hatMaxSupply hatEligibility hatToggle hatMutable hatImageUri } 
              ... on HatMintedEvent { wearer { id } operator } 
              ... on HatBurnedEvent { wearer { id } operator } 
              ... on HatStatusChangedEvent { hatNewStatus } 
              ... on HatDetailsChangedEvent { hatNewDetails } 
              ... on HatEligibilityChangedEvent { hatNewEligibility } 
              ... on HatToggleChangedEvent { hatNewToggle } 
              ... on HatMaxSupplyChangedEvent { hatNewMaxSupply } 
              ... on HatImageURIChangedEvent { hatNewImageURI } 
              ... on TopHatLinkRequestedEvent { newAdmin } 
              ... on TopHatLinkedEvent { newAdmin } 
              ... on WearerStandingChangedEvent { wearer { id } wearerStanding } 
            }`;
        } else {
          fields = fields + `${name} { ${normalizedPropsToQueryFields(props2)} }`;
        }
      }
    }
  }
  return fields;
}

// src/client.ts
import { gql, GraphQLClient } from "graphql-request";

// src/endpoints.ts
var DEFAULT_ENDPOINTS_CONFIG = {
  1: {
    endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-ethereum/version/latest"
  },
  10: {
    endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-optimism/version/latest"
  },
  100: {
    endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-gnosis-chain/version/latest"
  },
  137: {
    endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-polygon/version/latest"
  },
  42161: {
    endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-arbitrum/version/latest"
  },
  11155111: {
    endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-sepolia/version/latest"
  },
  8453: {
    endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-base/version/latest"
  },
  42220: {
    endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-celo/version/latest"
  },
  84532: {
    endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-base-sepolia/version/latest"
  }
};

// src/errors.ts
var SubgraphNotSupportedError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "SubgraphNotSupportedError";
  }
};
var SubgraphHatNotExistError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "SubgraphHatNotExistError";
  }
};
var SubgraphTreeNotExistError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "SubgraphTreeNotExistError";
  }
};
var SubgraphWearerNotExistError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "SubgraphWearerNotExistError";
  }
};
var InputValidationError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "InputValidationError";
  }
};

// src/schemas.ts
import { z } from "zod";
var hatPropsConfigSchema = z.object({
  prettyId: z.boolean().optional(),
  status: z.boolean().optional(),
  createdAt: z.boolean().optional(),
  details: z.boolean().optional(),
  maxSupply: z.boolean().optional(),
  eligibility: z.boolean().optional(),
  toggle: z.boolean().optional(),
  mutable: z.boolean().optional(),
  imageUri: z.boolean().optional(),
  levelAtLocalTree: z.boolean().optional(),
  currentSupply: z.boolean().optional(),
  tree: z.lazy(() => treePropsConfigSchema).optional(),
  wearers: z.lazy(() => wearersConfigSchema).optional(),
  badStandings: z.lazy(() => wearersConfigSchema).optional(),
  admin: z.lazy(() => hatPropsConfigSchema).optional(),
  subHats: z.lazy(() => hatsConfigSchema).optional(),
  linkRequestFromTree: z.lazy(() => treesConfigSchema).optional(),
  linkedTrees: z.lazy(() => treesConfigSchema).optional(),
  claimableBy: z.lazy(() => claimsHattersConfig).optional(),
  claimableForBy: z.lazy(() => claimsHattersConfig).optional(),
  events: z.lazy(() => hatsEventsConfigSchema).optional()
}).strict();
var hatsConfigSchema = z.object({
  props: z.object({
    prettyId: z.boolean().optional(),
    status: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    details: z.boolean().optional(),
    maxSupply: z.boolean().optional(),
    eligibility: z.boolean().optional(),
    toggle: z.boolean().optional(),
    mutable: z.boolean().optional(),
    imageUri: z.boolean().optional(),
    levelAtLocalTree: z.boolean().optional(),
    currentSupply: z.boolean().optional(),
    tree: z.lazy(() => treePropsConfigSchema).optional(),
    wearers: z.lazy(() => wearersConfigSchema).optional(),
    badStandings: z.lazy(() => wearersConfigSchema).optional(),
    admin: z.lazy(() => hatPropsConfigSchema).optional(),
    subHats: z.lazy(() => hatsConfigSchema).optional(),
    linkRequestFromTree: z.lazy(() => treesConfigSchema).optional(),
    linkedTrees: z.lazy(() => treesConfigSchema).optional(),
    claimableBy: z.lazy(() => claimsHattersConfig).optional(),
    claimableForBy: z.lazy(() => claimsHattersConfig).optional(),
    events: z.lazy(() => hatsEventsConfigSchema).optional()
  }),
  filters: z.object({
    first: z.number().optional()
  }).optional()
}).strict();
var treePropsConfigSchema = z.object({
  hats: z.lazy(() => hatsConfigSchema).optional(),
  childOfTree: z.lazy(() => treePropsConfigSchema).optional(),
  parentOfTrees: z.lazy(() => treesConfigSchema).optional(),
  linkedToHat: z.lazy(() => hatPropsConfigSchema).optional(),
  linkRequestFromTree: z.lazy(() => treesConfigSchema).optional(),
  requestedLinkToTree: z.lazy(() => treePropsConfigSchema).optional(),
  requestedLinkToHat: z.lazy(() => hatPropsConfigSchema).optional(),
  events: z.lazy(() => hatsEventsConfigSchema).optional()
}).strict();
var treesConfigSchema = z.object({
  props: z.object({
    hats: z.lazy(() => hatsConfigSchema).optional(),
    childOfTree: z.lazy(() => treePropsConfigSchema).optional(),
    parentOfTrees: z.lazy(() => treesConfigSchema).optional(),
    linkedToHat: z.lazy(() => hatPropsConfigSchema).optional(),
    linkRequestFromTree: z.lazy(() => treesConfigSchema).optional(),
    requestedLinkToTree: z.lazy(() => treePropsConfigSchema).optional(),
    requestedLinkToHat: z.lazy(() => hatPropsConfigSchema).optional(),
    events: z.lazy(() => hatsEventsConfigSchema).optional()
  }),
  filters: z.object({
    first: z.number().optional()
  }).optional()
}).strict();
var wearerPropsConfigSchema = z.object({
  currentHats: z.lazy(() => hatsConfigSchema).optional(),
  mintEvent: z.lazy(() => hatsEventsConfigSchema).optional(),
  burnEvent: z.lazy(() => hatsEventsConfigSchema).optional()
}).strict();
var wearersConfigSchema = z.object({
  props: z.object({
    currentHats: z.lazy(() => hatsConfigSchema).optional(),
    mintEvent: z.lazy(() => hatsEventsConfigSchema).optional(),
    burnEvent: z.lazy(() => hatsEventsConfigSchema).optional()
  }),
  filters: z.object({
    first: z.number().optional()
  }).optional()
}).strict();
var claimsHatterPropsConfigSchema = z.object({
  claimableHats: z.lazy(() => hatsConfigSchema).optional(),
  claimableForHats: z.lazy(() => hatsConfigSchema).optional()
}).strict();
var claimsHattersConfig = z.object({
  props: z.object({
    claimableHats: z.lazy(() => hatsConfigSchema).optional(),
    claimableForHats: z.lazy(() => hatsConfigSchema).optional()
  }),
  filters: z.object({
    first: z.number().optional()
  }).optional()
}).strict();
var hatsEventPropsConfigSchema = z.object({
  timestamp: z.boolean().optional(),
  blockNumber: z.boolean().optional(),
  transactionID: z.boolean().optional(),
  hat: z.lazy(() => hatPropsConfigSchema).optional(),
  tree: z.lazy(() => treePropsConfigSchema).optional()
}).strict();
var hatsEventsConfigSchema = z.object({
  props: z.object({
    timestamp: z.boolean().optional(),
    blockNumber: z.boolean().optional(),
    transactionID: z.boolean().optional(),
    hat: z.lazy(() => hatPropsConfigSchema).optional(),
    tree: z.lazy(() => treePropsConfigSchema).optional()
  }),
  filters: z.object({
    first: z.number().optional()
  }).optional()
}).strict();

// src/client.ts
var HatsSubgraphClient = class {
  constructor({ config }) {
    if (config === void 0) {
      this._config = DEFAULT_ENDPOINTS_CONFIG;
    } else {
      this._config = config;
    }
  }
  async _makeGqlRequest(chainId, query, variables) {
    if (this._config[chainId] === void 0) {
      throw new SubgraphNotSupportedError(
        `No subgraph support for network id ${chainId}`
      );
    }
    const client = new GraphQLClient(this._config[chainId].endpoint);
    if (this._config[chainId].authToken !== void 0) {
      client.setHeader("Authorization", `Bearer ${this._config[chainId].authToken}`);
    }
    const result = await client.request(query, variables);
    return result;
  }
  /**
   * Get a Hat by its ID.
   * The Hat's properties to fetch are configurable, including nested objects.
   *
   * @param chainId Id of the chain to fetch from.
   * @param hatId ID of the Hat to fetch.
   * @param props Hat's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
   * @param filters Optional filters to include in the query.
   * @returns A Hat object.
   *
   * @throws InputValidationError
   * Thrown if the provided properties are invalid.
   *
   * @throws SubgraphHatNotExistError
   * Thrown if the Hat does not exist in the subgraph.
   */
  async getHat({
    chainId,
    hatId,
    props
  }) {
    const validationRes = hatPropsConfigSchema.safeParse(props);
    if (validationRes.success === false) {
      throw new InputValidationError(validationRes.error.message);
    }
    const hatIdHex = hatIdDecimalToHex(hatId);
    const normalizedProps = normalizeProps(props);
    const queryFields = normalizedPropsToQueryFields(normalizedProps);
    const query = gql`
      query getHat($id: ID!) {
        hat(id: $id) {
          ${queryFields}
        }
      }
    `;
    const response = await this._makeGqlRequest(chainId, query, {
      id: hatIdHex
    });
    if (!response.hat) {
      throw new SubgraphHatNotExistError(
        `Hat with an ID of ${hatId} does not exist in the subgraph for chain ID ${chainId}`
      );
    }
    return response.hat;
  }
  /**
   * Get Hats by their IDs.
   * The properties to fetch for each Hat are configurable, including nested objects.
   *
   * @param chainId Id of the chain to fetch from.
   * @param hatIds IDs of the Hats to fetch.
   * @param props Hat's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
   * @param filters Optional filters to include in the query.
   * @returns An array of Hat objects.
   *
   * @throws InputValidationError
   * Thrown if the provided properties are invalid.
   *
   * @throws SubgraphHatNotExistError
   * Thrown if one or more of the Hats do not exist in the subgraph.
   */
  async getHatsByIds({
    chainId,
    hatIds,
    props
  }) {
    const validationRes = hatPropsConfigSchema.safeParse(props);
    if (validationRes.success === false) {
      throw new InputValidationError(validationRes.error.message);
    }
    const hatIdsHex = hatIds.map((id) => hatIdDecimalToHex(id));
    const normalizedProps = normalizeProps(props);
    const queryFields = normalizedPropsToQueryFields(normalizedProps);
    const query = gql`
      query getHatsByIds($ids: [ID!]!) {
        hats(where: { id_in: $ids }) {
            ${queryFields}
        }
      }
    `;
    const response = await this._makeGqlRequest(
      chainId,
      query,
      {
        ids: hatIdsHex
      }
    );
    if (!response.hats || response.hats.length < hatIds.length) {
      throw new SubgraphHatNotExistError(
        `One or more of the provided hats do not exist in the subgraph for chain ID ${chainId}`
      );
    }
    return response.hats;
  }
  /**
   * Get a Tree by its ID.
   * The Tree's properties to fetch are configurable, including nested objects.
   *
   * @param chainId Id of the chain to fetch from.
   * @param treeId ID of the Tree to fetch (the tree's top-hat domain - first 4 bytes of the top-hat ID).
   * @param props Tree's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
   * @param filters Optional filters to include in the query.
   * @returns A Tree object.
   *
   * @throws InputValidationError
   * Thrown if the provided properties are invalid.
   *
   * @throws SubgraphTreeNotExistError
   * Thrown if the Tree does not exist in the subgraph.
   */
  async getTree({
    chainId,
    treeId,
    props
  }) {
    const validationRes = treePropsConfigSchema.safeParse(props);
    if (validationRes.success === false) {
      throw new InputValidationError(validationRes.error.message);
    }
    const treeIdHex = treeIdDecimalToHex(treeId);
    const normalizedProps = normalizeProps(props);
    const queryFields = normalizedPropsToQueryFields(normalizedProps);
    const query = gql`
      query getTree($id: ID!) {
        tree(id: $id) {
          ${queryFields}
        }
      }
    `;
    const response = await this._makeGqlRequest(chainId, query, {
      id: treeIdHex
    });
    if (!response.tree) {
      throw new SubgraphTreeNotExistError(
        `Tree with an ID of ${treeId} does not exist in the subgraph for chain ID ${chainId}`
      );
    }
    return response.tree;
  }
  /**
   * Get Trees by their IDs.
   * The properties to fetch for each Tree are configurable, including nested objects.
   *
   * @param chainId Id of the chain to fetch from.
   * @param treeIds ID of the Trees to fetch (the tree's top-hat domain - first 4 bytes of the top-hat ID).
   * @param props Tree's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
   * @param filters Optional filters to include in the query.
   * @returns An array of Tree objects.
   *
   * @throws InputValidationError
   * Thrown if the provided properties are invalid.
   *
   * @throws SubgraphTreeNotExistError
   * Thrown if one or more of the Trees do not exist in the subgraph.
   */
  async getTreesByIds({
    chainId,
    treeIds,
    props
  }) {
    const validationRes = treePropsConfigSchema.safeParse(props);
    if (validationRes.success === false) {
      throw new InputValidationError(validationRes.error.message);
    }
    const treeIdsHex = treeIds.map((treeId) => treeIdDecimalToHex(treeId));
    const normalizedProps = normalizeProps(props);
    const queryFields = normalizedPropsToQueryFields(normalizedProps);
    const query = gql`
    query getTreesById($ids: [ID!]!) {
      trees(where: { id_in: $ids }) {
        ${queryFields}
      }
    }
  `;
    const response = await this._makeGqlRequest(
      chainId,
      query,
      {
        ids: treeIdsHex
      }
    );
    if (!response.trees || response.trees.length < treeIds.length) {
      throw new SubgraphTreeNotExistError(
        `One or more of the provided trees do not exist in the subgraph for chain ID ${chainId}`
      );
    }
    return response.trees;
  }
  /**
   * Paginate over all existing Trees.
   * The properties to fetch for each Tree are configurable, including nested objects.
   *
   * @param chainId Id of the chain to fetch from.
   * @param props Tree's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
   * @param page Number of page to fetch.
   * @param perPage Number of Trees to fetch in each page.
   * @param filters - Optional filters to include in the query.
   * @returns An array of Tree objects.
   *
   * @throws InputValidationError
   * Thrown if the provided properties are invalid.
   */
  async getTreesPaginated({
    chainId,
    props,
    page,
    perPage
  }) {
    const validationRes = treePropsConfigSchema.safeParse(props);
    if (validationRes.success === false) {
      throw new InputValidationError(validationRes.error.message);
    }
    const normalizedProps = normalizeProps(props);
    const queryFields = normalizedPropsToQueryFields(normalizedProps);
    const query = gql`
    query getPaginatedTrees($skip: Int!, $first: Int!) {
      trees(skip: $skip, first: $first) {
        ${queryFields}
      }
    }
  `;
    const response = await this._makeGqlRequest(
      chainId,
      query,
      {
        skip: page * perPage,
        first: perPage
      }
    );
    if (!response.trees) {
      throw new Error("Unexpected error");
    }
    return response.trees;
  }
  /**
   * Get Wearer by its address.
   * The properties to fetch for each Wearer are configurable, including nested objects.
   *
   * @param chainId Id of the chain to fetch from.
   * @param wearerAddress Address of the wearer.
   * @param props Wearer's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
   * @param filters Optional filters to include in the query.
   * @returns A Wearer object.
   *
   * @throws InputValidationError
   * Thrown if the provided properties are invalid.
   *
   * @throws SubgraphWearerNotExistError
   * Thrown if the Wearer does not exist in the subgraph.
   */
  async getWearer({
    chainId,
    wearerAddress,
    props
  }) {
    const validationRes = wearerPropsConfigSchema.safeParse(props);
    if (validationRes.success === false) {
      throw new InputValidationError(validationRes.error.message);
    }
    const wearerAddressLowerCase = wearerAddress.toLowerCase();
    const normalizedProps = normalizeProps(props);
    const queryFields = normalizedPropsToQueryFields(normalizedProps);
    const query = gql`
      query getCurrentHatsForWearer($id: ID!) {
        wearer(id: $id) {
            ${queryFields}
        }
      }
    `;
    const response = await this._makeGqlRequest(
      chainId,
      query,
      {
        id: wearerAddressLowerCase
      }
    );
    if (!response.wearer) {
      throw new SubgraphWearerNotExistError(
        `Wearer with an address of ${wearerAddress} does not exist in the subgraph for chain ID ${chainId}`
      );
    }
    return response.wearer;
  }
  /**
   * Paginate over the Wearers of a Hat.
   * The properties to fetch for each Wearer are configurable, including nested objects.
   *
   * @param chainId Id of the chain to fetch from.
   * @param hatId ID of the Hat for which Wearers to fetch.
   * @param props Wearer's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
   * @param page Number of page to fetch.
   * @param perPage Number of Wearers to fetch in each page.
   * @param filters Optional filters to include in the query.
   * @returns A Wearer object.
   *
   * @throws InputValidationError
   * Thrown if the provided properties are invalid.
   *
   * @throws SubgraphHatNotExistError
   * Thrown if the Hat does not exist in the subgraph.
   */
  async getWearersOfHatPaginated({
    chainId,
    hatId,
    props,
    page,
    perPage
  }) {
    const validationRes = wearerPropsConfigSchema.safeParse(props);
    if (validationRes.success === false) {
      throw new InputValidationError(validationRes.error.message);
    }
    const hatIdHex = hatIdDecimalToHex(hatId);
    const normalizedProps = normalizeProps(props);
    const queryFields = normalizedPropsToQueryFields(normalizedProps);
    const query = gql`
      query getPaginatedWearersForHat($hatId: ID!, $first: Int!, $skip: Int!) {
        hat(id: $hatId) {
            wearers(skip: $skip, first: $first) {
                ${queryFields}
            }
        }
      }
    `;
    const response = await this._makeGqlRequest(
      chainId,
      query,
      {
        hatId: hatIdHex,
        skip: page * perPage,
        first: perPage
      }
    );
    if (!response.hat) {
      throw new SubgraphHatNotExistError(
        `Hat with an ID of ${hatId} does not exist in the subgraph for chain ID ${chainId}`
      );
    }
    return response.hat.wearers;
  }
  /**
   * Search Hat, Tree or Wearer by ID.
   * The properties to fetch for each object are configurable, including nested objects.
   *
   * @param chainId Id of the chain to fetch from.
   * @param search ID to search for (Hat ID or pretty ID, Tree ID or Wearer address).
   * @param treeProps Tree's properties to fetch (if Tree was found), including the properties of nested objects. Pass an empty object to include only the object's ID.
   * @param hatProps Hat's properties to fetch (if Hat was found), including the properties of nested objects. Pass an empty object to include only the object's ID.
   * @param wearerProps Wearer's properties to fetch (if Wearer was found), including the properties of nested objects. Pass an empty object to include only the object's ID.
   * @param filters Optional filters to include in the query.
   * @returns An object containing the search result.
   *
   * @throws InputValidationError
   * Thrown if the provided properties are invalid.
   */
  async searchTreesHatsWearers({
    chainId,
    search,
    treeProps,
    hatProps,
    wearerProps
  }) {
    const treeValidationRes = treePropsConfigSchema.safeParse(treeProps);
    if (treeValidationRes.success === false) {
      throw new InputValidationError(treeValidationRes.error.message);
    }
    const hatValidationRes = hatPropsConfigSchema.safeParse(hatProps);
    if (hatValidationRes.success === false) {
      throw new InputValidationError(hatValidationRes.error.message);
    }
    const wearerValidationRes = wearerPropsConfigSchema.safeParse(wearerProps);
    if (wearerValidationRes.success === false) {
      throw new InputValidationError(wearerValidationRes.error.message);
    }
    const treeNormalizedProps = normalizeProps(treeProps);
    const treeQueryFields = normalizedPropsToQueryFields(treeNormalizedProps);
    const hatNormalizedProps = normalizeProps(hatProps);
    const hatQueryFields = normalizedPropsToQueryFields(hatNormalizedProps);
    const wearerNormalizedProps = normalizeProps(wearerProps);
    const wearerQueryFields = normalizedPropsToQueryFields(
      wearerNormalizedProps
    );
    const query = gql`
      query search($search: String!) {
        trees(where: { id: $search }) {
          ${treeQueryFields}
        }
        hats(where: { or: [{ id: $search }, { prettyId: $search }] }) {
          ${hatQueryFields}
        }
        wearers(where: { id: $search }) {
          ${wearerQueryFields}
        }
      }
    `;
    const response = await this._makeGqlRequest(chainId, query, {
      search: search.toLowerCase()
    });
    if (!response.wearers || !response.trees || !response.hats) {
      throw new Error("Unexpected error");
    }
    return response;
  }
};
export {
  DEFAULT_ENDPOINTS_CONFIG,
  HatsSubgraphClient
};
//# sourceMappingURL=index.mjs.map
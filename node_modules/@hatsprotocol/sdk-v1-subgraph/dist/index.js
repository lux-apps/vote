"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  DEFAULT_ENDPOINTS_CONFIG: () => DEFAULT_ENDPOINTS_CONFIG,
  HatsSubgraphClient: () => HatsSubgraphClient
});
module.exports = __toCommonJS(index_exports);

// src/utils.ts
function hatIdDecimalToHex(hatId) {
  return "0x" + BigInt(hatId).toString(16).padStart(64, "0");
}
function treeIdDecimalToHex(treeId) {
  return "0x" + treeId.toString(16).padStart(8, "0");
}
function normalizeProps(config) {
  const fields = ["id"];
  for (const [key, value] of Object.entries(config)) {
    if (typeof value !== "object" && value === true) {
      fields.push(key);
    }
    if (typeof value === "object") {
      const withPropsAndFilters = "props" in value ? true : false;
      const subFields = normalizeProps(
        withPropsAndFilters ? value.props : value
      );
      const obj = {
        objName: key,
        objProps: subFields
      };
      if (withPropsAndFilters && value.filters !== void 0 && value.filters.first !== void 0) {
        obj["objFilters"] = { first: value.filters.first };
      }
      fields.push(obj);
    }
  }
  return fields;
}
function normalizedPropsToQueryFields(props) {
  let fields = "";
  for (let i = 0; i < props.length; i++) {
    if (i > 0) {
      fields += ", ";
    }
    const elem = props[i];
    if (typeof elem === "string") {
      fields = fields + `${elem}`;
    }
    if (typeof elem === "object") {
      const name = elem["objName"];
      const props2 = elem["objProps"];
      const first = elem["objFilters"] !== void 0 ? elem["objFilters"]["first"] : void 0;
      if (first !== void 0) {
        if (name === "events") {
          fields = fields + `${name} (orderBy: timestamp, orderDirection: desc, first: ${first}) { ${normalizedPropsToQueryFields(
            props2
          )} 
            __typename 
            ... on HatCreatedEvent { hatDetails hatMaxSupply hatEligibility hatToggle hatMutable hatImageUri } 
            ... on HatMintedEvent { wearer { id } operator } 
            ... on HatBurnedEvent { wearer { id } operator } 
            ... on HatStatusChangedEvent { hatNewStatus } 
            ... on HatDetailsChangedEvent { hatNewDetails } 
            ... on HatEligibilityChangedEvent { hatNewEligibility } 
            ... on HatToggleChangedEvent { hatNewToggle } 
            ... on HatMaxSupplyChangedEvent { hatNewMaxSupply } 
            ... on HatImageURIChangedEvent { hatNewImageURI } 
            ... on TopHatLinkRequestedEvent { newAdmin } 
            ... on TopHatLinkedEvent { newAdmin } 
            ... on WearerStandingChangedEvent { wearer { id } wearerStanding } 
          }`;
        } else {
          fields = fields + `${name} (first: ${first}) { ${normalizedPropsToQueryFields(
            props2
          )} }`;
        }
      } else {
        if (name === "events") {
          fields = fields + `${name} (orderBy: timestamp, orderDirection: desc) { 
              ${normalizedPropsToQueryFields(props2)} 
              __typename 
              ... on HatCreatedEvent { hatDetails hatMaxSupply hatEligibility hatToggle hatMutable hatImageUri } 
              ... on HatMintedEvent { wearer { id } operator } 
              ... on HatBurnedEvent { wearer { id } operator } 
              ... on HatStatusChangedEvent { hatNewStatus } 
              ... on HatDetailsChangedEvent { hatNewDetails } 
              ... on HatEligibilityChangedEvent { hatNewEligibility } 
              ... on HatToggleChangedEvent { hatNewToggle } 
              ... on HatMaxSupplyChangedEvent { hatNewMaxSupply } 
              ... on HatImageURIChangedEvent { hatNewImageURI } 
              ... on TopHatLinkRequestedEvent { newAdmin } 
              ... on TopHatLinkedEvent { newAdmin } 
              ... on WearerStandingChangedEvent { wearer { id } wearerStanding } 
            }`;
        } else {
          fields = fields + `${name} { ${normalizedPropsToQueryFields(props2)} }`;
        }
      }
    }
  }
  return fields;
}

// src/client.ts
var import_graphql_request = require("graphql-request");

// src/endpoints.ts
var DEFAULT_ENDPOINTS_CONFIG = {
  1: {
    endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-ethereum/version/latest"
  },
  10: {
    endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-optimism/version/latest"
  },
  100: {
    endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-gnosis-chain/version/latest"
  },
  137: {
    endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-polygon/version/latest"
  },
  42161: {
    endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-arbitrum/version/latest"
  },
  11155111: {
    endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-sepolia/version/latest"
  },
  8453: {
    endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-base/version/latest"
  },
  42220: {
    endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-celo/version/latest"
  },
  84532: {
    endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-base-sepolia/version/latest"
  }
};

// src/errors.ts
var SubgraphNotSupportedError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "SubgraphNotSupportedError";
  }
};
var SubgraphHatNotExistError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "SubgraphHatNotExistError";
  }
};
var SubgraphTreeNotExistError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "SubgraphTreeNotExistError";
  }
};
var SubgraphWearerNotExistError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "SubgraphWearerNotExistError";
  }
};
var InputValidationError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "InputValidationError";
  }
};

// src/schemas.ts
var import_zod = require("zod");
var hatPropsConfigSchema = import_zod.z.object({
  prettyId: import_zod.z.boolean().optional(),
  status: import_zod.z.boolean().optional(),
  createdAt: import_zod.z.boolean().optional(),
  details: import_zod.z.boolean().optional(),
  maxSupply: import_zod.z.boolean().optional(),
  eligibility: import_zod.z.boolean().optional(),
  toggle: import_zod.z.boolean().optional(),
  mutable: import_zod.z.boolean().optional(),
  imageUri: import_zod.z.boolean().optional(),
  levelAtLocalTree: import_zod.z.boolean().optional(),
  currentSupply: import_zod.z.boolean().optional(),
  tree: import_zod.z.lazy(() => treePropsConfigSchema).optional(),
  wearers: import_zod.z.lazy(() => wearersConfigSchema).optional(),
  badStandings: import_zod.z.lazy(() => wearersConfigSchema).optional(),
  admin: import_zod.z.lazy(() => hatPropsConfigSchema).optional(),
  subHats: import_zod.z.lazy(() => hatsConfigSchema).optional(),
  linkRequestFromTree: import_zod.z.lazy(() => treesConfigSchema).optional(),
  linkedTrees: import_zod.z.lazy(() => treesConfigSchema).optional(),
  claimableBy: import_zod.z.lazy(() => claimsHattersConfig).optional(),
  claimableForBy: import_zod.z.lazy(() => claimsHattersConfig).optional(),
  events: import_zod.z.lazy(() => hatsEventsConfigSchema).optional()
}).strict();
var hatsConfigSchema = import_zod.z.object({
  props: import_zod.z.object({
    prettyId: import_zod.z.boolean().optional(),
    status: import_zod.z.boolean().optional(),
    createdAt: import_zod.z.boolean().optional(),
    details: import_zod.z.boolean().optional(),
    maxSupply: import_zod.z.boolean().optional(),
    eligibility: import_zod.z.boolean().optional(),
    toggle: import_zod.z.boolean().optional(),
    mutable: import_zod.z.boolean().optional(),
    imageUri: import_zod.z.boolean().optional(),
    levelAtLocalTree: import_zod.z.boolean().optional(),
    currentSupply: import_zod.z.boolean().optional(),
    tree: import_zod.z.lazy(() => treePropsConfigSchema).optional(),
    wearers: import_zod.z.lazy(() => wearersConfigSchema).optional(),
    badStandings: import_zod.z.lazy(() => wearersConfigSchema).optional(),
    admin: import_zod.z.lazy(() => hatPropsConfigSchema).optional(),
    subHats: import_zod.z.lazy(() => hatsConfigSchema).optional(),
    linkRequestFromTree: import_zod.z.lazy(() => treesConfigSchema).optional(),
    linkedTrees: import_zod.z.lazy(() => treesConfigSchema).optional(),
    claimableBy: import_zod.z.lazy(() => claimsHattersConfig).optional(),
    claimableForBy: import_zod.z.lazy(() => claimsHattersConfig).optional(),
    events: import_zod.z.lazy(() => hatsEventsConfigSchema).optional()
  }),
  filters: import_zod.z.object({
    first: import_zod.z.number().optional()
  }).optional()
}).strict();
var treePropsConfigSchema = import_zod.z.object({
  hats: import_zod.z.lazy(() => hatsConfigSchema).optional(),
  childOfTree: import_zod.z.lazy(() => treePropsConfigSchema).optional(),
  parentOfTrees: import_zod.z.lazy(() => treesConfigSchema).optional(),
  linkedToHat: import_zod.z.lazy(() => hatPropsConfigSchema).optional(),
  linkRequestFromTree: import_zod.z.lazy(() => treesConfigSchema).optional(),
  requestedLinkToTree: import_zod.z.lazy(() => treePropsConfigSchema).optional(),
  requestedLinkToHat: import_zod.z.lazy(() => hatPropsConfigSchema).optional(),
  events: import_zod.z.lazy(() => hatsEventsConfigSchema).optional()
}).strict();
var treesConfigSchema = import_zod.z.object({
  props: import_zod.z.object({
    hats: import_zod.z.lazy(() => hatsConfigSchema).optional(),
    childOfTree: import_zod.z.lazy(() => treePropsConfigSchema).optional(),
    parentOfTrees: import_zod.z.lazy(() => treesConfigSchema).optional(),
    linkedToHat: import_zod.z.lazy(() => hatPropsConfigSchema).optional(),
    linkRequestFromTree: import_zod.z.lazy(() => treesConfigSchema).optional(),
    requestedLinkToTree: import_zod.z.lazy(() => treePropsConfigSchema).optional(),
    requestedLinkToHat: import_zod.z.lazy(() => hatPropsConfigSchema).optional(),
    events: import_zod.z.lazy(() => hatsEventsConfigSchema).optional()
  }),
  filters: import_zod.z.object({
    first: import_zod.z.number().optional()
  }).optional()
}).strict();
var wearerPropsConfigSchema = import_zod.z.object({
  currentHats: import_zod.z.lazy(() => hatsConfigSchema).optional(),
  mintEvent: import_zod.z.lazy(() => hatsEventsConfigSchema).optional(),
  burnEvent: import_zod.z.lazy(() => hatsEventsConfigSchema).optional()
}).strict();
var wearersConfigSchema = import_zod.z.object({
  props: import_zod.z.object({
    currentHats: import_zod.z.lazy(() => hatsConfigSchema).optional(),
    mintEvent: import_zod.z.lazy(() => hatsEventsConfigSchema).optional(),
    burnEvent: import_zod.z.lazy(() => hatsEventsConfigSchema).optional()
  }),
  filters: import_zod.z.object({
    first: import_zod.z.number().optional()
  }).optional()
}).strict();
var claimsHatterPropsConfigSchema = import_zod.z.object({
  claimableHats: import_zod.z.lazy(() => hatsConfigSchema).optional(),
  claimableForHats: import_zod.z.lazy(() => hatsConfigSchema).optional()
}).strict();
var claimsHattersConfig = import_zod.z.object({
  props: import_zod.z.object({
    claimableHats: import_zod.z.lazy(() => hatsConfigSchema).optional(),
    claimableForHats: import_zod.z.lazy(() => hatsConfigSchema).optional()
  }),
  filters: import_zod.z.object({
    first: import_zod.z.number().optional()
  }).optional()
}).strict();
var hatsEventPropsConfigSchema = import_zod.z.object({
  timestamp: import_zod.z.boolean().optional(),
  blockNumber: import_zod.z.boolean().optional(),
  transactionID: import_zod.z.boolean().optional(),
  hat: import_zod.z.lazy(() => hatPropsConfigSchema).optional(),
  tree: import_zod.z.lazy(() => treePropsConfigSchema).optional()
}).strict();
var hatsEventsConfigSchema = import_zod.z.object({
  props: import_zod.z.object({
    timestamp: import_zod.z.boolean().optional(),
    blockNumber: import_zod.z.boolean().optional(),
    transactionID: import_zod.z.boolean().optional(),
    hat: import_zod.z.lazy(() => hatPropsConfigSchema).optional(),
    tree: import_zod.z.lazy(() => treePropsConfigSchema).optional()
  }),
  filters: import_zod.z.object({
    first: import_zod.z.number().optional()
  }).optional()
}).strict();

// src/client.ts
var HatsSubgraphClient = class {
  constructor({ config }) {
    if (config === void 0) {
      this._config = DEFAULT_ENDPOINTS_CONFIG;
    } else {
      this._config = config;
    }
  }
  async _makeGqlRequest(chainId, query, variables) {
    if (this._config[chainId] === void 0) {
      throw new SubgraphNotSupportedError(
        `No subgraph support for network id ${chainId}`
      );
    }
    const client = new import_graphql_request.GraphQLClient(this._config[chainId].endpoint);
    if (this._config[chainId].authToken !== void 0) {
      client.setHeader("Authorization", `Bearer ${this._config[chainId].authToken}`);
    }
    const result = await client.request(query, variables);
    return result;
  }
  /**
   * Get a Hat by its ID.
   * The Hat's properties to fetch are configurable, including nested objects.
   *
   * @param chainId Id of the chain to fetch from.
   * @param hatId ID of the Hat to fetch.
   * @param props Hat's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
   * @param filters Optional filters to include in the query.
   * @returns A Hat object.
   *
   * @throws InputValidationError
   * Thrown if the provided properties are invalid.
   *
   * @throws SubgraphHatNotExistError
   * Thrown if the Hat does not exist in the subgraph.
   */
  async getHat({
    chainId,
    hatId,
    props
  }) {
    const validationRes = hatPropsConfigSchema.safeParse(props);
    if (validationRes.success === false) {
      throw new InputValidationError(validationRes.error.message);
    }
    const hatIdHex = hatIdDecimalToHex(hatId);
    const normalizedProps = normalizeProps(props);
    const queryFields = normalizedPropsToQueryFields(normalizedProps);
    const query = import_graphql_request.gql`
      query getHat($id: ID!) {
        hat(id: $id) {
          ${queryFields}
        }
      }
    `;
    const response = await this._makeGqlRequest(chainId, query, {
      id: hatIdHex
    });
    if (!response.hat) {
      throw new SubgraphHatNotExistError(
        `Hat with an ID of ${hatId} does not exist in the subgraph for chain ID ${chainId}`
      );
    }
    return response.hat;
  }
  /**
   * Get Hats by their IDs.
   * The properties to fetch for each Hat are configurable, including nested objects.
   *
   * @param chainId Id of the chain to fetch from.
   * @param hatIds IDs of the Hats to fetch.
   * @param props Hat's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
   * @param filters Optional filters to include in the query.
   * @returns An array of Hat objects.
   *
   * @throws InputValidationError
   * Thrown if the provided properties are invalid.
   *
   * @throws SubgraphHatNotExistError
   * Thrown if one or more of the Hats do not exist in the subgraph.
   */
  async getHatsByIds({
    chainId,
    hatIds,
    props
  }) {
    const validationRes = hatPropsConfigSchema.safeParse(props);
    if (validationRes.success === false) {
      throw new InputValidationError(validationRes.error.message);
    }
    const hatIdsHex = hatIds.map((id) => hatIdDecimalToHex(id));
    const normalizedProps = normalizeProps(props);
    const queryFields = normalizedPropsToQueryFields(normalizedProps);
    const query = import_graphql_request.gql`
      query getHatsByIds($ids: [ID!]!) {
        hats(where: { id_in: $ids }) {
            ${queryFields}
        }
      }
    `;
    const response = await this._makeGqlRequest(
      chainId,
      query,
      {
        ids: hatIdsHex
      }
    );
    if (!response.hats || response.hats.length < hatIds.length) {
      throw new SubgraphHatNotExistError(
        `One or more of the provided hats do not exist in the subgraph for chain ID ${chainId}`
      );
    }
    return response.hats;
  }
  /**
   * Get a Tree by its ID.
   * The Tree's properties to fetch are configurable, including nested objects.
   *
   * @param chainId Id of the chain to fetch from.
   * @param treeId ID of the Tree to fetch (the tree's top-hat domain - first 4 bytes of the top-hat ID).
   * @param props Tree's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
   * @param filters Optional filters to include in the query.
   * @returns A Tree object.
   *
   * @throws InputValidationError
   * Thrown if the provided properties are invalid.
   *
   * @throws SubgraphTreeNotExistError
   * Thrown if the Tree does not exist in the subgraph.
   */
  async getTree({
    chainId,
    treeId,
    props
  }) {
    const validationRes = treePropsConfigSchema.safeParse(props);
    if (validationRes.success === false) {
      throw new InputValidationError(validationRes.error.message);
    }
    const treeIdHex = treeIdDecimalToHex(treeId);
    const normalizedProps = normalizeProps(props);
    const queryFields = normalizedPropsToQueryFields(normalizedProps);
    const query = import_graphql_request.gql`
      query getTree($id: ID!) {
        tree(id: $id) {
          ${queryFields}
        }
      }
    `;
    const response = await this._makeGqlRequest(chainId, query, {
      id: treeIdHex
    });
    if (!response.tree) {
      throw new SubgraphTreeNotExistError(
        `Tree with an ID of ${treeId} does not exist in the subgraph for chain ID ${chainId}`
      );
    }
    return response.tree;
  }
  /**
   * Get Trees by their IDs.
   * The properties to fetch for each Tree are configurable, including nested objects.
   *
   * @param chainId Id of the chain to fetch from.
   * @param treeIds ID of the Trees to fetch (the tree's top-hat domain - first 4 bytes of the top-hat ID).
   * @param props Tree's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
   * @param filters Optional filters to include in the query.
   * @returns An array of Tree objects.
   *
   * @throws InputValidationError
   * Thrown if the provided properties are invalid.
   *
   * @throws SubgraphTreeNotExistError
   * Thrown if one or more of the Trees do not exist in the subgraph.
   */
  async getTreesByIds({
    chainId,
    treeIds,
    props
  }) {
    const validationRes = treePropsConfigSchema.safeParse(props);
    if (validationRes.success === false) {
      throw new InputValidationError(validationRes.error.message);
    }
    const treeIdsHex = treeIds.map((treeId) => treeIdDecimalToHex(treeId));
    const normalizedProps = normalizeProps(props);
    const queryFields = normalizedPropsToQueryFields(normalizedProps);
    const query = import_graphql_request.gql`
    query getTreesById($ids: [ID!]!) {
      trees(where: { id_in: $ids }) {
        ${queryFields}
      }
    }
  `;
    const response = await this._makeGqlRequest(
      chainId,
      query,
      {
        ids: treeIdsHex
      }
    );
    if (!response.trees || response.trees.length < treeIds.length) {
      throw new SubgraphTreeNotExistError(
        `One or more of the provided trees do not exist in the subgraph for chain ID ${chainId}`
      );
    }
    return response.trees;
  }
  /**
   * Paginate over all existing Trees.
   * The properties to fetch for each Tree are configurable, including nested objects.
   *
   * @param chainId Id of the chain to fetch from.
   * @param props Tree's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
   * @param page Number of page to fetch.
   * @param perPage Number of Trees to fetch in each page.
   * @param filters - Optional filters to include in the query.
   * @returns An array of Tree objects.
   *
   * @throws InputValidationError
   * Thrown if the provided properties are invalid.
   */
  async getTreesPaginated({
    chainId,
    props,
    page,
    perPage
  }) {
    const validationRes = treePropsConfigSchema.safeParse(props);
    if (validationRes.success === false) {
      throw new InputValidationError(validationRes.error.message);
    }
    const normalizedProps = normalizeProps(props);
    const queryFields = normalizedPropsToQueryFields(normalizedProps);
    const query = import_graphql_request.gql`
    query getPaginatedTrees($skip: Int!, $first: Int!) {
      trees(skip: $skip, first: $first) {
        ${queryFields}
      }
    }
  `;
    const response = await this._makeGqlRequest(
      chainId,
      query,
      {
        skip: page * perPage,
        first: perPage
      }
    );
    if (!response.trees) {
      throw new Error("Unexpected error");
    }
    return response.trees;
  }
  /**
   * Get Wearer by its address.
   * The properties to fetch for each Wearer are configurable, including nested objects.
   *
   * @param chainId Id of the chain to fetch from.
   * @param wearerAddress Address of the wearer.
   * @param props Wearer's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
   * @param filters Optional filters to include in the query.
   * @returns A Wearer object.
   *
   * @throws InputValidationError
   * Thrown if the provided properties are invalid.
   *
   * @throws SubgraphWearerNotExistError
   * Thrown if the Wearer does not exist in the subgraph.
   */
  async getWearer({
    chainId,
    wearerAddress,
    props
  }) {
    const validationRes = wearerPropsConfigSchema.safeParse(props);
    if (validationRes.success === false) {
      throw new InputValidationError(validationRes.error.message);
    }
    const wearerAddressLowerCase = wearerAddress.toLowerCase();
    const normalizedProps = normalizeProps(props);
    const queryFields = normalizedPropsToQueryFields(normalizedProps);
    const query = import_graphql_request.gql`
      query getCurrentHatsForWearer($id: ID!) {
        wearer(id: $id) {
            ${queryFields}
        }
      }
    `;
    const response = await this._makeGqlRequest(
      chainId,
      query,
      {
        id: wearerAddressLowerCase
      }
    );
    if (!response.wearer) {
      throw new SubgraphWearerNotExistError(
        `Wearer with an address of ${wearerAddress} does not exist in the subgraph for chain ID ${chainId}`
      );
    }
    return response.wearer;
  }
  /**
   * Paginate over the Wearers of a Hat.
   * The properties to fetch for each Wearer are configurable, including nested objects.
   *
   * @param chainId Id of the chain to fetch from.
   * @param hatId ID of the Hat for which Wearers to fetch.
   * @param props Wearer's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
   * @param page Number of page to fetch.
   * @param perPage Number of Wearers to fetch in each page.
   * @param filters Optional filters to include in the query.
   * @returns A Wearer object.
   *
   * @throws InputValidationError
   * Thrown if the provided properties are invalid.
   *
   * @throws SubgraphHatNotExistError
   * Thrown if the Hat does not exist in the subgraph.
   */
  async getWearersOfHatPaginated({
    chainId,
    hatId,
    props,
    page,
    perPage
  }) {
    const validationRes = wearerPropsConfigSchema.safeParse(props);
    if (validationRes.success === false) {
      throw new InputValidationError(validationRes.error.message);
    }
    const hatIdHex = hatIdDecimalToHex(hatId);
    const normalizedProps = normalizeProps(props);
    const queryFields = normalizedPropsToQueryFields(normalizedProps);
    const query = import_graphql_request.gql`
      query getPaginatedWearersForHat($hatId: ID!, $first: Int!, $skip: Int!) {
        hat(id: $hatId) {
            wearers(skip: $skip, first: $first) {
                ${queryFields}
            }
        }
      }
    `;
    const response = await this._makeGqlRequest(
      chainId,
      query,
      {
        hatId: hatIdHex,
        skip: page * perPage,
        first: perPage
      }
    );
    if (!response.hat) {
      throw new SubgraphHatNotExistError(
        `Hat with an ID of ${hatId} does not exist in the subgraph for chain ID ${chainId}`
      );
    }
    return response.hat.wearers;
  }
  /**
   * Search Hat, Tree or Wearer by ID.
   * The properties to fetch for each object are configurable, including nested objects.
   *
   * @param chainId Id of the chain to fetch from.
   * @param search ID to search for (Hat ID or pretty ID, Tree ID or Wearer address).
   * @param treeProps Tree's properties to fetch (if Tree was found), including the properties of nested objects. Pass an empty object to include only the object's ID.
   * @param hatProps Hat's properties to fetch (if Hat was found), including the properties of nested objects. Pass an empty object to include only the object's ID.
   * @param wearerProps Wearer's properties to fetch (if Wearer was found), including the properties of nested objects. Pass an empty object to include only the object's ID.
   * @param filters Optional filters to include in the query.
   * @returns An object containing the search result.
   *
   * @throws InputValidationError
   * Thrown if the provided properties are invalid.
   */
  async searchTreesHatsWearers({
    chainId,
    search,
    treeProps,
    hatProps,
    wearerProps
  }) {
    const treeValidationRes = treePropsConfigSchema.safeParse(treeProps);
    if (treeValidationRes.success === false) {
      throw new InputValidationError(treeValidationRes.error.message);
    }
    const hatValidationRes = hatPropsConfigSchema.safeParse(hatProps);
    if (hatValidationRes.success === false) {
      throw new InputValidationError(hatValidationRes.error.message);
    }
    const wearerValidationRes = wearerPropsConfigSchema.safeParse(wearerProps);
    if (wearerValidationRes.success === false) {
      throw new InputValidationError(wearerValidationRes.error.message);
    }
    const treeNormalizedProps = normalizeProps(treeProps);
    const treeQueryFields = normalizedPropsToQueryFields(treeNormalizedProps);
    const hatNormalizedProps = normalizeProps(hatProps);
    const hatQueryFields = normalizedPropsToQueryFields(hatNormalizedProps);
    const wearerNormalizedProps = normalizeProps(wearerProps);
    const wearerQueryFields = normalizedPropsToQueryFields(
      wearerNormalizedProps
    );
    const query = import_graphql_request.gql`
      query search($search: String!) {
        trees(where: { id: $search }) {
          ${treeQueryFields}
        }
        hats(where: { or: [{ id: $search }, { prettyId: $search }] }) {
          ${hatQueryFields}
        }
        wearers(where: { id: $search }) {
          ${wearerQueryFields}
        }
      }
    `;
    const response = await this._makeGqlRequest(chainId, query, {
      search: search.toLowerCase()
    });
    if (!response.wearers || !response.trees || !response.hats) {
      throw new Error("Unexpected error");
    }
    return response;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DEFAULT_ENDPOINTS_CONFIG,
  HatsSubgraphClient
});
//# sourceMappingURL=index.js.map
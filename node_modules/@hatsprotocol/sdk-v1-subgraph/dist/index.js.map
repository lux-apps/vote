{"version":3,"sources":["../src/index.ts","../src/utils.ts","../src/client.ts","../src/endpoints.ts","../src/errors.ts","../src/schemas.ts"],"sourcesContent":["import { HatsSubgraphClient } from \"./client\";\nimport { DEFAULT_ENDPOINTS_CONFIG } from \"./endpoints\";\nimport type {\n  Hat,\n  Tree,\n  Wearer,\n  HatsEvent,\n  ClaimsHatter,\n  HatPropsConfig,\n  TreePropsConfig,\n  WearerPropsConfig,\n  HatsEventPropsConfig,\n  ClaimsHatterPropsConfig,\n  EndpointsConfig,\n} from \"./types\";\n\nexport { HatsSubgraphClient, DEFAULT_ENDPOINTS_CONFIG };\nexport type {\n  Hat,\n  Tree,\n  Wearer,\n  HatsEvent,\n  ClaimsHatter,\n  HatPropsConfig,\n  TreePropsConfig,\n  WearerPropsConfig,\n  HatsEventPropsConfig,\n  ClaimsHatterPropsConfig,\n  EndpointsConfig,\n};\n","import type {\n  HatPropsConfig,\n  TreePropsConfig,\n  WearerPropsConfig,\n  ClaimsHatterPropsConfig,\n  HatsEventPropsConfig,\n} from \"./types\";\n\nexport function hatIdDecimalToHex(hatId: bigint): string {\n  return \"0x\" + BigInt(hatId).toString(16).padStart(64, \"0\");\n}\n\nexport function treeIdDecimalToHex(treeId: number): string {\n  return \"0x\" + treeId.toString(16).padStart(8, \"0\");\n}\n\nexport function hatIdHexToDecimal(hatId: string): bigint {\n  return BigInt(hatId);\n}\n\nexport function treeIdHexToDecimal(treeId: string): number {\n  return parseInt(treeId, 16);\n}\n\nexport function hatIdDecimalToIp(hatId: bigint): string {\n  const hexId = hatIdDecimalToHex(hatId);\n  let ip = treeIdHexToDecimal(hexId.substring(0, 10)).toString();\n  for (let i = 10; i < hexId.length; i += 4) {\n    const domainAtLevel = hexId.substring(i, i + 4);\n    if (domainAtLevel === \"0000\") {\n      break;\n    }\n    ip += \".\" + parseInt(domainAtLevel, 16);\n  }\n  return ip;\n}\n\nexport function treeIdToTopHatId(treeId: number): bigint {\n  return BigInt(treeIdDecimalToHex(treeId).padEnd(66, \"0\"));\n}\n\nexport function hatIdToTreeId(hatId: bigint): number {\n  return parseInt(\n    \"0x\" + BigInt(hatId).toString(16).padStart(64, \"0\").substring(0, 8),\n    16\n  );\n}\n\nexport function normalizeProps(\n  config:\n    | HatPropsConfig\n    | TreePropsConfig\n    | WearerPropsConfig\n    | ClaimsHatterPropsConfig\n    | HatsEventPropsConfig\n): any {\n  const fields: any[] = [\"id\"];\n  for (const [key, value] of Object.entries(config)) {\n    if (typeof value !== \"object\" && value === true) {\n      fields.push(key);\n    }\n\n    if (typeof value === \"object\") {\n      const withPropsAndFilters = \"props\" in value ? true : false;\n      const subFields = normalizeProps(\n        withPropsAndFilters ? value.props : value\n      );\n      const obj: any = {\n        objName: key,\n        objProps: subFields,\n      };\n\n      if (\n        withPropsAndFilters &&\n        value.filters !== undefined &&\n        value.filters.first !== undefined\n      ) {\n        obj[\"objFilters\"] = { first: value.filters.first };\n      }\n      fields.push(obj);\n    }\n  }\n\n  return fields;\n}\n\nexport function normalizedPropsToQueryFields(props: any): any {\n  let fields = \"\";\n\n  for (let i = 0; i < props.length; i++) {\n    if (i > 0) {\n      fields += \", \";\n    }\n\n    const elem = props[i];\n    if (typeof elem === \"string\") {\n      fields = fields + `${elem}`;\n    }\n\n    if (typeof elem === \"object\") {\n      const name = elem[\"objName\"];\n      const props = elem[\"objProps\"];\n      const first =\n        elem[\"objFilters\"] !== undefined\n          ? elem[\"objFilters\"][\"first\"]\n          : undefined;\n\n      if (first !== undefined) {\n        if (name === \"events\") {\n          fields =\n            fields +\n            `${name} (orderBy: timestamp, orderDirection: desc, first: ${first}) { ${normalizedPropsToQueryFields(\n              props\n            )} \n            __typename \n            ... on HatCreatedEvent { hatDetails hatMaxSupply hatEligibility hatToggle hatMutable hatImageUri } \n            ... on HatMintedEvent { wearer { id } operator } \n            ... on HatBurnedEvent { wearer { id } operator } \n            ... on HatStatusChangedEvent { hatNewStatus } \n            ... on HatDetailsChangedEvent { hatNewDetails } \n            ... on HatEligibilityChangedEvent { hatNewEligibility } \n            ... on HatToggleChangedEvent { hatNewToggle } \n            ... on HatMaxSupplyChangedEvent { hatNewMaxSupply } \n            ... on HatImageURIChangedEvent { hatNewImageURI } \n            ... on TopHatLinkRequestedEvent { newAdmin } \n            ... on TopHatLinkedEvent { newAdmin } \n            ... on WearerStandingChangedEvent { wearer { id } wearerStanding } \n          }`;\n        } else {\n          fields =\n            fields +\n            `${name} (first: ${first}) { ${normalizedPropsToQueryFields(\n              props\n            )} }`;\n        }\n      } else {\n        if (name === \"events\") {\n          fields =\n            fields +\n            `${name} (orderBy: timestamp, orderDirection: desc) { \n              ${normalizedPropsToQueryFields(props)} \n              __typename \n              ... on HatCreatedEvent { hatDetails hatMaxSupply hatEligibility hatToggle hatMutable hatImageUri } \n              ... on HatMintedEvent { wearer { id } operator } \n              ... on HatBurnedEvent { wearer { id } operator } \n              ... on HatStatusChangedEvent { hatNewStatus } \n              ... on HatDetailsChangedEvent { hatNewDetails } \n              ... on HatEligibilityChangedEvent { hatNewEligibility } \n              ... on HatToggleChangedEvent { hatNewToggle } \n              ... on HatMaxSupplyChangedEvent { hatNewMaxSupply } \n              ... on HatImageURIChangedEvent { hatNewImageURI } \n              ... on TopHatLinkRequestedEvent { newAdmin } \n              ... on TopHatLinkedEvent { newAdmin } \n              ... on WearerStandingChangedEvent { wearer { id } wearerStanding } \n            }`;\n        } else {\n          fields =\n            fields + `${name} { ${normalizedPropsToQueryFields(props)} }`;\n        }\n      }\n    }\n  }\n\n  return fields;\n}\n","import {\n  treeIdDecimalToHex,\n  hatIdDecimalToHex,\n  normalizeProps,\n  normalizedPropsToQueryFields,\n} from \"./utils\";\nimport { gql, Variables, GraphQLClient } from \"graphql-request\";\nimport { DEFAULT_ENDPOINTS_CONFIG } from \"./endpoints\";\nimport {\n  SubgraphNotSupportedError,\n  SubgraphHatNotExistError,\n  SubgraphTreeNotExistError,\n  SubgraphWearerNotExistError,\n  InputValidationError,\n} from \"./errors\";\nimport {\n  hatPropsConfigSchema,\n  treePropsConfigSchema,\n  wearerPropsConfigSchema,\n} from \"./schemas\";\nimport type {\n  Hat,\n  Tree,\n  HatPropsConfig,\n  TreePropsConfig,\n  WearerPropsConfig,\n  Wearer,\n  EndpointsConfig,\n} from \"./types\";\n\nexport class HatsSubgraphClient {\n  protected readonly _config: EndpointsConfig;\n\n  constructor({ config }: { config?: EndpointsConfig }) {\n    if (config === undefined) {\n      this._config = DEFAULT_ENDPOINTS_CONFIG;\n    } else {\n      this._config = config;\n    }\n  }\n\n  protected async _makeGqlRequest<ResponseType>(\n    chainId: number,\n    query: string,\n    variables?: Variables\n  ): Promise<ResponseType> {\n    if (this._config[chainId] === undefined) {\n      throw new SubgraphNotSupportedError(\n        `No subgraph support for network id ${chainId}`\n      );\n    }\n\n    const client = new GraphQLClient(this._config[chainId].endpoint);\n\n    if (this._config[chainId].authToken !== undefined) {\n      client.setHeader(\"Authorization\", `Bearer ${this._config[chainId].authToken}`);\n    }\n\n    const result = (await client.request(query, variables)) as ResponseType;\n\n    return result;\n  }\n\n  /**\n   * Get a Hat by its ID.\n   * The Hat's properties to fetch are configurable, including nested objects.\n   *\n   * @param chainId Id of the chain to fetch from.\n   * @param hatId ID of the Hat to fetch.\n   * @param props Hat's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.\n   * @param filters Optional filters to include in the query.\n   * @returns A Hat object.\n   *\n   * @throws InputValidationError\n   * Thrown if the provided properties are invalid.\n   *\n   * @throws SubgraphHatNotExistError\n   * Thrown if the Hat does not exist in the subgraph.\n   */\n  async getHat({\n    chainId,\n    hatId,\n    props,\n  }: {\n    chainId: number;\n    hatId: bigint;\n    props: HatPropsConfig;\n  }): Promise<Hat> {\n    const validationRes = hatPropsConfigSchema.safeParse(props);\n    if (validationRes.success === false) {\n      throw new InputValidationError(validationRes.error.message);\n    }\n\n    const hatIdHex = hatIdDecimalToHex(hatId);\n\n    const normalizedProps = normalizeProps(props);\n    const queryFields = normalizedPropsToQueryFields(normalizedProps);\n\n    const query = gql`\n      query getHat($id: ID!) {\n        hat(id: $id) {\n          ${queryFields}\n        }\n      }\n    `;\n\n    const response = await this._makeGqlRequest<{ hat: Hat }>(chainId, query, {\n      id: hatIdHex,\n    });\n\n    if (!response.hat) {\n      throw new SubgraphHatNotExistError(\n        `Hat with an ID of ${hatId} does not exist in the subgraph for chain ID ${chainId}`\n      );\n    }\n\n    return response.hat;\n  }\n\n  /**\n   * Get Hats by their IDs.\n   * The properties to fetch for each Hat are configurable, including nested objects.\n   *\n   * @param chainId Id of the chain to fetch from.\n   * @param hatIds IDs of the Hats to fetch.\n   * @param props Hat's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.\n   * @param filters Optional filters to include in the query.\n   * @returns An array of Hat objects.\n   *\n   * @throws InputValidationError\n   * Thrown if the provided properties are invalid.\n   *\n   * @throws SubgraphHatNotExistError\n   * Thrown if one or more of the Hats do not exist in the subgraph.\n   */\n  async getHatsByIds({\n    chainId,\n    hatIds,\n    props,\n  }: {\n    chainId: number;\n    hatIds: bigint[];\n    props: HatPropsConfig;\n  }): Promise<Hat[]> {\n    const validationRes = hatPropsConfigSchema.safeParse(props);\n    if (validationRes.success === false) {\n      throw new InputValidationError(validationRes.error.message);\n    }\n\n    const hatIdsHex: string[] = hatIds.map((id) => hatIdDecimalToHex(id));\n\n    const normalizedProps = normalizeProps(props);\n    const queryFields = normalizedPropsToQueryFields(normalizedProps);\n\n    const query = gql`\n      query getHatsByIds($ids: [ID!]!) {\n        hats(where: { id_in: $ids }) {\n            ${queryFields}\n        }\n      }\n    `;\n\n    const response = await this._makeGqlRequest<{ hats: Hat[] }>(\n      chainId,\n      query,\n      {\n        ids: hatIdsHex,\n      }\n    );\n\n    if (!response.hats || response.hats.length < hatIds.length) {\n      throw new SubgraphHatNotExistError(\n        `One or more of the provided hats do not exist in the subgraph for chain ID ${chainId}`\n      );\n    }\n\n    return response.hats;\n  }\n\n  /**\n   * Get a Tree by its ID.\n   * The Tree's properties to fetch are configurable, including nested objects.\n   *\n   * @param chainId Id of the chain to fetch from.\n   * @param treeId ID of the Tree to fetch (the tree's top-hat domain - first 4 bytes of the top-hat ID).\n   * @param props Tree's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.\n   * @param filters Optional filters to include in the query.\n   * @returns A Tree object.\n   *\n   * @throws InputValidationError\n   * Thrown if the provided properties are invalid.\n   *\n   * @throws SubgraphTreeNotExistError\n   * Thrown if the Tree does not exist in the subgraph.\n   */\n  async getTree({\n    chainId,\n    treeId,\n    props,\n  }: {\n    chainId: number;\n    treeId: number;\n    props: TreePropsConfig;\n  }): Promise<Tree> {\n    const validationRes = treePropsConfigSchema.safeParse(props);\n    if (validationRes.success === false) {\n      throw new InputValidationError(validationRes.error.message);\n    }\n\n    const treeIdHex = treeIdDecimalToHex(treeId);\n\n    const normalizedProps = normalizeProps(props);\n    const queryFields = normalizedPropsToQueryFields(normalizedProps);\n\n    const query = gql`\n      query getTree($id: ID!) {\n        tree(id: $id) {\n          ${queryFields}\n        }\n      }\n    `;\n\n    const response = await this._makeGqlRequest<{ tree: Tree }>(chainId, query, {\n      id: treeIdHex,\n    });\n\n    if (!response.tree) {\n      throw new SubgraphTreeNotExistError(\n        `Tree with an ID of ${treeId} does not exist in the subgraph for chain ID ${chainId}`\n      );\n    }\n\n    return response.tree;\n  }\n\n  /**\n   * Get Trees by their IDs.\n   * The properties to fetch for each Tree are configurable, including nested objects.\n   *\n   * @param chainId Id of the chain to fetch from.\n   * @param treeIds ID of the Trees to fetch (the tree's top-hat domain - first 4 bytes of the top-hat ID).\n   * @param props Tree's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.\n   * @param filters Optional filters to include in the query.\n   * @returns An array of Tree objects.\n   *\n   * @throws InputValidationError\n   * Thrown if the provided properties are invalid.\n   *\n   * @throws SubgraphTreeNotExistError\n   * Thrown if one or more of the Trees do not exist in the subgraph.\n   */\n  async getTreesByIds({\n    chainId,\n    treeIds,\n    props,\n  }: {\n    chainId: number;\n    treeIds: number[];\n    props: TreePropsConfig;\n  }): Promise<Tree[]> {\n    const validationRes = treePropsConfigSchema.safeParse(props);\n    if (validationRes.success === false) {\n      throw new InputValidationError(validationRes.error.message);\n    }\n\n    const treeIdsHex = treeIds.map((treeId) => treeIdDecimalToHex(treeId));\n\n    const normalizedProps = normalizeProps(props);\n    const queryFields = normalizedPropsToQueryFields(normalizedProps);\n\n    const query = gql`\n    query getTreesById($ids: [ID!]!) {\n      trees(where: { id_in: $ids }) {\n        ${queryFields}\n      }\n    }\n  `;\n\n    const response = await this._makeGqlRequest<{ trees: Tree[] }>(\n      chainId,\n      query,\n      {\n        ids: treeIdsHex,\n      }\n    );\n\n    if (!response.trees || response.trees.length < treeIds.length) {\n      throw new SubgraphTreeNotExistError(\n        `One or more of the provided trees do not exist in the subgraph for chain ID ${chainId}`\n      );\n    }\n\n    return response.trees;\n  }\n\n  /**\n   * Paginate over all existing Trees.\n   * The properties to fetch for each Tree are configurable, including nested objects.\n   *\n   * @param chainId Id of the chain to fetch from.\n   * @param props Tree's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.\n   * @param page Number of page to fetch.\n   * @param perPage Number of Trees to fetch in each page.\n   * @param filters - Optional filters to include in the query.\n   * @returns An array of Tree objects.\n   *\n   * @throws InputValidationError\n   * Thrown if the provided properties are invalid.\n   */\n  async getTreesPaginated({\n    chainId,\n    props,\n    page,\n    perPage,\n  }: {\n    chainId: number;\n    props: TreePropsConfig;\n    page: number;\n    perPage: number;\n  }): Promise<Tree[]> {\n    const validationRes = treePropsConfigSchema.safeParse(props);\n    if (validationRes.success === false) {\n      throw new InputValidationError(validationRes.error.message);\n    }\n\n    const normalizedProps = normalizeProps(props);\n    const queryFields = normalizedPropsToQueryFields(normalizedProps);\n\n    const query = gql`\n    query getPaginatedTrees($skip: Int!, $first: Int!) {\n      trees(skip: $skip, first: $first) {\n        ${queryFields}\n      }\n    }\n  `;\n\n    const response = await this._makeGqlRequest<{ trees: Tree[] }>(\n      chainId,\n      query,\n      {\n        skip: page * perPage,\n        first: perPage,\n      }\n    );\n\n    if (!response.trees) {\n      throw new Error(\"Unexpected error\");\n    }\n\n    return response.trees;\n  }\n\n  /**\n   * Get Wearer by its address.\n   * The properties to fetch for each Wearer are configurable, including nested objects.\n   *\n   * @param chainId Id of the chain to fetch from.\n   * @param wearerAddress Address of the wearer.\n   * @param props Wearer's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.\n   * @param filters Optional filters to include in the query.\n   * @returns A Wearer object.\n   *\n   * @throws InputValidationError\n   * Thrown if the provided properties are invalid.\n   *\n   * @throws SubgraphWearerNotExistError\n   * Thrown if the Wearer does not exist in the subgraph.\n   */\n  async getWearer({\n    chainId,\n    wearerAddress,\n    props,\n  }: {\n    chainId: number;\n    wearerAddress: `0x${string}`;\n    props: WearerPropsConfig;\n  }): Promise<Wearer> {\n    const validationRes = wearerPropsConfigSchema.safeParse(props);\n    if (validationRes.success === false) {\n      throw new InputValidationError(validationRes.error.message);\n    }\n\n    const wearerAddressLowerCase = wearerAddress.toLowerCase();\n\n    const normalizedProps = normalizeProps(props);\n    const queryFields = normalizedPropsToQueryFields(normalizedProps);\n\n    const query = gql`\n      query getCurrentHatsForWearer($id: ID!) {\n        wearer(id: $id) {\n            ${queryFields}\n        }\n      }\n    `;\n\n    const response = await this._makeGqlRequest<{ wearer: Wearer }>(\n      chainId,\n      query,\n      {\n        id: wearerAddressLowerCase,\n      }\n    );\n\n    if (!response.wearer) {\n      throw new SubgraphWearerNotExistError(\n        `Wearer with an address of ${wearerAddress} does not exist in the subgraph for chain ID ${chainId}`\n      );\n    }\n\n    return response.wearer;\n  }\n\n  /**\n   * Paginate over the Wearers of a Hat.\n   * The properties to fetch for each Wearer are configurable, including nested objects.\n   *\n   * @param chainId Id of the chain to fetch from.\n   * @param hatId ID of the Hat for which Wearers to fetch.\n   * @param props Wearer's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.\n   * @param page Number of page to fetch.\n   * @param perPage Number of Wearers to fetch in each page.\n   * @param filters Optional filters to include in the query.\n   * @returns A Wearer object.\n   *\n   * @throws InputValidationError\n   * Thrown if the provided properties are invalid.\n   *\n   * @throws SubgraphHatNotExistError\n   * Thrown if the Hat does not exist in the subgraph.\n   */\n  async getWearersOfHatPaginated({\n    chainId,\n    hatId,\n    props,\n    page,\n    perPage,\n  }: {\n    chainId: number;\n    hatId: bigint;\n    props: WearerPropsConfig;\n    page: number;\n    perPage: number;\n  }): Promise<Wearer[]> {\n    const validationRes = wearerPropsConfigSchema.safeParse(props);\n    if (validationRes.success === false) {\n      throw new InputValidationError(validationRes.error.message);\n    }\n\n    const hatIdHex = hatIdDecimalToHex(hatId);\n\n    const normalizedProps = normalizeProps(props);\n    const queryFields = normalizedPropsToQueryFields(normalizedProps);\n\n    const query = gql`\n      query getPaginatedWearersForHat($hatId: ID!, $first: Int!, $skip: Int!) {\n        hat(id: $hatId) {\n            wearers(skip: $skip, first: $first) {\n                ${queryFields}\n            }\n        }\n      }\n    `;\n\n    const response = await this._makeGqlRequest<{ hat: { wearers: Wearer[] } }>(\n      chainId,\n      query,\n      {\n        hatId: hatIdHex,\n        skip: page * perPage,\n        first: perPage,\n      }\n    );\n\n    if (!response.hat) {\n      throw new SubgraphHatNotExistError(\n        `Hat with an ID of ${hatId} does not exist in the subgraph for chain ID ${chainId}`\n      );\n    }\n\n    return response.hat.wearers;\n  }\n\n  /**\n   * Search Hat, Tree or Wearer by ID.\n   * The properties to fetch for each object are configurable, including nested objects.\n   *\n   * @param chainId Id of the chain to fetch from.\n   * @param search ID to search for (Hat ID or pretty ID, Tree ID or Wearer address).\n   * @param treeProps Tree's properties to fetch (if Tree was found), including the properties of nested objects. Pass an empty object to include only the object's ID.\n   * @param hatProps Hat's properties to fetch (if Hat was found), including the properties of nested objects. Pass an empty object to include only the object's ID.\n   * @param wearerProps Wearer's properties to fetch (if Wearer was found), including the properties of nested objects. Pass an empty object to include only the object's ID.\n   * @param filters Optional filters to include in the query.\n   * @returns An object containing the search result.\n   *\n   * @throws InputValidationError\n   * Thrown if the provided properties are invalid.\n   */\n  async searchTreesHatsWearers({\n    chainId,\n    search,\n    treeProps,\n    hatProps,\n    wearerProps,\n  }: {\n    chainId: number;\n    search: string;\n    treeProps: TreePropsConfig;\n    hatProps: HatPropsConfig;\n    wearerProps: WearerPropsConfig;\n  }): Promise<{ trees: Tree[]; hats: Hat[]; wearers: Wearer[] }> {\n    const treeValidationRes = treePropsConfigSchema.safeParse(treeProps);\n    if (treeValidationRes.success === false) {\n      throw new InputValidationError(treeValidationRes.error.message);\n    }\n\n    const hatValidationRes = hatPropsConfigSchema.safeParse(hatProps);\n    if (hatValidationRes.success === false) {\n      throw new InputValidationError(hatValidationRes.error.message);\n    }\n\n    const wearerValidationRes = wearerPropsConfigSchema.safeParse(wearerProps);\n    if (wearerValidationRes.success === false) {\n      throw new InputValidationError(wearerValidationRes.error.message);\n    }\n\n    const treeNormalizedProps = normalizeProps(treeProps);\n    const treeQueryFields = normalizedPropsToQueryFields(treeNormalizedProps);\n\n    const hatNormalizedProps = normalizeProps(hatProps);\n    const hatQueryFields = normalizedPropsToQueryFields(hatNormalizedProps);\n\n    const wearerNormalizedProps = normalizeProps(wearerProps);\n    const wearerQueryFields = normalizedPropsToQueryFields(\n      wearerNormalizedProps\n    );\n\n    const query = gql`\n      query search($search: String!) {\n        trees(where: { id: $search }) {\n          ${treeQueryFields}\n        }\n        hats(where: { or: [{ id: $search }, { prettyId: $search }] }) {\n          ${hatQueryFields}\n        }\n        wearers(where: { id: $search }) {\n          ${wearerQueryFields}\n        }\n      }\n    `;\n\n    const response = await this._makeGqlRequest<{\n      trees: Tree[];\n      hats: Hat[];\n      wearers: Wearer[];\n    }>(chainId, query, {\n      search: search.toLowerCase(),\n    });\n\n    if (!response.wearers || !response.trees || !response.hats) {\n      throw new Error(\"Unexpected error\");\n    }\n\n    return response;\n  }\n}\n","import type { EndpointsConfig } from \"./types\";\n\nexport const DEFAULT_ENDPOINTS_CONFIG: EndpointsConfig = {\n  1: {\n    endpoint:\n      \"https://api.studio.thegraph.com/query/55784/hats-v1-ethereum/version/latest\",\n  },\n  10: {\n    endpoint:\n      \"https://api.studio.thegraph.com/query/55784/hats-v1-optimism/version/latest\",\n  },\n  100: {\n    endpoint:\n      \"https://api.studio.thegraph.com/query/55784/hats-v1-gnosis-chain/version/latest\",\n  },\n  137: {\n    endpoint:\n      \"https://api.studio.thegraph.com/query/55784/hats-v1-polygon/version/latest\",\n  },\n  42161: {\n    endpoint:\n      \"https://api.studio.thegraph.com/query/55784/hats-v1-arbitrum/version/latest\",\n  },\n  11155111: {\n    endpoint:\n      \"https://api.studio.thegraph.com/query/55784/hats-v1-sepolia/version/latest\",\n  },\n  8453: {\n    endpoint:\n      \"https://api.studio.thegraph.com/query/55784/hats-v1-base/version/latest\",\n  },\n  42220: {\n    endpoint:\n      \"https://api.studio.thegraph.com/query/55784/hats-v1-celo/version/latest\",\n  },\n  84532: {\n    endpoint:\n      \"https://api.studio.thegraph.com/query/55784/hats-v1-base-sepolia/version/latest\",\n  },\n};\n","export class SubgraphNotSupportedError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"SubgraphNotSupportedError\";\n  }\n}\n\nexport class SubgraphHatNotExistError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"SubgraphHatNotExistError\";\n  }\n}\n\nexport class SubgraphTreeNotExistError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"SubgraphTreeNotExistError\";\n  }\n}\nexport class SubgraphWearerNotExistError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"SubgraphWearerNotExistError\";\n  }\n}\n\nexport class InputValidationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"InputValidationError\";\n  }\n}\n","import { z } from \"zod\";\nimport type {\n  HatPropsConfig,\n  HatsConfig,\n  TreePropsConfig,\n  TreesConfig,\n  WearerPropsConfig,\n  WearersConfig,\n  ClaimsHatterPropsConfig,\n  ClaimsHattersConfig,\n  HatsEventPropsConfig,\n  HatsEventsConfig,\n} from \"./types\";\n\nexport const hatPropsConfigSchema: z.ZodType<HatPropsConfig> = z\n  .object({\n    prettyId: z.boolean().optional(),\n    status: z.boolean().optional(),\n    createdAt: z.boolean().optional(),\n    details: z.boolean().optional(),\n    maxSupply: z.boolean().optional(),\n    eligibility: z.boolean().optional(),\n    toggle: z.boolean().optional(),\n    mutable: z.boolean().optional(),\n    imageUri: z.boolean().optional(),\n    levelAtLocalTree: z.boolean().optional(),\n    currentSupply: z.boolean().optional(),\n    tree: z.lazy(() => treePropsConfigSchema).optional(),\n    wearers: z.lazy(() => wearersConfigSchema).optional(),\n    badStandings: z.lazy(() => wearersConfigSchema).optional(),\n    admin: z.lazy(() => hatPropsConfigSchema).optional(),\n    subHats: z.lazy(() => hatsConfigSchema).optional(),\n    linkRequestFromTree: z.lazy(() => treesConfigSchema).optional(),\n    linkedTrees: z.lazy(() => treesConfigSchema).optional(),\n    claimableBy: z.lazy(() => claimsHattersConfig).optional(),\n    claimableForBy: z.lazy(() => claimsHattersConfig).optional(),\n    events: z.lazy(() => hatsEventsConfigSchema).optional(),\n  })\n  .strict();\n\nexport const hatsConfigSchema: z.ZodType<HatsConfig> = z\n  .object({\n    props: z.object({\n      prettyId: z.boolean().optional(),\n      status: z.boolean().optional(),\n      createdAt: z.boolean().optional(),\n      details: z.boolean().optional(),\n      maxSupply: z.boolean().optional(),\n      eligibility: z.boolean().optional(),\n      toggle: z.boolean().optional(),\n      mutable: z.boolean().optional(),\n      imageUri: z.boolean().optional(),\n      levelAtLocalTree: z.boolean().optional(),\n      currentSupply: z.boolean().optional(),\n      tree: z.lazy(() => treePropsConfigSchema).optional(),\n      wearers: z.lazy(() => wearersConfigSchema).optional(),\n      badStandings: z.lazy(() => wearersConfigSchema).optional(),\n      admin: z.lazy(() => hatPropsConfigSchema).optional(),\n      subHats: z.lazy(() => hatsConfigSchema).optional(),\n      linkRequestFromTree: z.lazy(() => treesConfigSchema).optional(),\n      linkedTrees: z.lazy(() => treesConfigSchema).optional(),\n      claimableBy: z.lazy(() => claimsHattersConfig).optional(),\n      claimableForBy: z.lazy(() => claimsHattersConfig).optional(),\n      events: z.lazy(() => hatsEventsConfigSchema).optional(),\n    }),\n    filters: z\n      .object({\n        first: z.number().optional(),\n      })\n      .optional(),\n  })\n  .strict();\n\nexport const treePropsConfigSchema: z.ZodType<TreePropsConfig> = z\n  .object({\n    hats: z.lazy(() => hatsConfigSchema).optional(),\n    childOfTree: z.lazy(() => treePropsConfigSchema).optional(),\n    parentOfTrees: z.lazy(() => treesConfigSchema).optional(),\n    linkedToHat: z.lazy(() => hatPropsConfigSchema).optional(),\n    linkRequestFromTree: z.lazy(() => treesConfigSchema).optional(),\n    requestedLinkToTree: z.lazy(() => treePropsConfigSchema).optional(),\n    requestedLinkToHat: z.lazy(() => hatPropsConfigSchema).optional(),\n    events: z.lazy(() => hatsEventsConfigSchema).optional(),\n  })\n  .strict();\n\nexport const treesConfigSchema: z.ZodType<TreesConfig> = z\n  .object({\n    props: z.object({\n      hats: z.lazy(() => hatsConfigSchema).optional(),\n      childOfTree: z.lazy(() => treePropsConfigSchema).optional(),\n      parentOfTrees: z.lazy(() => treesConfigSchema).optional(),\n      linkedToHat: z.lazy(() => hatPropsConfigSchema).optional(),\n      linkRequestFromTree: z.lazy(() => treesConfigSchema).optional(),\n      requestedLinkToTree: z.lazy(() => treePropsConfigSchema).optional(),\n      requestedLinkToHat: z.lazy(() => hatPropsConfigSchema).optional(),\n      events: z.lazy(() => hatsEventsConfigSchema).optional(),\n    }),\n    filters: z\n      .object({\n        first: z.number().optional(),\n      })\n      .optional(),\n  })\n  .strict();\n\nexport const wearerPropsConfigSchema: z.ZodType<WearerPropsConfig> = z\n  .object({\n    currentHats: z.lazy(() => hatsConfigSchema).optional(),\n    mintEvent: z.lazy(() => hatsEventsConfigSchema).optional(),\n    burnEvent: z.lazy(() => hatsEventsConfigSchema).optional(),\n  })\n  .strict();\n\nexport const wearersConfigSchema: z.ZodType<WearersConfig> = z\n  .object({\n    props: z.object({\n      currentHats: z.lazy(() => hatsConfigSchema).optional(),\n      mintEvent: z.lazy(() => hatsEventsConfigSchema).optional(),\n      burnEvent: z.lazy(() => hatsEventsConfigSchema).optional(),\n    }),\n    filters: z\n      .object({\n        first: z.number().optional(),\n      })\n      .optional(),\n  })\n  .strict();\n\nexport const claimsHatterPropsConfigSchema: z.ZodType<ClaimsHatterPropsConfig> =\n  z\n    .object({\n      claimableHats: z.lazy(() => hatsConfigSchema).optional(),\n      claimableForHats: z.lazy(() => hatsConfigSchema).optional(),\n    })\n    .strict();\n\nexport const claimsHattersConfig: z.ZodType<ClaimsHattersConfig> = z\n  .object({\n    props: z.object({\n      claimableHats: z.lazy(() => hatsConfigSchema).optional(),\n      claimableForHats: z.lazy(() => hatsConfigSchema).optional(),\n    }),\n    filters: z\n      .object({\n        first: z.number().optional(),\n      })\n      .optional(),\n  })\n  .strict();\n\nexport const hatsEventPropsConfigSchema: z.ZodType<HatsEventPropsConfig> = z\n  .object({\n    timestamp: z.boolean().optional(),\n    blockNumber: z.boolean().optional(),\n    transactionID: z.boolean().optional(),\n    hat: z.lazy(() => hatPropsConfigSchema).optional(),\n    tree: z.lazy(() => treePropsConfigSchema).optional(),\n  })\n  .strict();\n\nexport const hatsEventsConfigSchema: z.ZodType<HatsEventsConfig> = z\n  .object({\n    props: z.object({\n      timestamp: z.boolean().optional(),\n      blockNumber: z.boolean().optional(),\n      transactionID: z.boolean().optional(),\n      hat: z.lazy(() => hatPropsConfigSchema).optional(),\n      tree: z.lazy(() => treePropsConfigSchema).optional(),\n    }),\n    filters: z\n      .object({\n        first: z.number().optional(),\n      })\n      .optional(),\n  })\n  .strict();\n"],"mappings":"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","names":["props"]}
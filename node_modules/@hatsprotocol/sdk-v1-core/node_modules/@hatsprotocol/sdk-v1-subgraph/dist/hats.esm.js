import { GraphQLClient, gql } from 'graphql-request';
import { z } from 'zod';

function hatIdDecimalToHex(hatId) {
    return "0x" + BigInt(hatId).toString(16).padStart(64, "0");
}
function treeIdDecimalToHex(treeId) {
    return "0x" + treeId.toString(16).padStart(8, "0");
}
function normalizeProps(config) {
    const fields = ["id"];
    for (const [key, value] of Object.entries(config)) {
        if (typeof value !== "object" && value === true) {
            fields.push(key);
        }
        if (typeof value === "object") {
            const withPropsAndFilters = "props" in value ? true : false;
            const subFields = normalizeProps(withPropsAndFilters ? value.props : value);
            const obj = {
                objName: key,
                objProps: subFields,
            };
            if (withPropsAndFilters &&
                value.filters !== undefined &&
                value.filters.first !== undefined) {
                obj["objFilters"] = { first: value.filters.first };
            }
            fields.push(obj);
        }
    }
    return fields;
}
function normalizedPropsToQueryFields(props) {
    let fields = "";
    for (let i = 0; i < props.length; i++) {
        if (i > 0) {
            fields += ", ";
        }
        const elem = props[i];
        if (typeof elem === "string") {
            fields = fields + `${elem}`;
        }
        if (typeof elem === "object") {
            const name = elem["objName"];
            const props = elem["objProps"];
            const first = elem["objFilters"] !== undefined
                ? elem["objFilters"]["first"]
                : undefined;
            if (first !== undefined) {
                if (name === "events") {
                    fields =
                        fields +
                            `${name} (orderBy: timestamp, orderDirection: desc, first: ${first}) { ${normalizedPropsToQueryFields(props)} 
            __typename 
            ... on HatCreatedEvent { hatDetails hatMaxSupply hatEligibility hatToggle hatMutable hatImageUri } 
            ... on HatMintedEvent { wearer { id } operator } 
            ... on HatBurnedEvent { wearer { id } operator } 
            ... on HatStatusChangedEvent { hatNewStatus } 
            ... on HatDetailsChangedEvent { hatNewDetails } 
            ... on HatEligibilityChangedEvent { hatNewEligibility } 
            ... on HatToggleChangedEvent { hatNewToggle } 
            ... on HatMaxSupplyChangedEvent { hatNewMaxSupply } 
            ... on HatImageURIChangedEvent { hatNewImageURI } 
            ... on TopHatLinkRequestedEvent { newAdmin } 
            ... on TopHatLinkedEvent { newAdmin } 
            ... on WearerStandingChangedEvent { wearer { id } wearerStanding } 
          }`;
                }
                else {
                    fields =
                        fields +
                            `${name} (first: ${first}) { ${normalizedPropsToQueryFields(props)} }`;
                }
            }
            else {
                if (name === "events") {
                    fields =
                        fields +
                            `${name} (orderBy: timestamp, orderDirection: desc) { 
              ${normalizedPropsToQueryFields(props)} 
              __typename 
              ... on HatCreatedEvent { hatDetails hatMaxSupply hatEligibility hatToggle hatMutable hatImageUri } 
              ... on HatMintedEvent { wearer { id } operator } 
              ... on HatBurnedEvent { wearer { id } operator } 
              ... on HatStatusChangedEvent { hatNewStatus } 
              ... on HatDetailsChangedEvent { hatNewDetails } 
              ... on HatEligibilityChangedEvent { hatNewEligibility } 
              ... on HatToggleChangedEvent { hatNewToggle } 
              ... on HatMaxSupplyChangedEvent { hatNewMaxSupply } 
              ... on HatImageURIChangedEvent { hatNewImageURI } 
              ... on TopHatLinkRequestedEvent { newAdmin } 
              ... on TopHatLinkedEvent { newAdmin } 
              ... on WearerStandingChangedEvent { wearer { id } wearerStanding } 
            }`;
                }
                else {
                    fields =
                        fields + `${name} { ${normalizedPropsToQueryFields(props)} }`;
                }
            }
        }
    }
    return fields;
}

const DEFAULT_ENDPOINTS_CONFIG = {
    1: {
        endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-ethereum/version/latest",
    },
    10: {
        endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-optimism/version/latest",
    },
    100: {
        endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-gnosis-chain/version/latest",
    },
    137: {
        endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-polygon/version/latest",
    },
    42161: {
        endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-arbitrum/version/latest",
    },
    11155111: {
        endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-sepolia/version/latest",
    },
    8453: {
        endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-base/version/latest",
    },
    42220: {
        endpoint: "https://api.studio.thegraph.com/query/55784/hats-v1-celo/version/latest",
    },
};

class SubgraphNotUpportedError extends Error {
    constructor(message) {
        super(message);
        this.name = "SubgraphNotUpportedError";
    }
}
class SubgraphHatNotExistError extends Error {
    constructor(message) {
        super(message);
        this.name = "SubgraphHatNotExistError";
    }
}
class SubgraphTreeNotExistError extends Error {
    constructor(message) {
        super(message);
        this.name = "SubgraphTreeNotExistError";
    }
}
class SubgraphWearerNotExistError extends Error {
    constructor(message) {
        super(message);
        this.name = "SubgraphWearerNotExistError";
    }
}
class InputValidationError extends Error {
    constructor(message) {
        super(message);
        this.name = "InputValidationError";
    }
}

const hatPropsConfigSchema = z
    .object({
    prettyId: z.boolean().optional(),
    status: z.boolean().optional(),
    createdAt: z.boolean().optional(),
    details: z.boolean().optional(),
    maxSupply: z.boolean().optional(),
    eligibility: z.boolean().optional(),
    toggle: z.boolean().optional(),
    mutable: z.boolean().optional(),
    imageUri: z.boolean().optional(),
    levelAtLocalTree: z.boolean().optional(),
    currentSupply: z.boolean().optional(),
    tree: z.lazy(() => treePropsConfigSchema).optional(),
    wearers: z.lazy(() => wearersConfigSchema).optional(),
    badStandings: z.lazy(() => wearersConfigSchema).optional(),
    admin: z.lazy(() => hatPropsConfigSchema).optional(),
    subHats: z.lazy(() => hatsConfigSchema).optional(),
    linkRequestFromTree: z.lazy(() => treesConfigSchema).optional(),
    linkedTrees: z.lazy(() => treesConfigSchema).optional(),
    claimableBy: z.lazy(() => claimsHattersConfig).optional(),
    claimableForBy: z.lazy(() => claimsHattersConfig).optional(),
    events: z.lazy(() => hatsEventsConfigSchema).optional(),
})
    .strict();
const hatsConfigSchema = z
    .object({
    props: z.object({
        prettyId: z.boolean().optional(),
        status: z.boolean().optional(),
        createdAt: z.boolean().optional(),
        details: z.boolean().optional(),
        maxSupply: z.boolean().optional(),
        eligibility: z.boolean().optional(),
        toggle: z.boolean().optional(),
        mutable: z.boolean().optional(),
        imageUri: z.boolean().optional(),
        levelAtLocalTree: z.boolean().optional(),
        currentSupply: z.boolean().optional(),
        tree: z.lazy(() => treePropsConfigSchema).optional(),
        wearers: z.lazy(() => wearersConfigSchema).optional(),
        badStandings: z.lazy(() => wearersConfigSchema).optional(),
        admin: z.lazy(() => hatPropsConfigSchema).optional(),
        subHats: z.lazy(() => hatsConfigSchema).optional(),
        linkRequestFromTree: z.lazy(() => treesConfigSchema).optional(),
        linkedTrees: z.lazy(() => treesConfigSchema).optional(),
        claimableBy: z.lazy(() => claimsHattersConfig).optional(),
        claimableForBy: z.lazy(() => claimsHattersConfig).optional(),
        events: z.lazy(() => hatsEventsConfigSchema).optional(),
    }),
    filters: z
        .object({
        first: z.number().optional(),
    })
        .optional(),
})
    .strict();
const treePropsConfigSchema = z
    .object({
    hats: z.lazy(() => hatsConfigSchema).optional(),
    childOfTree: z.lazy(() => treePropsConfigSchema).optional(),
    parentOfTrees: z.lazy(() => treesConfigSchema).optional(),
    linkedToHat: z.lazy(() => hatPropsConfigSchema).optional(),
    linkRequestFromTree: z.lazy(() => treesConfigSchema).optional(),
    requestedLinkToTree: z.lazy(() => treePropsConfigSchema).optional(),
    requestedLinkToHat: z.lazy(() => hatPropsConfigSchema).optional(),
    events: z.lazy(() => hatsEventsConfigSchema).optional(),
})
    .strict();
const treesConfigSchema = z
    .object({
    props: z.object({
        hats: z.lazy(() => hatsConfigSchema).optional(),
        childOfTree: z.lazy(() => treePropsConfigSchema).optional(),
        parentOfTrees: z.lazy(() => treesConfigSchema).optional(),
        linkedToHat: z.lazy(() => hatPropsConfigSchema).optional(),
        linkRequestFromTree: z.lazy(() => treesConfigSchema).optional(),
        requestedLinkToTree: z.lazy(() => treePropsConfigSchema).optional(),
        requestedLinkToHat: z.lazy(() => hatPropsConfigSchema).optional(),
        events: z.lazy(() => hatsEventsConfigSchema).optional(),
    }),
    filters: z
        .object({
        first: z.number().optional(),
    })
        .optional(),
})
    .strict();
const wearerPropsConfigSchema = z
    .object({
    currentHats: z.lazy(() => hatsConfigSchema).optional(),
    mintEvent: z.lazy(() => hatsEventsConfigSchema).optional(),
    burnEvent: z.lazy(() => hatsEventsConfigSchema).optional(),
})
    .strict();
const wearersConfigSchema = z
    .object({
    props: z.object({
        currentHats: z.lazy(() => hatsConfigSchema).optional(),
        mintEvent: z.lazy(() => hatsEventsConfigSchema).optional(),
        burnEvent: z.lazy(() => hatsEventsConfigSchema).optional(),
    }),
    filters: z
        .object({
        first: z.number().optional(),
    })
        .optional(),
})
    .strict();
z
    .object({
    claimableHats: z.lazy(() => hatsConfigSchema).optional(),
    claimableForHats: z.lazy(() => hatsConfigSchema).optional(),
})
    .strict();
const claimsHattersConfig = z
    .object({
    props: z.object({
        claimableHats: z.lazy(() => hatsConfigSchema).optional(),
        claimableForHats: z.lazy(() => hatsConfigSchema).optional(),
    }),
    filters: z
        .object({
        first: z.number().optional(),
    })
        .optional(),
})
    .strict();
z
    .object({
    timestamp: z.boolean().optional(),
    blockNumber: z.boolean().optional(),
    transactionID: z.boolean().optional(),
    hat: z.lazy(() => hatPropsConfigSchema).optional(),
    tree: z.lazy(() => treePropsConfigSchema).optional(),
})
    .strict();
const hatsEventsConfigSchema = z
    .object({
    props: z.object({
        timestamp: z.boolean().optional(),
        blockNumber: z.boolean().optional(),
        transactionID: z.boolean().optional(),
        hat: z.lazy(() => hatPropsConfigSchema).optional(),
        tree: z.lazy(() => treePropsConfigSchema).optional(),
    }),
    filters: z
        .object({
        first: z.number().optional(),
    })
        .optional(),
})
    .strict();

class HatsSubgraphClient {
    constructor({ config }) {
        if (config === undefined) {
            this._config = DEFAULT_ENDPOINTS_CONFIG;
        }
        else {
            this._config = config;
        }
    }
    async _makeGqlRequest(chainId, query, variables) {
        if (this._config[chainId] === undefined) {
            throw new SubgraphNotUpportedError(`No subgraph support for network id ${chainId}`);
        }
        const client = new GraphQLClient(this._config[chainId].endpoint);
        const result = (await client.request(query, variables));
        return result;
    }
    /**
     * Get a Hat by its ID.
     * The Hat's properties to fetch are configurable, including nested objects.
     *
     * @param chainId Id of the chain to fetch from.
     * @param hatId ID of the Hat to fetch.
     * @param props Hat's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
     * @param filters Optional filters to include in the query.
     * @returns A Hat object.
     *
     * @throws InputValidationError
     * Thrown if the provided properties are invalid.
     *
     * @throws SubgraphHatNotExistError
     * Thrown if the Hat does not exist in the subgraph.
     */
    async getHat({ chainId, hatId, props, }) {
        const validationRes = hatPropsConfigSchema.safeParse(props);
        if (validationRes.success === false) {
            throw new InputValidationError(validationRes.error.message);
        }
        const hatIdHex = hatIdDecimalToHex(hatId);
        const normalizedProps = normalizeProps(props);
        const queryFields = normalizedPropsToQueryFields(normalizedProps);
        const query = gql `
      query getHat($id: ID!) {
        hat(id: $id) {
          ${queryFields}
        }
      }
    `;
        const respone = await this._makeGqlRequest(chainId, query, {
            id: hatIdHex,
        });
        if (!respone.hat) {
            throw new SubgraphHatNotExistError(`Hat with an ID of ${hatId} does not exist in the subgraph for chain ID ${chainId}`);
        }
        return respone.hat;
    }
    /**
     * Get Hats by their IDs.
     * The properties to fetch for each Hat are configurable, including nested objects.
     *
     * @param chainId Id of the chain to fetch from.
     * @param hatIds IDs of the Hats to fetch.
     * @param props Hat's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
     * @param filters Optional filters to include in the query.
     * @returns An array of Hat objects.
     *
     * @throws InputValidationError
     * Thrown if the provided properties are invalid.
     *
     * @throws SubgraphHatNotExistError
     * Thrown if one or more of the Hats do not exist in the subgraph.
     */
    async getHatsByIds({ chainId, hatIds, props, }) {
        const validationRes = hatPropsConfigSchema.safeParse(props);
        if (validationRes.success === false) {
            throw new InputValidationError(validationRes.error.message);
        }
        const hatIdsHex = hatIds.map((id) => hatIdDecimalToHex(id));
        const normalizedProps = normalizeProps(props);
        const queryFields = normalizedPropsToQueryFields(normalizedProps);
        const query = gql `
      query getHatsByIds($ids: [ID!]!) {
        hats(where: { id_in: $ids }) {
            ${queryFields}
        }
      }
    `;
        const respone = await this._makeGqlRequest(chainId, query, {
            ids: hatIdsHex,
        });
        if (!respone.hats || respone.hats.length < hatIds.length) {
            throw new SubgraphHatNotExistError(`One or more of the provided hats do not exist in the subgraph for chain ID ${chainId}`);
        }
        return respone.hats;
    }
    /**
     * Get a Tree by its ID.
     * The Tree's properties to fetch are configurable, including nested objects.
     *
     * @param chainId Id of the chain to fetch from.
     * @param treeId ID of the Tree to fetch (the tree's top-hat domain - first 4 bytes of the top-hat ID).
     * @param props Tree's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
     * @param filters Optional filters to include in the query.
     * @returns A Tree object.
     *
     * @throws InputValidationError
     * Thrown if the provided properties are invalid.
     *
     * @throws SubgraphTreeNotExistError
     * Thrown if the Tree does not exist in the subgraph.
     */
    async getTree({ chainId, treeId, props, }) {
        const validationRes = treePropsConfigSchema.safeParse(props);
        if (validationRes.success === false) {
            throw new InputValidationError(validationRes.error.message);
        }
        const treeIdHex = treeIdDecimalToHex(treeId);
        const normalizedProps = normalizeProps(props);
        const queryFields = normalizedPropsToQueryFields(normalizedProps);
        const query = gql `
      query getTree($id: ID!) {
        tree(id: $id) {
          ${queryFields}
        }
      }
    `;
        const respone = await this._makeGqlRequest(chainId, query, {
            id: treeIdHex,
        });
        if (!respone.tree) {
            throw new SubgraphTreeNotExistError(`Tree with an ID of ${treeId} does not exist in the subgraph for chain ID ${chainId}`);
        }
        return respone.tree;
    }
    /**
     * Get Trees by their IDs.
     * The properties to fetch for each Tree are configurable, including nested objects.
     *
     * @param chainId Id of the chain to fetch from.
     * @param treeIds ID of the Trees to fetch (the tree's top-hat domain - first 4 bytes of the top-hat ID).
     * @param props Tree's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
     * @param filters Optional filters to include in the query.
     * @returns An array of Tree objects.
     *
     * @throws InputValidationError
     * Thrown if the provided properties are invalid.
     *
     * @throws SubgraphTreeNotExistError
     * Thrown if one or more of the Trees do not exist in the subgraph.
     */
    async getTreesByIds({ chainId, treeIds, props, }) {
        const validationRes = treePropsConfigSchema.safeParse(props);
        if (validationRes.success === false) {
            throw new InputValidationError(validationRes.error.message);
        }
        const treeIdsHex = treeIds.map((treeId) => treeIdDecimalToHex(treeId));
        const normalizedProps = normalizeProps(props);
        const queryFields = normalizedPropsToQueryFields(normalizedProps);
        const query = gql `
    query getTreesById($ids: [ID!]!) {
      trees(where: { id_in: $ids }) {
        ${queryFields}
      }
    }
  `;
        const respone = await this._makeGqlRequest(chainId, query, {
            ids: treeIdsHex,
        });
        if (!respone.trees || respone.trees.length < treeIds.length) {
            throw new SubgraphTreeNotExistError(`One or more of the provided trees do not exist in the subgraph for chain ID ${chainId}`);
        }
        return respone.trees;
    }
    /**
     * Paginate over all existing Trees.
     * The properties to fetch for each Tree are configurable, including nested objects.
     *
     * @param chainId Id of the chain to fetch from.
     * @param props Tree's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
     * @param page Number of page to fetch.
     * @param perPage Number of Trees to fetch in each page.
     * @param filters - Optional filters to include in the query.
     * @returns An array of Tree objects.
     *
     * @throws InputValidationError
     * Thrown if the provided properties are invalid.
     */
    async getTreesPaginated({ chainId, props, page, perPage, }) {
        const validationRes = treePropsConfigSchema.safeParse(props);
        if (validationRes.success === false) {
            throw new InputValidationError(validationRes.error.message);
        }
        const normalizedProps = normalizeProps(props);
        const queryFields = normalizedPropsToQueryFields(normalizedProps);
        const query = gql `
    query getPaginatedTrees($skip: Int!, $first: Int!) {
      trees(skip: $skip, first: $first) {
        ${queryFields}
      }
    }
  `;
        const respone = await this._makeGqlRequest(chainId, query, {
            skip: page * perPage,
            first: perPage,
        });
        if (!respone.trees) {
            throw new Error("Unexpected error");
        }
        return respone.trees;
    }
    /**
     * Get Wearer by its address.
     * The properties to fetch for each Wearer are configurable, including nested objects.
     *
     * @param chainId Id of the chain to fetch from.
     * @param wearerAddress Address of the wearer.
     * @param props Wearer's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
     * @param filters Optional filters to include in the query.
     * @returns A Wearer object.
     *
     * @throws InputValidationError
     * Thrown if the provided properties are invalid.
     *
     * @throws SubgraphWearerNotExistError
     * Thrown if the Wearer does not exist in the subgraph.
     */
    async getWearer({ chainId, wearerAddress, props, }) {
        const validationRes = wearerPropsConfigSchema.safeParse(props);
        if (validationRes.success === false) {
            throw new InputValidationError(validationRes.error.message);
        }
        const wearerAddressLowerCase = wearerAddress.toLowerCase();
        const normalizedProps = normalizeProps(props);
        const queryFields = normalizedPropsToQueryFields(normalizedProps);
        const query = gql `
      query getCurrentHatsForWearer($id: ID!) {
        wearer(id: $id) {
            ${queryFields}
        }
      }
    `;
        const respone = await this._makeGqlRequest(chainId, query, {
            id: wearerAddressLowerCase,
        });
        if (!respone.wearer) {
            throw new SubgraphWearerNotExistError(`Wearer with an address of ${wearerAddress} does not exist in the subgraph for chain ID ${chainId}`);
        }
        return respone.wearer;
    }
    /**
     * Paginate over the Wearers of a Hat.
     * The properties to fetch for each Wearer are configurable, including nested objects.
     *
     * @param chainId Id of the chain to fetch from.
     * @param hatId ID of the Hat for which Wearers to fetch.
     * @param props Wearer's properties to fetch, including the properties of nested objects. Pass an empty object to include only the object's ID.
     * @param page Number of page to fetch.
     * @param perPage Number of Wearers to fetch in each page.
     * @param filters Optional filters to include in the query.
     * @returns A Wearer object.
     *
     * @throws InputValidationError
     * Thrown if the provided properties are invalid.
     *
     * @throws SubgraphHatNotExistError
     * Thrown if the Hat does not exist in the subgraph.
     */
    async getWearersOfHatPaginated({ chainId, hatId, props, page, perPage, }) {
        const validationRes = wearerPropsConfigSchema.safeParse(props);
        if (validationRes.success === false) {
            throw new InputValidationError(validationRes.error.message);
        }
        const hatIdHex = hatIdDecimalToHex(hatId);
        const normalizedProps = normalizeProps(props);
        const queryFields = normalizedPropsToQueryFields(normalizedProps);
        const query = gql `
      query getPaginatedWearersForHat($hatId: ID!, $first: Int!, $skip: Int!) {
        hat(id: $hatId) {
            wearers(skip: $skip, first: $first) {
                ${queryFields}
            }
        }
      }
    `;
        const respone = await this._makeGqlRequest(chainId, query, {
            hatId: hatIdHex,
            skip: page * perPage,
            first: perPage,
        });
        if (!respone.hat) {
            throw new SubgraphHatNotExistError(`Hat with an ID of ${hatId} does not exist in the subgraph for chain ID ${chainId}`);
        }
        return respone.hat.wearers;
    }
    /**
     * Search Hat, Tree or Wearer by ID.
     * The properties to fetch for each object are configurable, including nested objects.
     *
     * @param chainId Id of the chain to fetch from.
     * @param search ID to search for (Hat ID or pretty ID, Tree ID or Wearer address).
     * @param treeProps Tree's properties to fetch (if Tree was found), including the properties of nested objects. Pass an empty object to include only the object's ID.
     * @param hatProps Hat's properties to fetch (if Hat was found), including the properties of nested objects. Pass an empty object to include only the object's ID.
     * @param wearerProps Wearer's properties to fetch (if Wearer was found), including the properties of nested objects. Pass an empty object to include only the object's ID.
     * @param filters Optional filters to include in the query.
     * @returns An object containing the search result.
     *
     * @throws InputValidationError
     * Thrown if the provided properties are invalid.
     */
    async searchTreesHatsWearers({ chainId, search, treeProps, hatProps, wearerProps, }) {
        const treeValidationRes = treePropsConfigSchema.safeParse(treeProps);
        if (treeValidationRes.success === false) {
            throw new InputValidationError(treeValidationRes.error.message);
        }
        const hatValidationRes = hatPropsConfigSchema.safeParse(hatProps);
        if (hatValidationRes.success === false) {
            throw new InputValidationError(hatValidationRes.error.message);
        }
        const wearerValidationRes = wearerPropsConfigSchema.safeParse(wearerProps);
        if (wearerValidationRes.success === false) {
            throw new InputValidationError(wearerValidationRes.error.message);
        }
        const treeNormalizedProps = normalizeProps(treeProps);
        const treeQueryFields = normalizedPropsToQueryFields(treeNormalizedProps);
        const hatNormalizedProps = normalizeProps(hatProps);
        const hatQueryFields = normalizedPropsToQueryFields(hatNormalizedProps);
        const wearerNormalizedProps = normalizeProps(wearerProps);
        const wearerQueryFields = normalizedPropsToQueryFields(wearerNormalizedProps);
        const query = gql `
      query search($search: String!) {
        trees(where: { id: $search }) {
          ${treeQueryFields}
        }
        hats(where: { or: [{ id: $search }, { prettyId: $search }] }) {
          ${hatQueryFields}
        }
        wearers(where: { id: $search }) {
          ${wearerQueryFields}
        }
      }
    `;
        const respone = await this._makeGqlRequest(chainId, query, {
            search: search.toLowerCase(),
        });
        if (!respone.wearers || !respone.trees || !respone.hats) {
            throw new Error("Unexpected error");
        }
        return respone;
    }
}

export { DEFAULT_ENDPOINTS_CONFIG, HatsSubgraphClient };

'use strict';

var viem = require('viem');
var sdkV1Subgraph = require('@hatsprotocol/sdk-v1-subgraph');

const HATS_ABI = [
    {
        inputs: [
            { internalType: "string", name: "_name", type: "string" },
            { internalType: "string", name: "_baseImageURI", type: "string" },
        ],
        stateMutability: "nonpayable",
        type: "constructor",
    },
    {
        inputs: [{ internalType: "uint256", name: "hatId", type: "uint256" }],
        name: "AllHatsWorn",
        type: "error",
    },
    {
        inputs: [
            { internalType: "address", name: "wearer", type: "address" },
            { internalType: "uint256", name: "hatId", type: "uint256" },
        ],
        name: "AlreadyWearingHat",
        type: "error",
    },
    { inputs: [], name: "BatchArrayLengthMismatch", type: "error" },
    { inputs: [], name: "CircularLinkage", type: "error" },
    { inputs: [], name: "CrossTreeLinkage", type: "error" },
    {
        inputs: [{ internalType: "uint256", name: "hatId", type: "uint256" }],
        name: "HatDoesNotExist",
        type: "error",
    },
    { inputs: [], name: "HatNotActive", type: "error" },
    { inputs: [], name: "Immutable", type: "error" },
    { inputs: [], name: "InvalidHatId", type: "error" },
    { inputs: [], name: "InvalidUnlink", type: "error" },
    { inputs: [], name: "LinkageNotRequested", type: "error" },
    { inputs: [], name: "MaxLevelsReached", type: "error" },
    { inputs: [], name: "MaxLevelsReached", type: "error" },
    { inputs: [], name: "NewMaxSupplyTooLow", type: "error" },
    {
        inputs: [
            { internalType: "address", name: "user", type: "address" },
            { internalType: "uint256", name: "hatId", type: "uint256" },
        ],
        name: "NotAdmin",
        type: "error",
    },
    { inputs: [], name: "NotAdminOrWearer", type: "error" },
    { inputs: [], name: "NotEligible", type: "error" },
    { inputs: [], name: "NotHatWearer", type: "error" },
    { inputs: [], name: "NotHatsEligibility", type: "error" },
    { inputs: [], name: "NotHatsToggle", type: "error" },
    { inputs: [], name: "StringTooLong", type: "error" },
    { inputs: [], name: "ZeroAddress", type: "error" },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "owner",
                type: "address",
            },
            {
                indexed: true,
                internalType: "address",
                name: "operator",
                type: "address",
            },
            { indexed: false, internalType: "bool", name: "approved", type: "bool" },
        ],
        name: "ApprovalForAll",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            { indexed: false, internalType: "uint256", name: "id", type: "uint256" },
            {
                indexed: false,
                internalType: "string",
                name: "details",
                type: "string",
            },
            {
                indexed: false,
                internalType: "uint32",
                name: "maxSupply",
                type: "uint32",
            },
            {
                indexed: false,
                internalType: "address",
                name: "eligibility",
                type: "address",
            },
            {
                indexed: false,
                internalType: "address",
                name: "toggle",
                type: "address",
            },
            { indexed: false, internalType: "bool", name: "mutable_", type: "bool" },
            {
                indexed: false,
                internalType: "string",
                name: "imageURI",
                type: "string",
            },
        ],
        name: "HatCreated",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "hatId",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "string",
                name: "newDetails",
                type: "string",
            },
        ],
        name: "HatDetailsChanged",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "hatId",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "address",
                name: "newEligibility",
                type: "address",
            },
        ],
        name: "HatEligibilityChanged",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "hatId",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "string",
                name: "newImageURI",
                type: "string",
            },
        ],
        name: "HatImageURIChanged",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "hatId",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "uint32",
                name: "newMaxSupply",
                type: "uint32",
            },
        ],
        name: "HatMaxSupplyChanged",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "hatId",
                type: "uint256",
            },
        ],
        name: "HatMutabilityChanged",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "hatId",
                type: "uint256",
            },
            { indexed: false, internalType: "bool", name: "newStatus", type: "bool" },
        ],
        name: "HatStatusChanged",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "hatId",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "address",
                name: "newToggle",
                type: "address",
            },
        ],
        name: "HatToggleChanged",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint32",
                name: "domain",
                type: "uint32",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "newAdmin",
                type: "uint256",
            },
        ],
        name: "TopHatLinkRequested",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint32",
                name: "domain",
                type: "uint32",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "newAdmin",
                type: "uint256",
            },
        ],
        name: "TopHatLinked",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "operator",
                type: "address",
            },
            { indexed: true, internalType: "address", name: "from", type: "address" },
            { indexed: true, internalType: "address", name: "to", type: "address" },
            {
                indexed: false,
                internalType: "uint256[]",
                name: "ids",
                type: "uint256[]",
            },
            {
                indexed: false,
                internalType: "uint256[]",
                name: "amounts",
                type: "uint256[]",
            },
        ],
        name: "TransferBatch",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: true,
                internalType: "address",
                name: "operator",
                type: "address",
            },
            { indexed: true, internalType: "address", name: "from", type: "address" },
            { indexed: true, internalType: "address", name: "to", type: "address" },
            { indexed: false, internalType: "uint256", name: "id", type: "uint256" },
            {
                indexed: false,
                internalType: "uint256",
                name: "amount",
                type: "uint256",
            },
        ],
        name: "TransferSingle",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            { indexed: false, internalType: "string", name: "value", type: "string" },
            { indexed: true, internalType: "uint256", name: "id", type: "uint256" },
        ],
        name: "URI",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "hatId",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "address",
                name: "wearer",
                type: "address",
            },
            {
                indexed: false,
                internalType: "bool",
                name: "wearerStanding",
                type: "bool",
            },
        ],
        name: "WearerStandingChanged",
        type: "event",
    },
    {
        inputs: [
            { internalType: "uint32", name: "_topHatDomain", type: "uint32" },
            { internalType: "uint256", name: "_newAdminHat", type: "uint256" },
            { internalType: "address", name: "_eligibility", type: "address" },
            { internalType: "address", name: "_toggle", type: "address" },
            { internalType: "string", name: "_details", type: "string" },
            { internalType: "string", name: "_imageURI", type: "string" },
        ],
        name: "approveLinkTopHatToTree",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint256", name: "", type: "uint256" },
            { internalType: "address", name: "", type: "address" },
        ],
        name: "badStandings",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            { internalType: "address", name: "_wearer", type: "address" },
            { internalType: "uint256", name: "_hatId", type: "uint256" },
        ],
        name: "balanceOf",
        outputs: [{ internalType: "uint256", name: "balance", type: "uint256" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            { internalType: "address[]", name: "_wearers", type: "address[]" },
            { internalType: "uint256[]", name: "_hatIds", type: "uint256[]" },
        ],
        name: "balanceOfBatch",
        outputs: [
            { internalType: "uint256[]", name: "balances", type: "uint256[]" },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "baseImageURI",
        outputs: [{ internalType: "string", name: "", type: "string" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint256[]", name: "_admins", type: "uint256[]" },
            { internalType: "string[]", name: "_details", type: "string[]" },
            { internalType: "uint32[]", name: "_maxSupplies", type: "uint32[]" },
            {
                internalType: "address[]",
                name: "_eligibilityModules",
                type: "address[]",
            },
            { internalType: "address[]", name: "_toggleModules", type: "address[]" },
            { internalType: "bool[]", name: "_mutables", type: "bool[]" },
            { internalType: "string[]", name: "_imageURIs", type: "string[]" },
        ],
        name: "batchCreateHats",
        outputs: [{ internalType: "bool", name: "success", type: "bool" }],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint256[]", name: "_hatIds", type: "uint256[]" },
            { internalType: "address[]", name: "_wearers", type: "address[]" },
        ],
        name: "batchMintHats",
        outputs: [{ internalType: "bool", name: "success", type: "bool" }],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint256", name: "_admin", type: "uint256" },
            { internalType: "uint16", name: "_newHat", type: "uint16" },
        ],
        name: "buildHatId",
        outputs: [{ internalType: "uint256", name: "id", type: "uint256" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint256", name: "_hatId", type: "uint256" },
            { internalType: "string", name: "_newDetails", type: "string" },
        ],
        name: "changeHatDetails",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint256", name: "_hatId", type: "uint256" },
            { internalType: "address", name: "_newEligibility", type: "address" },
        ],
        name: "changeHatEligibility",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint256", name: "_hatId", type: "uint256" },
            { internalType: "string", name: "_newImageURI", type: "string" },
        ],
        name: "changeHatImageURI",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint256", name: "_hatId", type: "uint256" },
            { internalType: "uint32", name: "_newMaxSupply", type: "uint32" },
        ],
        name: "changeHatMaxSupply",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint256", name: "_hatId", type: "uint256" },
            { internalType: "address", name: "_newToggle", type: "address" },
        ],
        name: "changeHatToggle",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "checkHatStatus",
        outputs: [{ internalType: "bool", name: "toggled", type: "bool" }],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint256", name: "_hatId", type: "uint256" },
            { internalType: "address", name: "_wearer", type: "address" },
        ],
        name: "checkHatWearerStatus",
        outputs: [{ internalType: "bool", name: "updated", type: "bool" }],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint256", name: "_admin", type: "uint256" },
            { internalType: "string", name: "_details", type: "string" },
            { internalType: "uint32", name: "_maxSupply", type: "uint32" },
            { internalType: "address", name: "_eligibility", type: "address" },
            { internalType: "address", name: "_toggle", type: "address" },
            { internalType: "bool", name: "_mutable", type: "bool" },
            { internalType: "string", name: "_imageURI", type: "string" },
        ],
        name: "createHat",
        outputs: [{ internalType: "uint256", name: "newHatId", type: "uint256" }],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint256", name: "_hatId", type: "uint256" },
            { internalType: "uint32", name: "_level", type: "uint32" },
        ],
        name: "getAdminAtLevel",
        outputs: [{ internalType: "uint256", name: "admin", type: "uint256" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint256", name: "_hatId", type: "uint256" },
            { internalType: "uint32", name: "_level", type: "uint32" },
        ],
        name: "getAdminAtLocalLevel",
        outputs: [{ internalType: "uint256", name: "admin", type: "uint256" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "getHatEligibilityModule",
        outputs: [
            { internalType: "address", name: "eligibility", type: "address" },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "getHatLevel",
        outputs: [{ internalType: "uint32", name: "level", type: "uint32" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "getHatMaxSupply",
        outputs: [{ internalType: "uint32", name: "maxSupply", type: "uint32" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "getHatToggleModule",
        outputs: [{ internalType: "address", name: "toggle", type: "address" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "getImageURIForHat",
        outputs: [{ internalType: "string", name: "_uri", type: "string" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "getLocalHatLevel",
        outputs: [{ internalType: "uint32", name: "level", type: "uint32" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_admin", type: "uint256" }],
        name: "getNextId",
        outputs: [{ internalType: "uint256", name: "nextId", type: "uint256" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint32", name: "_topHatDomain", type: "uint32" }],
        name: "getTippyTopHatDomain",
        outputs: [{ internalType: "uint32", name: "domain", type: "uint32" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "getTopHatDomain",
        outputs: [{ internalType: "uint32", name: "domain", type: "uint32" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "hatSupply",
        outputs: [{ internalType: "uint32", name: "supply", type: "uint32" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "isActive",
        outputs: [{ internalType: "bool", name: "active", type: "bool" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            { internalType: "address", name: "_user", type: "address" },
            { internalType: "uint256", name: "_hatId", type: "uint256" },
        ],
        name: "isAdminOfHat",
        outputs: [{ internalType: "bool", name: "isAdmin", type: "bool" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            { internalType: "address", name: "", type: "address" },
            { internalType: "address", name: "", type: "address" },
        ],
        name: "isApprovedForAll",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            { internalType: "address", name: "_wearer", type: "address" },
            { internalType: "uint256", name: "_hatId", type: "uint256" },
        ],
        name: "isEligible",
        outputs: [{ internalType: "bool", name: "eligible", type: "bool" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            { internalType: "address", name: "_wearer", type: "address" },
            { internalType: "uint256", name: "_hatId", type: "uint256" },
        ],
        name: "isInGoodStanding",
        outputs: [{ internalType: "bool", name: "standing", type: "bool" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "isLocalTopHat",
        outputs: [{ internalType: "bool", name: "_isLocalTopHat", type: "bool" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "isTopHat",
        outputs: [{ internalType: "bool", name: "_isTopHat", type: "bool" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "isValidHatId",
        outputs: [{ internalType: "bool", name: "validHatId", type: "bool" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [
            { internalType: "address", name: "_user", type: "address" },
            { internalType: "uint256", name: "_hatId", type: "uint256" },
        ],
        name: "isWearerOfHat",
        outputs: [{ internalType: "bool", name: "isWearer", type: "bool" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "lastTopHatId",
        outputs: [{ internalType: "uint32", name: "", type: "uint32" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint32", name: "", type: "uint32" }],
        name: "linkedTreeAdmins",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint32", name: "", type: "uint32" }],
        name: "linkedTreeRequests",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "makeHatImmutable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint256", name: "_hatId", type: "uint256" },
            { internalType: "address", name: "_wearer", type: "address" },
        ],
        name: "mintHat",
        outputs: [{ internalType: "bool", name: "success", type: "bool" }],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            { internalType: "address", name: "_target", type: "address" },
            { internalType: "string", name: "_details", type: "string" },
            { internalType: "string", name: "_imageURI", type: "string" },
        ],
        name: "mintTopHat",
        outputs: [{ internalType: "uint256", name: "topHatId", type: "uint256" }],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [{ internalType: "bytes[]", name: "data", type: "bytes[]" }],
        name: "multicall",
        outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "name",
        outputs: [{ internalType: "string", name: "", type: "string" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint32", name: "_topHatDomain", type: "uint32" },
            { internalType: "uint256", name: "_linkedAdmin", type: "uint256" },
        ],
        name: "noCircularLinkage",
        outputs: [{ internalType: "bool", name: "notCircular", type: "bool" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint32", name: "_topHatDomain", type: "uint32" },
            { internalType: "uint256", name: "_newAdminHat", type: "uint256" },
            { internalType: "address", name: "_eligibility", type: "address" },
            { internalType: "address", name: "_toggle", type: "address" },
            { internalType: "string", name: "_details", type: "string" },
            { internalType: "string", name: "_imageURI", type: "string" },
        ],
        name: "relinkTopHatWithinTree",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "renounceHat",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint32", name: "_topHatDomain", type: "uint32" },
            { internalType: "uint256", name: "_requestedAdminHat", type: "uint256" },
        ],
        name: "requestLinkTopHatToTree",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            { internalType: "address", name: "", type: "address" },
            { internalType: "address", name: "", type: "address" },
            { internalType: "uint256[]", name: "", type: "uint256[]" },
            { internalType: "uint256[]", name: "", type: "uint256[]" },
            { internalType: "bytes", name: "", type: "bytes" },
        ],
        name: "safeBatchTransferFrom",
        outputs: [],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [
            { internalType: "address", name: "", type: "address" },
            { internalType: "address", name: "", type: "address" },
            { internalType: "uint256", name: "", type: "uint256" },
            { internalType: "uint256", name: "", type: "uint256" },
            { internalType: "bytes", name: "", type: "bytes" },
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint32", name: "_topHatDomain", type: "uint32" },
            { internalType: "uint256", name: "_newAdminHat", type: "uint256" },
        ],
        name: "sameTippyTopHatDomain",
        outputs: [{ internalType: "bool", name: "sameDomain", type: "bool" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            { internalType: "address", name: "", type: "address" },
            { internalType: "bool", name: "", type: "bool" },
        ],
        name: "setApprovalForAll",
        outputs: [],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint256", name: "_hatId", type: "uint256" },
            { internalType: "bool", name: "_newStatus", type: "bool" },
        ],
        name: "setHatStatus",
        outputs: [{ internalType: "bool", name: "toggled", type: "bool" }],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint256", name: "_hatId", type: "uint256" },
            { internalType: "address", name: "_wearer", type: "address" },
            { internalType: "bool", name: "_eligible", type: "bool" },
            { internalType: "bool", name: "_standing", type: "bool" },
        ],
        name: "setHatWearerStatus",
        outputs: [{ internalType: "bool", name: "updated", type: "bool" }],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
        name: "supportsInterface",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint256", name: "_hatId", type: "uint256" },
            { internalType: "address", name: "_from", type: "address" },
            { internalType: "address", name: "_to", type: "address" },
        ],
        name: "transferHat",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint32", name: "_topHatDomain", type: "uint32" },
            { internalType: "address", name: "_wearer", type: "address" },
        ],
        name: "unlinkTopHatFromTree",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "id", type: "uint256" }],
        name: "uri",
        outputs: [{ internalType: "string", name: "_uri", type: "string" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "viewHat",
        outputs: [
            { internalType: "string", name: "details", type: "string" },
            { internalType: "uint32", name: "maxSupply", type: "uint32" },
            { internalType: "uint32", name: "supply", type: "uint32" },
            { internalType: "address", name: "eligibility", type: "address" },
            { internalType: "address", name: "toggle", type: "address" },
            { internalType: "string", name: "imageURI", type: "string" },
            { internalType: "uint16", name: "lastHatId", type: "uint16" },
            { internalType: "bool", name: "mutable_", type: "bool" },
            { internalType: "bool", name: "active", type: "bool" },
        ],
        stateMutability: "view",
        type: "function",
    },
];

const CLAIMS_HATTER_ABI = [
    {
        inputs: [{ internalType: "string", name: "_version", type: "string" }],
        stateMutability: "nonpayable",
        type: "constructor",
    },
    { inputs: [], name: "MultiClaimsHatter_ArrayLengthMismatch", type: "error" },
    {
        inputs: [{ internalType: "uint256", name: "hatId", type: "uint256" }],
        name: "MultiClaimsHatter_HatNotClaimable",
        type: "error",
    },
    {
        inputs: [{ internalType: "uint256", name: "hatId", type: "uint256" }],
        name: "MultiClaimsHatter_HatNotClaimableFor",
        type: "error",
    },
    {
        inputs: [
            { internalType: "address", name: "account", type: "address" },
            { internalType: "uint256", name: "hatId", type: "uint256" },
        ],
        name: "MultiClaimsHatter_NotAdminOfHat",
        type: "error",
    },
    {
        inputs: [
            { internalType: "address", name: "account", type: "address" },
            { internalType: "uint256", name: "hatId", type: "uint256" },
        ],
        name: "MultiClaimsHatter_NotExplicitlyEligible",
        type: "error",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256",
                name: "hatId",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "enum MultiClaimsHatter.ClaimType",
                name: "claimType",
                type: "uint8",
            },
        ],
        name: "HatClaimabilitySet",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint256[]",
                name: "hatIds",
                type: "uint256[]",
            },
            {
                indexed: false,
                internalType: "enum MultiClaimsHatter.ClaimType[]",
                name: "claimTypes",
                type: "uint8[]",
            },
        ],
        name: "HatsClaimabilitySet",
        type: "event",
    },
    {
        anonymous: false,
        inputs: [
            { indexed: false, internalType: "uint8", name: "version", type: "uint8" },
        ],
        name: "Initialized",
        type: "event",
    },
    {
        inputs: [],
        name: "HATS",
        outputs: [{ internalType: "contract IHats", name: "", type: "address" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [],
        name: "IMPLEMENTATION",
        outputs: [{ internalType: "address", name: "", type: "address" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [
            { internalType: "address", name: "_account", type: "address" },
            { internalType: "uint256", name: "_hatId", type: "uint256" },
        ],
        name: "accountCanClaim",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            { internalType: "address", name: "_account", type: "address" },
            { internalType: "uint256", name: "_hatId", type: "uint256" },
        ],
        name: "canClaimForAccount",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "claimHat",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint256", name: "_hatId", type: "uint256" },
            { internalType: "address", name: "_account", type: "address" },
        ],
        name: "claimHatFor",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256[]", name: "_hatIds", type: "uint256[]" }],
        name: "claimHats",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint256[]", name: "_hatIds", type: "uint256[]" },
            { internalType: "address[]", name: "_accounts", type: "address[]" },
        ],
        name: "claimHatsFor",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "hatExists",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "hatId",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "hatId", type: "uint256" }],
        name: "hatToClaimType",
        outputs: [
            {
                internalType: "enum MultiClaimsHatter.ClaimType",
                name: "claimType",
                type: "uint8",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "isClaimableBy",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "isClaimableFor",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint256", name: "_hatId", type: "uint256" },
            {
                internalType: "enum MultiClaimsHatter.ClaimType",
                name: "_claimType",
                type: "uint8",
            },
        ],
        name: "setHatClaimability",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "contract HatsModuleFactory",
                name: "_factory",
                type: "address",
            },
            { internalType: "address", name: "_implementation", type: "address" },
            { internalType: "uint256", name: "_moduleHatId", type: "uint256" },
            { internalType: "bytes", name: "_otherImmutableArgs", type: "bytes" },
            { internalType: "bytes", name: "_initData", type: "bytes" },
            { internalType: "uint256", name: "_hatId", type: "uint256" },
            {
                internalType: "enum MultiClaimsHatter.ClaimType",
                name: "_claimType",
                type: "uint8",
            },
        ],
        name: "setHatClaimabilityAndCreateModule",
        outputs: [{ internalType: "address", name: "_instance", type: "address" }],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            { internalType: "uint256[]", name: "_hatIds", type: "uint256[]" },
            {
                internalType: "enum MultiClaimsHatter.ClaimType[]",
                name: "_claimTypes",
                type: "uint8[]",
            },
        ],
        name: "setHatsClaimability",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "contract HatsModuleFactory",
                name: "_factory",
                type: "address",
            },
            {
                internalType: "address[]",
                name: "_implementations",
                type: "address[]",
            },
            { internalType: "uint256[]", name: "_moduleHatIds", type: "uint256[]" },
            {
                internalType: "bytes[]",
                name: "_otherImmutableArgsArray",
                type: "bytes[]",
            },
            { internalType: "bytes[]", name: "_initDataArray", type: "bytes[]" },
            { internalType: "uint256[]", name: "_hatIds", type: "uint256[]" },
            {
                internalType: "enum MultiClaimsHatter.ClaimType[]",
                name: "_claimTypes",
                type: "uint8[]",
            },
        ],
        name: "setHatsClaimabilityAndCreateModules",
        outputs: [{ internalType: "bool", name: "success", type: "bool" }],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [{ internalType: "bytes", name: "_initData", type: "bytes" }],
        name: "setUp",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "version",
        outputs: [{ internalType: "string", name: "", type: "string" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "version_",
        outputs: [{ internalType: "string", name: "", type: "string" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "wearsAdmin",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            { internalType: "string", name: "_name", type: "string" },
            { internalType: "string", name: "_baseImageURI", type: "string" },
        ],
        stateMutability: "nonpayable",
        type: "constructor",
    },
    {
        inputs: [{ internalType: "uint256", name: "hatId", type: "uint256" }],
        name: "AllHatsWorn",
        type: "error",
    },
    {
        inputs: [
            { internalType: "address", name: "wearer", type: "address" },
            { internalType: "uint256", name: "hatId", type: "uint256" },
        ],
        name: "AlreadyWearingHat",
        type: "error",
    },
    { inputs: [], name: "BatchArrayLengthMismatch", type: "error" },
    { inputs: [], name: "CircularLinkage", type: "error" },
    { inputs: [], name: "CrossTreeLinkage", type: "error" },
    {
        inputs: [{ internalType: "uint256", name: "hatId", type: "uint256" }],
        name: "HatDoesNotExist",
        type: "error",
    },
    { inputs: [], name: "HatNotActive", type: "error" },
    { inputs: [], name: "Immutable", type: "error" },
    { inputs: [], name: "InvalidHatId", type: "error" },
    { inputs: [], name: "InvalidUnlink", type: "error" },
    { inputs: [], name: "LinkageNotRequested", type: "error" },
    { inputs: [], name: "MaxLevelsReached", type: "error" },
    { inputs: [], name: "MaxLevelsReached", type: "error" },
    { inputs: [], name: "NewMaxSupplyTooLow", type: "error" },
    {
        inputs: [
            { internalType: "address", name: "user", type: "address" },
            { internalType: "uint256", name: "hatId", type: "uint256" },
        ],
        name: "NotAdmin",
        type: "error",
    },
    { inputs: [], name: "NotAdminOrWearer", type: "error" },
    { inputs: [], name: "NotEligible", type: "error" },
    { inputs: [], name: "NotHatWearer", type: "error" },
    { inputs: [], name: "NotHatsEligibility", type: "error" },
    { inputs: [], name: "NotHatsToggle", type: "error" },
    { inputs: [], name: "StringTooLong", type: "error" },
    { inputs: [], name: "ZeroAddress", type: "error" },
];

class ChainIdMismatchError extends Error {
    constructor(message) {
        super(message);
        this.name = "ChainIdMismatchError";
    }
}
class MissingPublicClientError extends Error {
    constructor(message) {
        super(message);
        this.name = "MissingPublicClientError";
    }
}
class MissingWalletClientError extends Error {
    constructor(message) {
        super(message);
        this.name = "MissingWalletClientError";
    }
}
class ZeroAddressError extends Error {
    constructor(message) {
        super(message);
        this.name = "ZeroAddressError";
    }
}
class InvalidAdminError extends Error {
    constructor(message) {
        super(message);
        this.name = "InvalidAdminError";
    }
}
class NotAdminError extends Error {
    constructor(message) {
        super(message);
        this.name = "NotAdminError";
    }
}
class HatNotExistError extends Error {
    constructor(message) {
        super(message);
        this.name = "HatNotExistError";
    }
}
class AllHatsWornError extends Error {
    constructor(message) {
        super(message);
        this.name = "AllHatsWornError";
    }
}
class NotEligibleError extends Error {
    constructor(message) {
        super(message);
        this.name = "NotEligibleError";
    }
}
class NotExplicitlyEligibleError extends Error {
    constructor(message) {
        super(message);
        this.name = "NotExplicitlyEligibleError";
    }
}
class NotActiveError extends Error {
    constructor(message) {
        super(message);
        this.name = "NotActiveError";
    }
}
class AlreadyWearingError extends Error {
    constructor(message) {
        super(message);
        this.name = "AlreadyWearingError";
    }
}
class NotToggleError extends Error {
    constructor(message) {
        super(message);
        this.name = "NotToggleError";
    }
}
class NotEligibilityError extends Error {
    constructor(message) {
        super(message);
        this.name = "NotEligibilityError";
    }
}
class ImmutableHatError extends Error {
    constructor(message) {
        super(message);
        this.name = "ImmutableHatError";
    }
}
class NotWearerError extends Error {
    constructor(message) {
        super(message);
        this.name = "NotWearerError";
    }
}
class StringTooLongError extends Error {
    constructor(message) {
        super(message);
        this.name = "StringTooLongError";
    }
}
class InvalidMaxSupplyError extends Error {
    constructor(message) {
        super(message);
        this.name = "InvalidMaxSupplyError";
    }
}
class NoLinkageRequestError extends Error {
    constructor(message) {
        super(message);
        this.name = "NoLinkageRequestError";
    }
}
class NotAdminOrWearerError extends Error {
    constructor(message) {
        super(message);
        this.name = "NotAdminOrWearerError";
    }
}
class CircularLinkageError extends Error {
    constructor(message) {
        super(message);
        this.name = "CircularLinkageError";
    }
}
class CrossLinkageError extends Error {
    constructor(message) {
        super(message);
        this.name = "CrossLinkageError";
    }
}
class BatchParamsError extends Error {
    constructor(message) {
        super(message);
        this.name = "BatchParamsError";
    }
}
class MaxLevelReachedError extends Error {
    constructor(message) {
        super(message);
        this.name = "MaxLevelReachedError";
    }
}
class MaxHatsInLevelReached extends Error {
    constructor(message) {
        super(message);
        this.name = "MaxHatsInLevelReached";
    }
}
class InvalidUnlinkError extends Error {
    constructor(message) {
        super(message);
        this.name = "InvalidUnlinkError";
    }
}
class HatNotClaimableError extends Error {
    constructor(message) {
        super(message);
        this.name = "HatNotClaimableError";
    }
}
class HatNotClaimableForError extends Error {
    constructor(message) {
        super(message);
        this.name = "HatNotClaimableForError";
    }
}

const HATS_V1 = "0x3bc1A0Ad72417f2d411118085256fC53CBdDd137";
const ZERO_ADDRESS = "0x0000000000000000000000000000000000000000";
const MAX_LEVELS = 14;
const MAX_LEVEL_HATS = 65535;
const ZERO_ID = "0x0000000000000000000000000000000000000000000000000000000000000000";
const FALLBACK_ADDRESS = "0x0000000000000000000000000000000000004a75";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
function getError(err) {
    if (err instanceof viem.BaseError) {
        const revertError = err.walk((err) => err instanceof viem.ContractFunctionRevertedError);
        if (revertError instanceof viem.ContractFunctionRevertedError) {
            const errorName = revertError.data?.errorName ?? "";
            const errorArgs = revertError.data?.args;
            switch (errorName) {
                case "NotAdmin": {
                    throw new NotAdminError(`Error: address ${errorArgs[0]} is attempting to perform an action on ${errorArgs[1]} but is not wearing one of its admin hats`);
                }
                case "NotHatWearer": {
                    throw new NotWearerError(`Error: attempting to perform an action as or for an account that is not a wearer of a given hat`);
                }
                case "NotAdminOrWearer": {
                    throw new NotAdminOrWearerError(`Error: attempting to perform an action that requires being either an admin or wearer of a given hat`);
                }
                case "AllHatsWorn": {
                    throw new AllHatsWornError(`Error: attempting to mint ${errorArgs[0]} but its maxSupply has been reached`);
                }
                case "MaxLevelsReached": {
                    throw new MaxLevelReachedError(`Error: attempting to create a hat with a level 14 hat as its admin`);
                }
                case "InvalidHatId": {
                    throw new InvalidAdminError(`Error: provided hat id has empty intermediate level(s)`);
                }
                case "AlreadyWearingHat": {
                    throw new AlreadyWearingError(`Error: attempting to mint hat with ID ${errorArgs[1]} to address ${errorArgs[0]} who is already wearing the hat`);
                }
                case "HatDoesNotExist": {
                    throw new HatNotExistError(`Error: attempting to mint a non-existant hat with ID ${errorArgs[0]}`);
                }
                case "HatNotActive": {
                    throw new NotActiveError(`Error: attempting to mint or transfer a hat that is not active`);
                }
                case "NotEligible": {
                    throw new NotEligibleError(`Error: attempting to mint or transfer a hat to an ineligible wearer`);
                }
                case "NotHatsToggle": {
                    throw new NotToggleError(`Error: attempting to set a hat's status from an account that is not that hat's toggle module`);
                }
                case "NotHatsEligibility": {
                    throw new NotEligibilityError(`Error: attempting to check or set a hat wearer's status from an account that is not that hat's eligibility module`);
                }
                case "BatchArrayLengthMismatch": {
                    throw new BatchParamsError(`Error: array arguments to a batch function have mismatching lengths`);
                }
                case "Immutable": {
                    throw new ImmutableHatError(`Error: attempting to mutate or transfer an immutable hat`);
                }
                case "NewMaxSupplyTooLow": {
                    throw new InvalidMaxSupplyError(`Error: attempting to mutate or transfer an immutable hat`);
                }
                case "CircularLinkage": {
                    throw new CircularLinkageError(`Error: attempting to link a tophat to a new admin for which the tophat serves as an admin`);
                }
                case "CrossTreeLinkage": {
                    throw new CrossLinkageError(`Error: attempting to link or relink a tophat to a separate tree`);
                }
                case "LinkageNotRequested": {
                    throw new NoLinkageRequestError(`Error: attempting to link a tophat without a request`);
                }
                case "InvalidUnlink": {
                    throw new InvalidUnlinkError(`Error: attempting to unlink a tophat that does not have a wearer`);
                }
                case "ZeroAddress": {
                    throw new ZeroAddressError(`Error: attempting to change a hat's eligibility or toggle module to the zero address`);
                }
                case "StringTooLong": {
                    throw new StringTooLongError(`Error: attempting to change a hat's details or imageURI to a string with over 7000 bytes (~characters)`);
                }
                case "MultiClaimsHatter_ArrayLengthMismatch": {
                    throw new BatchParamsError(`Error: array arguments to a batch function have mismatching lengths`);
                }
                case "MultiClaimsHatter_NotAdminOfHat": {
                    throw new NotAdminError(`Error: address ${errorArgs[0]} is attempting to set the claimability of hat ${errorArgs[1]} but is not wearing one of its admin hats`);
                }
                case "MultiClaimsHatter_NotExplicitlyEligible": {
                    throw new NotExplicitlyEligibleError(`Error: address ${errorArgs[0]} is not explicitly eligible for hat ${errorArgs[1]}`);
                }
                case "MultiClaimsHatter_HatNotClaimable": {
                    throw new HatNotClaimableError(`Error: attempting to claim hat ${errorArgs[0]}, which is not claimable`);
                }
                case "MultiClaimsHatter_HatNotClaimableFor": {
                    throw new HatNotClaimableForError(`Error: attempting to claim hat ${errorArgs[0]} on behalf of an account, but the hat is not claimable-for`);
                }
                default: {
                    throw err;
                }
            }
        }
    }
    else {
        if (err instanceof Error) {
            throw err;
        }
        else {
            throw new Error("Unexpected error occured");
        }
    }
}

class HatsReadClient {
    /**
     * Initialize a HatsClient.
     *
     * @param chainId - Client chain ID. The client is initialized to work with one specific chain.
     * @param publicClient - Viem Public Client
     * @returns A HatsCallDataClient instance.
     *
     * @throws MissingPublicClientError
     * Thrown when a public client is not provided.
     *
     * @throws ChainIdMismatchError
     * Thrown when there is a chain ID mismatch between one of the Viem clients and/or the provided chain ID.
     */
    constructor({ chainId, publicClient, }) {
        if (publicClient === undefined) {
            throw new MissingPublicClientError("Public client is required");
        }
        if (publicClient.chain?.id !== chainId) {
            throw new ChainIdMismatchError("Provided chain id should match the public client chain id");
        }
        this.chainId = chainId;
        this._publicClient = publicClient;
    }
    /**
     * Get a hat's properties.
     *
     * @param hatId - The hat ID.
     * @returns An object containing the hat's properties.
     */
    async viewHat(hatId) {
        const result = await this._publicClient.readContract({
            address: HATS_V1,
            abi: HATS_ABI,
            functionName: "viewHat",
            args: [BigInt(hatId)],
        });
        return {
            details: result[0],
            maxSupply: result[1],
            supply: result[2],
            eligibility: result[3],
            toggle: result[4],
            imageUri: result[5],
            numChildren: result[6],
            mutable: result[7],
            active: result[8],
        };
    }
    /**
     * Check if an address is a wearer of a specific hat.
     *
     * @param wearer - Address to check.
     * @param hatId - The hat ID.
     * @returns True if the address weares the hat, false otherwise.
     */
    async isWearerOfHat({ wearer, hatId, }) {
        const res = await this._publicClient.readContract({
            address: HATS_V1,
            abi: HATS_ABI,
            functionName: "isWearerOfHat",
            args: [wearer, hatId],
        });
        return res;
    }
    /**
     * Check if an address is an admin of a specific hat.
     *
     * @param user - The address to check.
     * @param hatId - The hat ID.
     * @returns True is the address is an admin of the hat, false otherwise.
     */
    async isAdminOfHat({ user, hatId, }) {
        const res = await this._publicClient.readContract({
            address: HATS_V1,
            abi: HATS_ABI,
            functionName: "isAdminOfHat",
            args: [user, hatId],
        });
        return res;
    }
    /**
     * Check if a hat is active.
     *
     * @param hatId - The hat ID.
     * @returns True if active, false otherwise.
     */
    async isActive(hatId) {
        const res = await this._publicClient.readContract({
            address: HATS_V1,
            abi: HATS_ABI,
            functionName: "isActive",
            args: [hatId],
        });
        return res;
    }
    /**
     * Check if a wearer is in good standing.
     *
     * @param wearer - The address of the wearer.
     * @param hatID - The hat ID.
     * @returns True if the wearer is in good standing, false otherwise.
     */
    async isInGoodStanding({ wearer, hatId, }) {
        const res = await this._publicClient.readContract({
            address: HATS_V1,
            abi: HATS_ABI,
            functionName: "isInGoodStanding",
            args: [wearer, hatId],
        });
        return res;
    }
    /**
     * Check if an address is eligible for a specific hat.
     *
     * @param wearer - The Address to check.
     * @param hatId - THe hat ID.
     * @returns True if eligible, false otherwise.
     */
    async isEligible({ wearer, hatId, }) {
        const res = await this._publicClient.readContract({
            address: HATS_V1,
            abi: HATS_ABI,
            functionName: "isEligible",
            args: [wearer, hatId],
        });
        return res;
    }
    async predictNextChildrenHatIDs({ admin, numChildren, }) {
        const res = [];
        if (numChildren < 1) {
            return res;
        }
        const adminHat = await this.viewHat(admin);
        if (adminHat.numChildren + numChildren > MAX_LEVEL_HATS) {
            throw new MaxHatsInLevelReached("Maximum amount of hats per level is 65535");
        }
        const level = await this.getLocalHatLevel(admin);
        if (level === MAX_LEVELS) {
            throw new MaxLevelReachedError("The provided admin's hat level is on the maximal level");
        }
        const contractDetails = {
            address: HATS_V1,
            abi: HATS_ABI,
        };
        const calls = [];
        for (let i = 0; i < numChildren; i++) {
            calls.push({
                ...contractDetails,
                functionName: "buildHatId",
                args: [admin, adminHat.numChildren + i + 1],
            });
        }
        const childHats = await this._publicClient.multicall({
            contracts: calls,
        });
        childHats.forEach((hat) => {
            if (hat.result !== undefined) {
                res.push(hat.result);
            }
        });
        return res;
    }
    /**
     * Get the number of trees.
     *
     * @returns The number of already created trees.
     */
    async getTreesCount() {
        const res = await this._publicClient.readContract({
            address: HATS_V1,
            abi: HATS_ABI,
            functionName: "lastTopHatId",
        });
        return res;
    }
    /**
     * Get the linkage request of a tree.
     *
     * @param topHatDomain - The tree domain. The tree domain is the first four bytes of the tophat ID.
     * @returns If request exists, returns the requested new admin hat ID. If not, returns zero.
     */
    async getLinkageRequest(topHatDomain) {
        const res = await this._publicClient.readContract({
            address: HATS_V1,
            abi: HATS_ABI,
            functionName: "linkedTreeRequests",
            args: [topHatDomain],
        });
        return res;
    }
    /**
     * Get the admin of a linked tree.
     *
     * @param topHatDomain - The tree domain. The tree domain is the first four bytes of the tophat ID.
     * @returns If tree is linked, returns the admin hat ID of the linked tree. If not, returns zero.
     */
    async getLinkedTreeAdmin(topHatDomain) {
        const res = await this._publicClient.readContract({
            address: HATS_V1,
            abi: HATS_ABI,
            functionName: "linkedTreeAdmins",
            args: [topHatDomain],
        });
        return res;
    }
    /**
     * Get a hat's level. If the tree is linked, level is calulated in the global tree (formed of all linked trees).
     * @param hatId - The hat ID.
     * @returns The hat's level in the global tree.
     */
    async getHatLevel(hatId) {
        const res = await this._publicClient.readContract({
            address: HATS_V1,
            abi: HATS_ABI,
            functionName: "getHatLevel",
            args: [hatId],
        });
        return res;
    }
    /**
     * Get a hat's level in its local tree (without considering linked trees).
     * @param hatId - The hat ID.
     * @returns The hat's local level.
     */
    async getLocalHatLevel(hatId) {
        const res = await this._publicClient.readContract({
            address: HATS_V1,
            abi: HATS_ABI,
            functionName: "getLocalHatLevel",
            args: [hatId],
        });
        return res;
    }
    /**
     * Get a hat's tree domain.
     *
     * @param hatId - The hat ID.
     * @returns The tree domain of the hat. The tree domain is the first four bytes of the tophat ID.
     */
    async getTopHatDomain(hatId) {
        const res = await this._publicClient.readContract({
            address: HATS_V1,
            abi: HATS_ABI,
            functionName: "getTopHatDomain",
            args: [hatId],
        });
        return res;
    }
    /**
     * Get the tree domain of the global's tree tophat (tippy top hat), which the provided tree is included in.
     *
     * @param topHatDomain The tree domain. The tree domain is the first four bytes of the tophat ID.
     * @returns The tree domain of the tippy top hat.
     */
    async getTippyTopHatDomain(topHatDomain) {
        const res = await this._publicClient.readContract({
            address: HATS_V1,
            abi: HATS_ABI,
            functionName: "getTippyTopHatDomain",
            args: [topHatDomain],
        });
        return res;
    }
    /**
     * Get the direct admin of a hat (its parent).
     * @param hatId- The hat ID.
     * @returns The admin's hat ID. If the provided hat is an unlinked tophat, then this top hat is returned, as it is
     * the admin of itself.
     */
    async getAdmin(hatId) {
        const hatLevel = await this.getHatLevel(hatId);
        if (hatLevel === 0) {
            return hatId;
        }
        const res = await this._publicClient.readContract({
            address: HATS_V1,
            abi: HATS_ABI,
            functionName: "getAdminAtLevel",
            args: [hatId, hatLevel - 1],
        });
        return res;
    }
    /**
     * Get the children hats of a hat.
     *
     * @param hatId - The hat ID.
     * @returns An array of all children hats IDs.
     */
    async getChildrenHats(hatId) {
        const res = [];
        const hat = await this.viewHat(hatId);
        if (hat.numChildren === 0) {
            return res;
        }
        for (let i = 0; i < hat.numChildren; i++) {
            const childHatId = await this._publicClient.readContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "buildHatId",
                args: [hatId, i + 1],
            });
            res.push(childHatId);
        }
        return res;
    }
}

function hatIdDecimalToHex(hatId) {
    return ("0x" + BigInt(hatId).toString(16).padStart(64, "0"));
}
function treeIdDecimalToHex(treeId) {
    return ("0x" + treeId.toString(16).padStart(8, "0"));
}
function hatIdHexToDecimal(hatId) {
    return BigInt(hatId);
}
function treeIdHexToDecimal(treeId) {
    return parseInt(treeId, 16);
}
function hatIdDecimalToIp(hatId) {
    const hexId = hatIdDecimalToHex(hatId);
    let ip = treeIdHexToDecimal(hexId.substring(0, 10)).toString();
    for (let i = 10; i < hexId.length; i += 4) {
        const domainAtLevel = hexId.substring(i, i + 4);
        if (domainAtLevel === "0000") {
            break;
        }
        ip += "." + parseInt(domainAtLevel, 16);
    }
    return ip;
}
function hatIdIpToDecimal(hatId) {
    const domains = hatId.split(".");
    let hatIdHex = parseInt(domains[0]).toString(16).padStart(8, "0");
    for (let i = 1; i < domains.length; i++) {
        hatIdHex = hatIdHex + parseInt(domains[i]).toString(16).padStart(4, "0");
    }
    hatIdHex = "0x" + hatIdHex.padEnd(64, "0");
    return BigInt(hatIdHex);
}
function treeIdToTopHatId(treeId) {
    return BigInt(treeIdDecimalToHex(treeId).padEnd(66, "0"));
}
function hatIdToTreeId(hatId) {
    return parseInt("0x" + BigInt(hatId).toString(16).padStart(64, "0").substring(0, 8), 16);
}

class HatsCallDataClient extends HatsReadClient {
    /**
     * Initialize a HatsClient.
     *
     * @param chainId - Client chain ID. The client is initialized to work with one specific chain.
     * @param publicClient - Viem Public Client
     * @returns A HatsCallDataClient instance.
     *
     * @throws MissingPublicClientError
     * Thrown when a public client is not provided.
     *
     * @throws ChainIdMismatchError
     * Thrown when there is a chain ID mismatch between one of the Viem clients and/or the provided chain ID.
     */
    constructor({ chainId, publicClient, }) {
        super({ chainId, publicClient });
        this._graphqlClient = new sdkV1Subgraph.HatsSubgraphClient({});
    }
    /**
     * Return the call data a multicall operation.
     *
     * @param calls - An array with the call data strings, for each function call.
     * @returns An object containing the call data and the function name.
     */
    multicallCallData(calls) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "multicall",
            args: [calls],
        });
        return { functionName: "multicall", callData };
    }
    /**
     * Return the call data for a mintTopHat operation.
     *
     * @param target - Tophat's wearer address.
     * @param details - Tophat's details field.
     * @param imageURIi - Optional tophat's image URI.
     * @returns An object containing the call data and the function name.
     */
    mintTopHatCallData({ target, details, imageURI, }) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "mintTopHat",
            args: [target, details, imageURI === undefined ? "" : imageURI],
        });
        return { functionName: "mintTopHat", callData };
    }
    /**
     * Return the call data for a createHat operation.
     *
     * @param admin - Hat's admin ID.
     * @param details - Hat's details field.
     * @param maxSupply - Hat's maximum amount of possible wearers.
     * @param eligibility - Hat's eligibility address (zero address is not valid).
     * @param toggle - Hat's toggle address (zero address is not valid).
     * @param mutable - True if the hat should be mutable, false otherwise.
     * @param imageURI - Optional hat's image URI.
     * @returns An object containing the call data and the function name.
     */
    createHatCallData({ admin, details, maxSupply, eligibility, toggle, mutable, imageURI, }) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "createHat",
            args: [
                admin,
                details,
                maxSupply,
                eligibility,
                toggle,
                mutable,
                imageURI === undefined ? "" : imageURI,
            ],
        });
        return { functionName: "createHat", callData };
    }
    /**
     * Return the call data for a transferHat operation.
     *
     * @param hatId - Hat ID to be transfered.
     * @param from - Current wearer address.
     * @param to - New wearer address.
     * @returns An object containing the call data and the function name.
     */
    transferHatCallData({ hatId, from, to, }) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "transferHat",
            args: [hatId, from, to],
        });
        return { functionName: "transferHat", callData };
    }
    /**
     * Return the call data for a mintHat operation.
     *
     * @param hatId - ID of the minted hat.
     * @param wearer - Address of the new wearer.
     * @returns An object containing the call data and the function name.
     */
    mintHatCallData({ hatId, wearer }) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "mintHat",
            args: [hatId, wearer],
        });
        return { functionName: "mintHat", callData };
    }
    /**
     * Return the call data for a batchCreateHats operation.
     *
     * @param admins - The hats admin IDs.
     * @param details - The hats details fields.
     * @param maxSupplies - The hats maximum amounts of possible wearers.
     * @param eligibilityModules - The hats eligibility addresses (zero address is not valid).
     * @param toggleModules - The hats toggle addresses (zero address is not valid).
     * @param mutables - True if the hat should be mutable, false otherwise.
     * @param imageURIs - Optional hats image URIs.
     * @returns An object containing the call data and the function name.
     */
    batchCreateHatsCallData({ admins, details, maxSupplies, eligibilityModules, toggleModules, mutables, imageURIs, }) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "batchCreateHats",
            args: [
                admins,
                details,
                maxSupplies,
                eligibilityModules,
                toggleModules,
                mutables,
                imageURIs === undefined ? Array(admins.length).fill("") : imageURIs,
            ],
        });
        return { functionName: "batchCreateHats", callData };
    }
    /**
     * Return the call data for a batchMintHats operation.
     *
     * @param hatIds - IDs of the minted hats.
     * @param wearers - Addresses of the new wearers.
     * @returns An object containing the call data and the function name.
     */
    batchMintHatsCallData({ hatIds, wearers, }) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "batchMintHats",
            args: [hatIds, wearers],
        });
        return { functionName: "batchMintHats", callData };
    }
    /**
     * Return the call data for a setHatStatus operation.
     *
     * @param hatId - hat ID.
     * @param newStatus - Hat's new status: true for active, false for inactive.
     * @returns An object containing the call data and the function name.
     */
    setHatStatusCallData({ hatId, newStatus, }) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "setHatStatus",
            args: [hatId, newStatus],
        });
        return { functionName: "setHatStatus", callData };
    }
    checkHatStatusCallData({ hatId }) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "checkHatStatus",
            args: [hatId],
        });
        return { functionName: "checkHatStatus", callData };
    }
    /**
     * Return the call data for a setHatWearerStatus operation.
     *
     * @param hatId - Hat ID.
     * @param wearer - Wearer address.
     * @param eligible - Wearer's eligibility. True for eligible, false otherwise.
     * @param standing - Wearer's standing. True for good, false for bad.
     * @returns An object containing the call data and the function name.
     */
    setHatWearerStatusCallData({ hatId, wearer, eligible, standing, }) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "setHatWearerStatus",
            args: [hatId, wearer, eligible, standing],
        });
        return { functionName: "setHatWearerStatus", callData };
    }
    /**
     * Return the call data for a checkHatWearerStatus operation.
     *
     * @param hatId - Hat ID.
     * @param wearer - Wearer address.
     * @returns An object containing the call data and the function name.
     */
    checkHatWearerStatusCallData({ hatId, wearer, }) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "checkHatWearerStatus",
            args: [hatId, wearer],
        });
        return { functionName: "checkHatWearerStatus", callData };
    }
    /**
     * Return the call data for a renounceHat operation.
     *
     * @param hatId - Hat ID of the hat the caller wishes to renounce.
     * @returns An object containing the call data and the function name.
     */
    renounceHatCallData({ hatId }) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "renounceHat",
            args: [hatId],
        });
        return { functionName: "renounceHat", callData };
    }
    /**
     * Return the call data for a makeHatImmutable operation.
     *
     * @param hatId - Hat ID.
     * @returns An object containing the call data and the function name.
     */
    makeHatImmutableCallData({ hatId }) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "makeHatImmutable",
            args: [hatId],
        });
        return { functionName: "makeHatImmutable", callData };
    }
    /**
     * Return the call data for a changeHatDetails operation.
     *
     * @param hatId - Hat ID.
     * @param newDetails - The new details.
     * @returns An object containing the call data and the function name.
     */
    changeHatDetailsCallData({ hatId, newDetails, }) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "changeHatDetails",
            args: [hatId, newDetails],
        });
        return { functionName: "changeHatDetails", callData };
    }
    /**
     * Return the call data for a changeHatEligibility operation.
     *
     * @param hatId - Hat ID.
     * @param newEligibility - The new eligibility address. Zero address is not valid.
     * @returns An object containing the call data and the function name.
     */
    changeHatEligibilityCallData({ hatId, newEligibility, }) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "changeHatEligibility",
            args: [hatId, newEligibility],
        });
        return { functionName: "changeHatEligibility", callData };
    }
    /**
     * Return the call data for a changeHatToggle operation.
     *
     * @param hatId - Hat ID.
     * @param newToggle - The new toggle address. Zero address is not valid.
     * @returns An object containing the call data and the function name.
     */
    changeHatToggleCallData({ hatId, newToggle, }) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "changeHatToggle",
            args: [hatId, newToggle],
        });
        return { functionName: "changeHatToggle", callData };
    }
    /**
     * Return the call data for a changeHatImageURI operation.
     *
     * @param hatId - Hat ID.
     * @param newImageURI - The new image URI.
     * @returns An object containing the call data and the function name.
     */
    changeHatImageURICallData({ hatId, newImageURI, }) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "changeHatImageURI",
            args: [hatId, newImageURI],
        });
        return { functionName: "changeHatImageURI", callData };
    }
    /**
     * Return the call data for a changeHatMaxSupply operation.
     *
     * @param hatId - Hat ID.
     * @param newMaxSupply -New maximum supply for the hat.
     * @returns An object containing the call data and the function name.
     */
    changeHatMaxSupplyCallData({ hatId, newMaxSupply, }) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "changeHatMaxSupply",
            args: [hatId, newMaxSupply],
        });
        return { functionName: "changeHatMaxSupply", callData };
    }
    /**
     * Return the call data for a requestLinkTopHatToTree operation.
     *
     * @param topHatDomain - The tree domain of the requesting tree. The tree domain is the first four bytes of the tophat ID.
     * @param requestedAdminHat - ID of the requested new admin hat.
     * @returns An object containing the call data and the function name.
     */
    requestLinkTopHatToTreeCallData({ topHatDomain, requestedAdminHat, }) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "requestLinkTopHatToTree",
            args: [topHatDomain, requestedAdminHat],
        });
        return { functionName: "requestLinkTopHatToTree", callData };
    }
    /**
     * Return the call data for a approveLinkTopHatToTree operation.
     *
     * @param topHatDomain - The tree domain of the requesting tree. The tree domain is the first four bytes of the tophat ID.
     * @param newAdminHat - ID of the new admin hat.
     * @param newEligibility - Optional new eligibility for the linked tophat.
     * @param newToggle - Optional new toggle for the linked tophat.
     * @param newDetails - Optional new details for the linked tophat.
     * @param newImageURI - Optional new image URI for the linked tophat.
     * @returns An object containing the call data and the function name.
     */
    approveLinkTopHatToTreeCallData({ topHatDomain, newAdminHat, newEligibility, newToggle, newDetails, newImageURI, }) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "approveLinkTopHatToTree",
            args: [
                topHatDomain,
                newAdminHat,
                newEligibility === undefined ? ZERO_ADDRESS : newEligibility,
                newToggle === undefined ? ZERO_ADDRESS : newToggle,
                newDetails === undefined ? "" : newDetails,
                newImageURI === undefined ? "" : newImageURI,
            ],
        });
        return { functionName: "approveLinkTopHatToTree", callData };
    }
    /**
     * Return the call data for a unlinkTopHatFromTree operation.
     *
     * @param topHatDomain - The tree domain of the requesting tree. The tree domain is the first four bytes of the tophat ID.
     * @param wearer - The current wearer of the tophat that is about to be unlinked.
     * @returns An object containing the call data and the function name.
     */
    unlinkTopHatFromTreeCallData({ topHatDomain, wearer, }) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "unlinkTopHatFromTree",
            args: [topHatDomain, wearer],
        });
        return { functionName: "unlinkTopHatFromTree", callData };
    }
    /**
     * Return the call data for a relinkTopHatWithinTree operation.
     *
     * @param topHatDomain - The tree domain of the requesting tree. The tree domain is the first four bytes of the tophat ID.
     * @param newAdminHat - ID of the new admin hat.
     * @param newEligibility - Optional new eligibility for the linked tophat.
     * @param newToggle - Optional new toggle for the linked tophat.
     * @param newDetails - Optional new details for the linked tophat.
     * @param newImageURI - Optional new image URI for the linked tophat.
     * @returns An object containing the call data and the function name.
     */
    relinkTopHatWithinTreeCallData({ topHatDomain, newAdminHat, newEligibility, newToggle, newDetails, newImageURI, }) {
        const callData = viem.encodeFunctionData({
            abi: HATS_ABI,
            functionName: "relinkTopHatWithinTree",
            args: [
                topHatDomain,
                newAdminHat,
                newEligibility === undefined ? ZERO_ADDRESS : newEligibility,
                newToggle === undefined ? ZERO_ADDRESS : newToggle,
                newDetails === undefined ? "" : newDetails,
                newImageURI === undefined ? "" : newImageURI,
            ],
        });
        return { functionName: "relinkTopHatWithinTree", callData };
    }
    /**
     * Get the call data to copy a tree's hats and wearers.
     * Note: this doensn't include the target's top-hat. The target top-hat should be created separately.
     *
     * @param sourceTree - The source tree domain.
     * @param targetTree - The target tree domain.
     * @returns An array of call data objects. Passing the result to the multicall function will execute the copy operation.
     */
    async copyTreeCallData({ sourceTree, targetTree, }) {
        if (this._graphqlClient === undefined) {
            throw new Error("Subgraph client was not initialized");
        }
        const res = [];
        const tree = await this._graphqlClient.getTree({
            chainId: this.chainId,
            treeId: sourceTree,
            props: {
                hats: {
                    props: {
                        details: true,
                        maxSupply: true,
                        imageUri: true,
                        currentSupply: true,
                        levelAtLocalTree: true,
                        eligibility: true,
                        toggle: true,
                        mutable: true,
                        createdAt: true,
                        wearers: { props: {} },
                        admin: {},
                    },
                },
                childOfTree: {},
                linkedToHat: {},
                parentOfTrees: { props: {} },
            },
        });
        const targetTreeHex = treeIdDecimalToHex(targetTree);
        tree.hats?.forEach((hat, index) => {
            if (index !== 0 && hat.createdAt !== null) {
                const adminID = hatIdHexToDecimal(targetTreeHex + hat.admin?.id.substring(10));
                const createHatCall = this.createHatCallData({
                    admin: adminID,
                    details: hat.details,
                    maxSupply: +hat.maxSupply,
                    eligibility: hat.eligibility,
                    toggle: hat.toggle,
                    mutable: hat.mutable,
                    imageURI: hat.imageUri,
                });
                res.push({
                    functionName: "createHat",
                    callData: createHatCall.callData,
                });
                hat.wearers?.forEach((wearer) => {
                    const mintHatCall = this.mintHatCallData({
                        hatId: hatIdHexToDecimal(targetTreeHex + hat.id.substring(10)),
                        wearer: wearer.id,
                    });
                    res.push({ functionName: "mintHat", callData: mintHatCall.callData });
                });
            }
        });
        return res;
    }
}

class HatsClient extends HatsCallDataClient {
    /**
     * Initialize a HatsClient.
     *
     * @param chainId - Client chain ID. The client is initialized to work with one specific chain.
     * @param publicClient - Viem Public Client
     * @param walletClient - Optional Viem Wallet Client. If not provided, then only read operations will be possible.
     * @returns A HatsClient instance.
     *
     * @throws MissingPublicClientError
     * Thrown when a public client is not provided.
     *
     * @throws ChainIdMismatchError
     * Thrown when there is a chain ID mismatch between one of the Viem clients and/or the provided chain ID.
     */
    constructor({ chainId, publicClient, walletClient, }) {
        super({ chainId, publicClient });
        if (publicClient === undefined) {
            throw new MissingPublicClientError("Public client is required");
        }
        if (publicClient.chain?.id !== chainId) {
            throw new ChainIdMismatchError("Provided chain id should match the public client chain id");
        }
        if (walletClient !== undefined && walletClient.chain?.id !== chainId) {
            throw new ChainIdMismatchError("Provided chain id should match the wallet client chain id");
        }
        this._walletClient = walletClient;
    }
    /**
     * Create a new tophat (new tree).
     *
     * @param account - A Viem account.
     * @param target - Tophat's wearer address.
     * @param details - Tophat's details field.
     * @param imageURI - Optional tophat's image URI.
     * @returns An object containing the status of the call, the transactions hash and the created tophat ID.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     */
    async mintTopHat({ account, target, details, imageURI, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        const hash = await this._walletClient.writeContract({
            address: HATS_V1,
            abi: HATS_ABI,
            functionName: "mintTopHat",
            args: [target, details, imageURI === undefined ? "" : imageURI],
            account,
            chain: this._walletClient.chain,
        });
        const receipt = await this._publicClient.waitForTransactionReceipt({
            hash,
        });
        const event = viem.decodeEventLog({
            abi: HATS_ABI,
            eventName: "HatCreated",
            data: receipt.logs[0].data,
            topics: receipt.logs[0].topics,
        });
        return {
            status: receipt.status,
            transactionHash: receipt.transactionHash,
            hatId: event.args.id,
        };
    }
    /**
     * Create a hat.
     *
     * @param account - A Viem account.
     * @param admin - Hat's admin ID.
     * @param details - Hat's details field.
     * @param maxSupply - Hat's maximum amount of wearers.
     * @param eligibility - Hat's eligibility address (zero address is not valid).
     * @param toggle - Hat's toggle address (zero address is not valid).
     * @param mutable - True if the hat should be mutable, false otherwise.
     * @param imageURI - Optional hat's image URI.
     * @returns An object containing the status of the call, the transaction hash and the created hat ID.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     *
     * @throws ZeroAddressError
     * Thrown if provided the zero address as an eligibility or toggle.
     *
     * @throws InvalidAdminError
     * Thrown if the provided admin ID is not valid.
     *
     * @throws NotAdminError
     * Thrown if the calling account is not an admin of the hat that will be created.
     */
    async createHat({ account, admin, details, maxSupply, eligibility, toggle, mutable, imageURI, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "createHat",
                args: [
                    BigInt(admin),
                    details,
                    maxSupply,
                    eligibility,
                    toggle,
                    mutable,
                    imageURI === undefined ? "" : imageURI,
                ],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            const event = viem.decodeEventLog({
                abi: HATS_ABI,
                eventName: "HatCreated",
                data: receipt.logs[0].data,
                topics: receipt.logs[0].topics,
            });
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
                hatId: event.args.id,
            };
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Create multiple hats.
     *
     * @param account - A Viem account.
     * @param admins - The hats admin IDs.
     * @param details - The hats details fields.
     * @param maxSupplies - The hats maximum amounts of wearers.
     * @param eligibilityModules - The hats eligibility addresses (zero address is not valid).
     * @param toggleModules - The hats toggle addresses (zero address is not valid).
     * @param mutables - True if the hat should be mutable, false otherwise.
     * @param imageURIs - Optional hats image URIs.
     * @returns An object containing the status of the call, the transaction hash and the created hat IDs.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     *
     * @throws ZeroAddressError
     * Thrown if provided the zero address as an eligibility or toggle.
     *
     * @throws InvalidAdminError
     * Thrown if the provided admin ID is not valid.
     *
     * @throws NotAdminError
     * Thrown if the calling account is not an admin of the hat that will be created.
     *
     * @throws BatchParamsError
     * Thrown if there is a length mismatch between the provided hats properties.
     */
    async batchCreateHats({ account, admins, details, maxSupplies, eligibilityModules, toggleModules, mutables, imageURIs, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "batchCreateHats",
                args: [
                    admins,
                    details,
                    maxSupplies,
                    eligibilityModules,
                    toggleModules,
                    mutables,
                    imageURIs === undefined ? Array(admins.length).fill("") : imageURIs,
                ],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            const newHatIds = [];
            for (let i = 0; i < admins.length; i++) {
                const event = viem.decodeEventLog({
                    abi: HATS_ABI,
                    eventName: "HatCreated",
                    data: receipt.logs[i].data,
                    topics: receipt.logs[i].topics,
                });
                newHatIds.push(event.args.id);
            }
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
                hatIds: newHatIds,
            };
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Mint a hat.
     *
     * @param account - A Viem account.
     * @param hatId - ID of the minted hat.
     * @param wearer - Address of the new wearer.
     * @returns An object containing the status of the call and the transaction hash.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     *
     * @throws NotAdminError
     * Thrown if the calling account is not an admin of hat.
     *
     * @throws HatNotExistError
     * Thrown if the hat does not exist.
     *
     * @throws AllHatsWornError
     * Thrown if all the hats of the provided hat ID are currently worn.
     *
     * @throws NotEligibleError
     * Thrown if the new wearer is not eligible for the hat.
     *
     * @throws NotActiveError
     * Thrown if the hat is not active.
     *
     * @throws AlreadyWearingError
     * Thrown if the new wearer is already wearing the hat.
     *
     */
    async mintHat({ account, hatId, wearer, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "mintHat",
                args: [hatId, wearer],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
            };
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Mint multiple hats.
     *
     * @param account - A Viem account.
     * @param hatIds - IDs of the minted hats.
     * @param wearers - Addresses of the new wearers.
     * @returns An object containing the status of the call and the transaction hash.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     *
     * @throws NotAdminError
     * Thrown if the calling account is not an admin of hat.
     *
     * @throws HatNotExistError
     * Thrown if the hat does not exist.
     *
     * @throws AllHatsWornError
     * Thrown if all the hats of the provided hat ID are currently worn.
     *
     * @throws NotEligibleError
     * Thrown if the new wearer is not eligible for the hat.
     *
     * @throws NotActiveError
     * Thrown if the hat is not active.
     *
     * @throws AlreadyWearingError
     * Thrown if the new wearer is already wearing the hat.
     *
     * @throws BatchParamsError
     * Thrown if there is a length mismatch between the provided properties.
     */
    async batchMintHats({ account, hatIds, wearers, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "batchMintHats",
                args: [hatIds, wearers],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
            };
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Set a hat's status to active/inactive.
     *
     * @param account - A Viem account.
     * @param hatId - hat ID.
     * @param newStatus - Hat's new status: true for active, false for inactive.
     * @returns An object containing the status of the call and the transaction hash.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     *
     * @throws NotToggleError
     * Thrown if the calling account is not the toggle of the hat.
     */
    async setHatStatus({ account, hatId, newStatus, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "setHatStatus",
                args: [hatId, newStatus],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
            };
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Check a hat's status by calling its toggle module, and updating the status as needed.
     *
     * @param account - A Viem account.
     * @param hatId - Hat Id.
     * @returns An object containing the status of the call, the transaction hash, an indicator whether the status was
     * toggled and the new status in case the status was toggled.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     */
    async checkHatStatus({ account, hatId, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "checkHatStatus",
                args: [hatId],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            if (receipt.logs.length === 0) {
                return {
                    status: receipt.status,
                    transactionHash: receipt.transactionHash,
                    toggled: false,
                };
            }
            else {
                const event = viem.decodeEventLog({
                    abi: HATS_ABI,
                    eventName: "HatStatusChanged",
                    data: receipt.logs[0].data,
                    topics: receipt.logs[0].topics,
                });
                return {
                    status: receipt.status,
                    transactionHash: receipt.transactionHash,
                    toggled: true,
                    newStatus: event.args.newStatus ? "active" : "inactive",
                };
            }
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Set a hat's wearer status.
     *
     * @param account - A Viem account.
     * @param hatId - Hat ID.
     * @param wearer - Wearer address.
     * @param eligible - Wearer's eligibility. True for eligible, false otherwise.
     * @param standing - Wearer's standing. True for good, false for bad.
     * @returns An object containing the status of the call and the transaction hash
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     *
     * @throws NotEligibilityError
     * Thrown if the calling account is not the eligibility of the hat.
     */
    async setHatWearerStatus({ account, hatId, wearer, eligible, standing, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "setHatWearerStatus",
                args: [hatId, wearer, eligible, standing],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
            };
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Check a hat's wearer status by calling the hat's eligibilty module.
     * If the wearer is in non eligible and/or in bad standing, then its hat is burned.
     *
     * @param account - A Viem account.
     * @param hatId - Hat ID.
     * @param wearer - Wearer address.
     * @returns An object containing the status of the call, the transaction hash, indicator whether the wearer's standing
     * was updated, indicator whether the wearer's hat was burned and if standing has changed then the new standing.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     */
    async checkHatWearerStatus({ account, hatId, wearer, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "checkHatWearerStatus",
                args: [hatId, wearer],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            if (receipt.logs.length === 0) {
                return {
                    status: receipt.status,
                    transactionHash: receipt.transactionHash,
                    wearerStandingUpdated: false,
                    hatBurned: false,
                };
            }
            else if (receipt.logs.length === 1) {
                const burnEventTopic = viem.encodeEventTopics({
                    abi: HATS_ABI,
                    eventName: "TransferSingle",
                });
                const wearerStandingChangedTopic = viem.encodeEventTopics({
                    abi: HATS_ABI,
                    eventName: "WearerStandingChanged",
                });
                if (receipt.logs[0].topics[0] === burnEventTopic[0]) {
                    return {
                        status: receipt.status,
                        transactionHash: receipt.transactionHash,
                        wearerStandingUpdated: false,
                        hatBurned: true,
                    };
                }
                else if (receipt.logs[0].topics[0] === wearerStandingChangedTopic[0]) {
                    const event = viem.decodeEventLog({
                        abi: HATS_ABI,
                        eventName: "WearerStandingChanged",
                        data: receipt.logs[0].data,
                        topics: receipt.logs[0].topics,
                    });
                    return {
                        status: receipt.status,
                        transactionHash: receipt.transactionHash,
                        wearerStandingUpdated: true,
                        hatBurned: false,
                        newWearerStanding: event.args.wearerStanding ? "good" : "bad",
                    };
                }
                else {
                    throw new Error("Unexpected error");
                }
            }
            else {
                const wearerStandingChangedEvent = viem.decodeEventLog({
                    abi: HATS_ABI,
                    eventName: "WearerStandingChanged",
                    data: receipt.logs[1].data,
                    topics: receipt.logs[1].topics,
                });
                return {
                    status: receipt.status,
                    transactionHash: receipt.transactionHash,
                    wearerStandingUpdated: true,
                    hatBurned: true,
                    newWearerStanding: wearerStandingChangedEvent.args.wearerStanding
                        ? "good"
                        : "bad",
                };
            }
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Renounce a hat. This action burns the hat for the renouncing wearer.
     *
     * @param account - A Viem account.
     * @param hatId - Hat ID of the hat the caller wishes to renounce.
     * @returns An object containing the status of the call and the transaction hash.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     */
    async renounceHat({ account, hatId, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "renounceHat",
                args: [hatId],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
            };
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Transfer a hat from one wearer to another.
     *
     * @param account - A Viem account.
     * @param hatId - Hat ID to be transfered.
     * @param from - Current wearer address.
     * @param to - New wearer address.
     * @returns An object containing the status of the call and the transaction hash.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     *
     * @throws ImmutableHatError
     * Thrown if the hat is immutable. Immutable hats cannot be transfered.
     *
     * @throws NotAdminError
     * Thrown if the calling account is not an admin of the hat.
     *
     * @throws NotEligibleError
     * Thrown if the new wearer is not eligible for the hat.
     *
     * @throws NotActiveError
     * Thrown if the hat is not active.
     *
     * @throws NotWearerError
     * Thrown if the provided current wearer is not wearing the hat.
     *
     * @throws AlreadyWearingError
     * Thrown if the new wearer is already wearing the hat.
     */
    async transferHat({ account, hatId, from, to, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "transferHat",
                args: [hatId, from, to],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
            };
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Make a hat immutable.
     *
     * @param account - A Viem account.
     * @param hatId - Hat ID.
     * @returns An object containing the status of the call and the transaction hash.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     *
     * @throws NotAdminError
     * Thrown if the calling account is not an admin of the hat.
     *
     * @throws ImmutableHatError
     * Thrown if the hat is immutable. Immutable hats cannot be edited.
     */
    async makeHatImmutable({ account, hatId, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "makeHatImmutable",
                args: [hatId],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
            };
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Change a hat's details.
     *
     * @param account - A Viem account.
     * @param hatId - Hat ID.
     * @param newDetails - The new details.
     * @returns An object containing the status of the call and the transaction hash.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     *
     * @throws NotAdminError
     * Thrown if the calling account is not an admin of the hat.
     *
     * @throws ImmutableHatError
     * Thrown if the hat is immutable.
     *
     * @throws StringTooLongError
     * Thrown if the new details length is larger than 7000.
     */
    async changeHatDetails({ account, hatId, newDetails, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "changeHatDetails",
                args: [hatId, newDetails],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
            };
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Change a hat's eligibility.
     *
     * @param account - A Viem account.
     * @param hatId - Hat ID.
     * @param newEligibility - The new eligibility address. Zero address is not valid.
     * @returns An object containing the status of the call and the transaction hash.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     *
     * @throws NotAdminError
     * Thrown if the calling account is not an admin of the hat.
     *
     * @throws ImmutableHatError
     * Thrown if the hat is immutable.
     *
     * @throws ZeroAddressError
     * Thrown if the new eligibilty is the zero address.
     */
    async changeHatEligibility({ account, hatId, newEligibility, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "changeHatEligibility",
                args: [hatId, newEligibility],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
            };
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Change a hat's toggle.
     *
     * @param account - A Viem account.
     * @param hatId - Hat ID.
     * @param newToggle - The new toggle address. Zero address is not valid.
     * @returns An object containing the status of the call and the transaction hash.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     *
     * @throws NotAdminError
     * Thrown if the calling account is not an admin of the hat.
     *
     * @throws ImmutableHatError
     * Thrown if the hat is immutable.
     *
     * @throws ZeroAddressError
     * Thrown if the new toggle is the zero address.
     */
    async changeHatToggle({ account, hatId, newToggle, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "changeHatToggle",
                args: [hatId, newToggle],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
            };
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Change a hat's image URI.
     *
     * @param account - A Viem account.
     * @param hatId - Hat ID.
     * @param newImageURI - The new image URI.
     * @returns An object containing the status of the call and the transaction hash.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     *
     * @throws NotAdminError
     * Thrown if the calling account is not an admin of the hat.
     *
     * @throws ImmutableHatError
     * Thrown if the hat is immutable.
     *
     * @throws StringTooLongError
     * Thrown if the new image URI length is larger than 7000.
     */
    async changeHatImageURI({ account, hatId, newImageURI, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "changeHatImageURI",
                args: [hatId, newImageURI],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
            };
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Change a hat's max supply.
     *
     * @param account - A Viem account.
     * @param hatId - Hat ID.
     * @param newMaxSupply -New maximum supply for the hat.
     * @returns An object containing the status of the call and the transaction hash.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     *
     * @throws NotAdminError
     * Thrown if the calling account is not an admin of the hat.
     *
     * @throws ImmutableHatError
     * Thrown if the hat is immutable.
     *
     * @throws InvalidMaxSupplyError
     * Thrown if the new maximum supply is smaller the current amount of wearers.
     */
    async changeHatMaxSupply({ account, hatId, newMaxSupply, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "changeHatMaxSupply",
                args: [hatId, newMaxSupply],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
            };
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Request a link from a tophat to a new admin hat.
     *
     * @param account - A Viem account.
     * @param topHatDomain - The tree domain of the requesting tree. The tree domain is the first four bytes of the tophat ID.
     * @param requestedAdminHat - ID of the requested new admin hat.
     * @returns An object containing the status of the call and the transaction hash.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     *
     * @throws NotAdminError
     * Thrown if the calling account is not an admin of the tophat.
     */
    async requestLinkTopHatToTree({ account, topHatDomain, requestedAdminHat, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "requestLinkTopHatToTree",
                args: [topHatDomain, requestedAdminHat],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
            };
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Approve a tophat's linkage request.
     *
     * @param account - A Viem account.
     * @param topHatDomain - The tree domain of the requesting tree. The tree domain is the first four bytes of the tophat ID.
     * @param newAdminHat - ID of the new admin hat.
     * @param newEligibility - Optional new eligibility for the linked tophat.
     * @param newToggle - Optional new toggle for the linked tophat.
     * @param newDetails - Optional new details for the linked tophat.
     * @param newImageURI - Optional new image URI for the linked tophat.
     * @returns An object containing the status of the call and the transaction hash.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     *
     * @throws NoLinkageRequestError
     * Thrown if the tophat has not requested the link.
     *
     * @throws NotAdminOrWearerError
     * Thrown if the calling account is not an admin or a wearer of the new admin hat.
     *
     * @throws CircularLinkageError
     * Thrown if linking the trees creates a circular linkage.
     *
     * @throws CrossLinkageError
     * Thrown if the new admin hat is in a different global tree than the current global
     * tree of the tophat that is being linked or if the calling account has no permission
     * to relink to the new destination within the same global tree.
     *
     * @throws StringTooLongErrorError
     * Thrown if a new details or new image URI were provided and either length is greater
     * than 7000.
     */
    async approveLinkTopHatToTree({ account, topHatDomain, newAdminHat, newEligibility, newToggle, newDetails, newImageURI, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "approveLinkTopHatToTree",
                args: [
                    topHatDomain,
                    newAdminHat,
                    newEligibility === undefined ? ZERO_ADDRESS : newEligibility,
                    newToggle === undefined ? ZERO_ADDRESS : newToggle,
                    newDetails === undefined ? "" : newDetails,
                    newImageURI === undefined ? "" : newImageURI,
                ],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
            };
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Unlink a tree.
     *
     * @param account - A Viem account.
     * @param topHatDomain - The tree domain of the requesting tree. The tree domain is the first four bytes of the tophat ID.
     * @param wearer - The current wearer of the tophat that is about to be unlinked.
     * @returns An object containing the status of the call and the transaction hash.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     *
     * @throws NotWearerError
     * Thrown if provided wearer is not the wearer of the tophat.
     *
     * @throws NotAdminError
     * Thrown if the calling account is not an admin of the tophat.
     */
    async unlinkTopHatFromTree({ account, topHatDomain, wearer, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "unlinkTopHatFromTree",
                args: [topHatDomain, wearer],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
            };
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Relink a tree within the same global tree that it is already part of.
     *
     * @param account - A Viem account.
     * @param topHatDomain - The tree domain of the requesting tree. The tree domain is the first four bytes of the tophat ID.
     * @param newAdminHat - ID of the new admin hat.
     * @param newEligibility - Optional new eligibility for the linked tophat.
     * @param newToggle - Optional new toggle for the linked tophat.
     * @param newDetails - Optional new details for the linked tophat.
     * @param newImageURI - Optional new image URI for the linked tophat.
     * @returns An object containing the status of the call and the transaction hash.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     *
     * * @throws NotAdminError
     * Thrown if the calling account is not an admin of the tophat that is about to be relinked.
     *
     * @throws NotAdminOrWearerError
     * Thrown if the calling account is not an admin or a wearer of the new admin hat.
     *
     * @throws CircularLinkageError
     * Thrown if linking the trees creates a circular linkage.
     *
     * @throws CrossLinkageError
     * Thrown if the new admin hat is in a different global tree than the current global
     * tree of the tophat that is being linked or if the calling account has no permission
     * to relink to the new destination within the same global tree.
     *
     * * @throws StringTooLongErrorError
     * Thrown if a new details or new image URI were provided and either length is greater
     * than 7000.
     */
    async relinkTopHatWithinTree({ account, topHatDomain, newAdminHat, newEligibility, newToggle, newDetails, newImageURI, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "relinkTopHatWithinTree",
                args: [
                    topHatDomain,
                    newAdminHat,
                    newEligibility === undefined ? ZERO_ADDRESS : newEligibility,
                    newToggle === undefined ? ZERO_ADDRESS : newToggle,
                    newDetails === undefined ? "" : newDetails,
                    newImageURI === undefined ? "" : newImageURI,
                ],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
            };
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Batch multiple operations
     *
     * @param account - A Viem account.
     * @param calls - Array of call objects, containing the call data and the function name
     * @returns An object containing newly created, minted or burned hats and hat/wearer status changes as a result of the multicall
     *
     * @throws MultiCallError
     * Thrown if the multicall simulation reverted.
     */
    async multicall({ account, calls, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        try {
            const callDatas = calls.map((call) => call.callData);
            const { request } = await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "multicall",
                args: [callDatas],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            const hatsCreated = [];
            const hatsMinted = [];
            const hatsBurned = [];
            const hatStatusChanges = [];
            const wearerStandingChanges = [];
            for (let i = 0; i < receipt.logs.length; i++) {
                const log = receipt.logs[i];
                try {
                    const event = viem.decodeEventLog({
                        abi: HATS_ABI,
                        data: log.data,
                        topics: log.topics,
                    });
                    switch (event.eventName) {
                        case "HatCreated": {
                            hatsCreated.push(event.args.id);
                            break;
                        }
                        case "TransferSingle": {
                            if (event.args.to !== ZERO_ADDRESS) {
                                hatsMinted.push({
                                    hatId: event.args.id,
                                    wearer: event.args.to,
                                });
                            }
                            if (event.args.from !== ZERO_ADDRESS) {
                                hatsBurned.push({
                                    hatId: event.args.id,
                                    wearer: event.args.from,
                                });
                            }
                            break;
                        }
                        case "HatStatusChanged": {
                            hatStatusChanges.push({
                                hatId: event.args.hatId,
                                newStatus: event.args.newStatus ? "active" : "inactive",
                            });
                            break;
                        }
                        case "WearerStandingChanged": {
                            wearerStandingChanges.push({
                                hatId: event.args.hatId,
                                wearer: event.args.wearer,
                                newStanding: event.args.wearerStanding ? "good" : "bad",
                            });
                            break;
                        }
                    }
                }
                catch (err) {
                    console.log("Non Hats event encountered");
                    continue;
                }
            }
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
                gasUsed: receipt.gasUsed,
                hatsCreated,
                hatsMinted,
                hatsBurned,
                hatStatusChanges,
                wearerStandingChanges,
            };
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Check if a multicall operation will succeed with given calls. Reverts if not, otherwise returns without a return value.
     *
     * @param account - A Viem account.
     * @param calls - Array of call objects, containing the call data and the function name
     */
    async multicallPreFlightCheck({ account, calls, }) {
        const callDatas = calls.map((call) => call.callData);
        try {
            await this._publicClient.simulateContract({
                address: HATS_V1,
                abi: HATS_ABI,
                functionName: "multicall",
                args: [callDatas],
                account,
            });
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Check whether an account can claim a given hat.
     *
     * @param hatId - The hat ID to claim.
     * @param account - The claiming account's address.
     * @returns 'true' if can claim, 'false' otherwise.
     */
    async accountCanClaim({ hatId, account, }) {
        const hat = (await this._graphqlClient.getHat({
            chainId: this.chainId,
            hatId,
            props: {
                claimableBy: {
                    props: {},
                    filters: { first: 1 },
                },
            },
        }));
        if (hat.claimableBy.length == 0) {
            return false;
        }
        let claimsHatterToUse;
        for (let i = 0; i < hat.claimableBy.length; i++) {
            const claimsHatter = hat.claimableBy[i];
            const wearsAdmin = await this._publicClient.readContract({
                address: claimsHatter.id,
                abi: CLAIMS_HATTER_ABI,
                functionName: "wearsAdmin",
                args: [hatId],
            });
            if (wearsAdmin) {
                claimsHatterToUse = claimsHatter;
            }
        }
        if (claimsHatterToUse === undefined) {
            return false;
        }
        const canClaim = await this._publicClient.readContract({
            address: claimsHatterToUse.id,
            abi: CLAIMS_HATTER_ABI,
            functionName: "accountCanClaim",
            args: [account, hatId],
        });
        return canClaim;
    }
    /**
     * Check whether a hat can be claimed on behalf of a given account.
     *
     * @param hatId - The hat ID to claim-for.
     * @param account - The account address to claim on behalf of.
     * @returns 'true' if can claim-for, 'false' otherwise.
     */
    async canClaimForAccount({ hatId, account, }) {
        const hat = (await this._graphqlClient.getHat({
            chainId: this.chainId,
            hatId,
            props: {
                claimableForBy: {
                    props: {},
                    filters: { first: 1 },
                },
            },
        }));
        let claimsHatterToUse;
        for (let i = 0; i < hat.claimableForBy.length; i++) {
            const claimsHatter = hat.claimableForBy[i];
            const wearsAdmin = await this._publicClient.readContract({
                address: claimsHatter.id,
                abi: CLAIMS_HATTER_ABI,
                functionName: "wearsAdmin",
                args: [hatId],
            });
            if (wearsAdmin) {
                claimsHatterToUse = claimsHatter;
            }
        }
        if (claimsHatterToUse === undefined) {
            return false;
        }
        const canClaim = await this._publicClient.readContract({
            address: claimsHatterToUse.id,
            abi: CLAIMS_HATTER_ABI,
            functionName: "canClaimForAccount",
            args: [account, hatId],
        });
        return canClaim;
    }
    /**
     * Claim a hat for the calling account.
     *
     * @param account - A Viem account.
     * @param hatId - ID of the hat to claim.
     * @returns An object containing the status of the call and the transaction hash.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     *
     * @throws HatNotClaimableError
     * Thrown if the hat is not claimable.
     *
     * @throws NotExplicitlyEligibleError
     * Thrown if the wearer is not explicitly eligible for the hat.
     *
     * @throws NotAdminError
     * Thrown if there is no multi claims hatter instance that is the hat's admin.
     */
    async claimHat({ account, hatId, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        const hat = (await this._graphqlClient.getHat({
            chainId: this.chainId,
            hatId,
            props: {
                claimableBy: {
                    props: {},
                    filters: { first: 1 },
                },
            },
        }));
        if (hat.claimableBy.length == 0) {
            throw new HatNotClaimableError(`Error: attempting to claim hat ${hatId.toString()}, which is not claimable`);
        }
        let claimsHatterToUse;
        for (let i = 0; i < hat.claimableBy.length; i++) {
            const claimsHatter = hat.claimableBy[i];
            const wearsAdmin = await this._publicClient.readContract({
                address: claimsHatter.id,
                abi: CLAIMS_HATTER_ABI,
                functionName: "wearsAdmin",
                args: [hatId],
            });
            if (wearsAdmin) {
                claimsHatterToUse = claimsHatter;
            }
        }
        if (claimsHatterToUse === undefined) {
            throw new NotAdminError("Error: attempting to claim a hat which does not have a claims hatter instance as admin");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: claimsHatterToUse.id,
                abi: CLAIMS_HATTER_ABI,
                functionName: "claimHat",
                args: [hatId],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
            };
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Claim a hat on behalf of a chosen account.
     *
     * @param account - A Viem account.
     * @param hatId - ID of the hat to claim-for.
     * @param wearer -  Address for which to claim the hat for.
     * @returns An object containing the status of the call and the transaction hash.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     *
     * @throws HatNotClaimableForError
     * Thrown if the hat is not claimable-for.
     *
     * @throws NotExplicitlyEligibleError
     * Thrown if the wearer is not explicitly eligible for the hat.
     *
     * @throws NotAdminError
     * Thrown if there is no multi claims hatter instance that is the hat's admin.
     */
    async claimHatFor({ account, hatId, wearer, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        const hat = (await this._graphqlClient.getHat({
            chainId: this.chainId,
            hatId,
            props: {
                claimableForBy: {
                    props: {},
                    filters: { first: 1 },
                },
            },
        }));
        if (hat.claimableForBy.length == 0) {
            throw new HatNotClaimableForError(`Error: attempting to claim-for hat ${hatId.toString()}, which is not claimable-for`);
        }
        let claimsHatterToUse;
        for (let i = 0; i < hat.claimableForBy.length; i++) {
            const claimsHatter = hat.claimableForBy[i];
            const wearsAdmin = await this._publicClient.readContract({
                address: claimsHatter.id,
                abi: CLAIMS_HATTER_ABI,
                functionName: "wearsAdmin",
                args: [hatId],
            });
            if (wearsAdmin) {
                claimsHatterToUse = claimsHatter;
            }
        }
        if (claimsHatterToUse === undefined) {
            throw new NotAdminError("Error: attempting to claim a hat which does not have a claims hatter instance as admin");
        }
        try {
            const { request } = await this._publicClient.simulateContract({
                address: claimsHatterToUse.id,
                abi: CLAIMS_HATTER_ABI,
                functionName: "claimHatFor",
                args: [hatId, wearer],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
            };
        }
        catch (err) {
            getError(err);
        }
    }
    /**
     * Claim a hat on behalf of multiple accounts.
     *
     * @param account - A Viem account.
     * @param hatId - ID of the hat to claim-for.
     * @param wearers -  Addresses for which to claim the hat for.
     * @returns An object containing the status of the call and the transaction hash.
     *
     * @throws MissingWalletClientError
     * Thrown if no wallet client was provided in the hats client initialization.
     *
     * @throws HatNotClaimableForError
     * Thrown if the hat is not claimable-for.
     *
     * @throws NotExplicitlyEligibleError
     * Thrown if one of the wearers is not explicitly eligible for the hat.
     *
     * @throws NotAdminError
     * Thrown if there is no multi claims hatter instance that is the hat's admin.
     */
    async multiClaimHatFor({ account, hatId, wearers, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Wallet client is required to perform this action");
        }
        const hat = (await this._graphqlClient.getHat({
            chainId: this.chainId,
            hatId,
            props: {
                claimableForBy: {
                    props: {},
                    filters: { first: 1 },
                },
            },
        }));
        if (hat.claimableForBy.length == 0) {
            throw new HatNotClaimableForError(`Error: attempting to claim-for hat ${hatId.toString()}, which is not claimable-for`);
        }
        let claimsHatterToUse;
        for (let i = 0; i < hat.claimableForBy.length; i++) {
            const claimsHatter = hat.claimableForBy[i];
            const wearsAdmin = await this._publicClient.readContract({
                address: claimsHatter.id,
                abi: CLAIMS_HATTER_ABI,
                functionName: "wearsAdmin",
                args: [hatId],
            });
            if (wearsAdmin) {
                claimsHatterToUse = claimsHatter;
            }
        }
        if (claimsHatterToUse === undefined) {
            throw new NotAdminError("Error: attempting to claim a hat which does not have a claims hatter instance as admin");
        }
        let hatIdsArray = new Array(wearers.length);
        hatIdsArray = hatIdsArray.fill(hatId);
        try {
            const { request } = await this._publicClient.simulateContract({
                address: claimsHatterToUse.id,
                abi: CLAIMS_HATTER_ABI,
                functionName: "claimHatsFor",
                args: [hatIdsArray, wearers],
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
            };
        }
        catch (err) {
            getError(err);
        }
    }
}

exports.FALLBACK_ADDRESS = FALLBACK_ADDRESS;
exports.HATS_ABI = HATS_ABI;
exports.HATS_V1 = HATS_V1;
exports.HatsClient = HatsClient;
exports.MAX_LEVELS = MAX_LEVELS;
exports.MAX_LEVEL_HATS = MAX_LEVEL_HATS;
exports.ZERO_ID = ZERO_ID;
exports.hatIdDecimalToHex = hatIdDecimalToHex;
exports.hatIdDecimalToIp = hatIdDecimalToIp;
exports.hatIdHexToDecimal = hatIdHexToDecimal;
exports.hatIdIpToDecimal = hatIdIpToDecimal;
exports.hatIdToTreeId = hatIdToTreeId;
exports.treeIdDecimalToHex = treeIdDecimalToHex;
exports.treeIdHexToDecimal = treeIdHexToDecimal;
exports.treeIdToTopHatId = treeIdToTopHatId;

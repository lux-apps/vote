'use strict';

var viem = require('viem');
var zod = require('zod');
var axios = require('axios');

class MissingPublicClientError extends Error {
    constructor(message) {
        super(message);
        this.name = "MissingPublicClientError";
    }
}
class MissingWalletClientError extends Error {
    constructor(message) {
        super(message);
        this.name = "MissingWalletClientError";
    }
}
class MissingPublicClientChainError extends Error {
    constructor(message) {
        super(message);
        this.name = "MissingPublicClientChainError";
    }
}
class TransactionRevertedError extends Error {
    constructor(message) {
        super(message);
        this.name = "TransactionRevertedError";
    }
}
class ModuleNotAvailableError extends Error {
    constructor(message) {
        super(message);
        this.name = "ModuleNotAvailableError";
    }
}
class InvalidParamError extends Error {
    constructor(message) {
        super(message);
        this.name = "InvalidParamError";
    }
}
class ClientNotPreparedError extends Error {
    constructor(message) {
        super(message);
        this.name = "ClientNotPreparedError";
    }
}
class ParametersLengthsMismatchError extends Error {
    constructor(message) {
        super(message);
        this.name = "ParametersLengthsMismatchError";
    }
}
class ModulesRegistryFetchError extends Error {
    constructor(message) {
        super(message);
        this.name = "ModulesRegistryFetchError";
    }
}
class ModuleParameterError extends Error {
    constructor(message) {
        super(message);
        this.name = "ModuleParameterError";
    }
}
class ModuleFunctionRevertedError extends Error {
    constructor(message) {
        super(message);
        this.name = "ModuleFunctionRevertedError";
    }
}
// AllowList Eligibility Errors
class AllowlistEligibility_NotOwnerError extends Error {
    constructor(message) {
        super(message);
        this.name = "AllowlistEligibility_NotOwnerError";
    }
}
class AllowlistEligibility_NotArbitratorError extends Error {
    constructor(message) {
        super(message);
        this.name = "AllowlistEligibility_NotArbitratorError";
    }
}
class AllowlistEligibility_NotWearerError extends Error {
    constructor(message) {
        super(message);
        this.name = "AllowlistEligibility_NotWearerError";
    }
}
// HatsElection Eligibility Errors
class HatsElectionEligibility_NotBallotBoxError extends Error {
    constructor(message) {
        super(message);
        this.name = "HatsElectionEligibility_NotBallotBoxError";
    }
}
class HatsElectionEligibility_NotAdminError extends Error {
    constructor(message) {
        super(message);
        this.name = "HatsElectionEligibility_NotAdminError";
    }
}
class HatsElectionEligibility_TooManyWinnersError extends Error {
    constructor(message) {
        super(message);
        this.name = "HatsElectionEligibility_TooManyWinnersError";
    }
}
class HatsElectionEligibility_ElectionClosedError extends Error {
    constructor(message) {
        super(message);
        this.name = "HatsElectionEligibility_ElectionClosedError";
    }
}
class HatsElectionEligibility_InvalidTermEndError extends Error {
    constructor(message) {
        super(message);
        this.name = "HatsElectionEligibility_InvalidTermEndError";
    }
}
class HatsElectionEligibility_TermNotEndedError extends Error {
    constructor(message) {
        super(message);
        this.name = "HatsElectionEligibility_TermNotEndedError";
    }
}
class HatsElectionEligibility_NextTermNotReadyError extends Error {
    constructor(message) {
        super(message);
        this.name = "HatsElectionEligibility_NextTermNotReadyError";
    }
}
// JokeRace Eligibility Errors
class JokeraceEligibility_ContestNotCompletedError extends Error {
    constructor(message) {
        super(message);
        this.name = "JokeraceEligibility_ContestNotCompletedError";
    }
}
class JokeraceEligibility_TermNotCompletedError extends Error {
    constructor(message) {
        super(message);
        this.name = "JokeraceEligibility_TermNotCompletedError";
    }
}
class JokeraceEligibility_NotAdminError extends Error {
    constructor(message) {
        super(message);
        this.name = "JokeraceEligibility_NotAdminError";
    }
}
class JokeraceEligibility_MustHaveDownvotingDisabledError extends Error {
    constructor(message) {
        super(message);
        this.name = "JokeraceEligibility_MustHaveDownvotingDisabledError";
    }
}
class JokeraceEligibility_MustHaveSortingEnabledError extends Error {
    constructor(message) {
        super(message);
        this.name = "JokeraceEligibility_MustHaveSortingEnabledError";
    }
}
// Passthrough Eligibility Errors
class PassthroughEligibility_NotAuthorizedError extends Error {
    constructor(message) {
        super(message);
        this.name = "PassthroughEligibility_NotAuthorizedError";
    }
}
// Season Toggle Errors
class SeasonToggle_NotBranchAdminError extends Error {
    constructor(message) {
        super(message);
        this.name = "SeasonToggle_NotBranchAdminError";
    }
}
class SeasonToggle_NotExtendableError extends Error {
    constructor(message) {
        super(message);
        this.name = "SeasonToggle_NotExtendableError";
    }
}
class SeasonToggle_InvalidExtensionDelayError extends Error {
    constructor(message) {
        super(message);
        this.name = "SeasonToggle_InvalidExtensionDelay";
    }
}
class SeasonToggle_SeasonDurationTooShortError extends Error {
    constructor(message) {
        super(message);
        this.name = "SeasonToggle_SeasonDurationTooShort";
    }
}
// Staking Eligibility Errors
class StakingEligibility_InsufficientStakeError extends Error {
    constructor(message) {
        super(message);
        this.name = "StakingEligibility_InsufficientStakeError";
    }
}
class StakingEligibility_CooldownNotEndedError extends Error {
    constructor(message) {
        super(message);
        this.name = "StakingEligibility_CooldownNotEndedError";
    }
}
class StakingEligibility_NoCooldownError extends Error {
    constructor(message) {
        super(message);
        this.name = "StakingEligibility_NoCooldownError";
    }
}
class StakingEligibility_AlreadySlashedError extends Error {
    constructor(message) {
        super(message);
        this.name = "StakingEligibility_AlreadySlashedError";
    }
}
class StakingEligibility_NotJudgeError extends Error {
    constructor(message) {
        super(message);
        this.name = "StakingEligibility_NotJudgeError";
    }
}
class StakingEligibility_NotRecipientError extends Error {
    constructor(message) {
        super(message);
        this.name = "StakingEligibility_NotRecipientError";
    }
}
class StakingEligibility_NotHatAdminError extends Error {
    constructor(message) {
        super(message);
        this.name = "StakingEligibility_NotHatAdminError";
    }
}
class StakingEligibility_HatImmutableError extends Error {
    constructor(message) {
        super(message);
        this.name = "StakingEligibility_HatImmutableError";
    }
}
class StakingEligibility_TransferFailedError extends Error {
    constructor(message) {
        super(message);
        this.name = "StakingEligibility_TransferFailedError";
    }
}
class StakingEligibility_NothingToWithdrawError extends Error {
    constructor(message) {
        super(message);
        this.name = "StakingEligibility_NothingToWithdrawError";
    }
}
class StakingEligibility_NotSlashedError extends Error {
    constructor(message) {
        super(message);
        this.name = "StakingEligibility_NotSlashedError";
    }
}
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
function getModuleFunctionError(err, moduleId) {
    if (err instanceof viem.BaseError) {
        const revertError = err.walk((err) => err instanceof viem.ContractFunctionRevertedError);
        if (revertError instanceof viem.ContractFunctionRevertedError) {
            const errorName = revertError.data?.errorName ?? "";
            // AllowList Eligibility error
            if (moduleId === "0xaC208e6668DE569C6ea1db76DeCea70430335Ed5") {
                switch (errorName) {
                    case "AllowlistEligibility_NotOwner": {
                        throw new AllowlistEligibility_NotOwnerError(`Error: the caller does not wear the module's Owner Hat`);
                    }
                    case "AllowlistEligibility_NotArbitrator": {
                        throw new AllowlistEligibility_NotArbitratorError(`Error: the caller does not wear the module's Arbitrator Hat`);
                    }
                    case "AllowlistEligibility_ArrayLengthMismatch": {
                        throw new AllowlistEligibility_NotArbitratorError(`Error: array arguments are not of the same length`);
                    }
                    case "AllowlistEligibility_NotWearer": {
                        throw new AllowlistEligibility_NotWearerError(`Error: Attempting to burn a hat that an account is not wearing`);
                    }
                    default: {
                        throw err;
                    }
                }
            }
            // Hat Elections Eligibility error
            if (moduleId === "0xd3b916a8F0C4f9D1d5B6Af29c3C012dbd4f3149E") {
                switch (errorName) {
                    case "NotBallotBox": {
                        throw new HatsElectionEligibility_NotBallotBoxError(`Error: the caller does not wear the module's Ballot Box Hat`);
                    }
                    case "NotAdmin": {
                        throw new HatsElectionEligibility_NotAdminError(`Error: the caller does not wear the module's Admin Hat`);
                    }
                    case "TooManyWinners": {
                        throw new HatsElectionEligibility_TooManyWinnersError(`Error: amount of election winners is larger than the hat's max amount of wearers`);
                    }
                    case "ElectionClosed": {
                        throw new HatsElectionEligibility_ElectionClosedError(`Error: attempting to submit results for a closed election`);
                    }
                    case "InvalidTermEnd": {
                        throw new HatsElectionEligibility_InvalidTermEndError(`Error: the next term's end time must be larger than the current one`);
                    }
                    case "TermNotEnded": {
                        throw new HatsElectionEligibility_TermNotEndedError(`Error: attempting to start the next term while the current one has not ended`);
                    }
                    case "NextTermNotReady": {
                        throw new HatsElectionEligibility_NextTermNotReadyError(`Error: next term must be set and its election must be closed`);
                    }
                    default: {
                        throw err;
                    }
                }
            }
            // JokeRace Eligibility error
            if (moduleId === "0xAE0e56A0c509dA713722c1aFFcF4B5f1C6CDc73a") {
                switch (errorName) {
                    case "JokeraceEligibility_ContestNotCompleted": {
                        throw new JokeraceEligibility_ContestNotCompletedError(`Error: the JokeRace contest has not completed yet`);
                    }
                    case "JokeraceEligibility_TermNotCompleted": {
                        throw new JokeraceEligibility_TermNotCompletedError(`Error: can only set a new election once the current term has ended`);
                    }
                    case "JokeraceEligibility_NotAdmin": {
                        throw new JokeraceEligibility_NotAdminError(`Error: caller does not wear the module's Admin Hat`);
                    }
                    case "JokeraceEligibility_MustHaveDownvotingDisabled": {
                        throw new JokeraceEligibility_MustHaveDownvotingDisabledError(`Error: only JokeRace contests with down-voting disabled are supported`);
                    }
                    case "JokeraceEligibility_MustHaveSortingEnabled": {
                        throw new JokeraceEligibility_MustHaveSortingEnabledError(`Error: only JokeRace contests with sorting enabled are supported`);
                    }
                    default: {
                        throw err;
                    }
                }
            }
            // Passthrough Eligibility error
            if (moduleId === "0x050079a8fbFCE76818C62481BA015b89567D2d35") {
                switch (errorName) {
                    case "NotAuthorized": {
                        throw new PassthroughEligibility_NotAuthorizedError(`Error: caller is not wearing the eligibility/toggle passthrough hat`);
                    }
                    default: {
                        throw err;
                    }
                }
            }
            // Season Toggle error
            if (moduleId === "0xFb6bD2e96B123d0854064823f6cb59420A285C00") {
                switch (errorName) {
                    case "SeasonToggle_NotBranchAdmin": {
                        throw new SeasonToggle_NotBranchAdminError(`Error: caller is not an admin of the season toggle branch`);
                    }
                    case "SeasonToggle_NotExtendable": {
                        throw new SeasonToggle_NotExtendableError(`Error: attempting to extend a branch to a new season before its extendable`);
                    }
                    case "SeasonToggle_InvalidExtensionDelay": {
                        throw new SeasonToggle_InvalidExtensionDelayError(`Error: valid extension delays are smaller than 10,000`);
                    }
                    case "SeasonToggle_SeasonDurationTooShort": {
                        throw new SeasonToggle_SeasonDurationTooShortError(`Error: season durations must be at least one hour long`);
                    }
                    default: {
                        throw err;
                    }
                }
            }
            // Staking Eligibility error
            if (moduleId === "0x9E01030aF633Be5a439DF122F2eEf750b44B8aC7") {
                switch (errorName) {
                    case "StakingEligibility_InsufficientStake": {
                        throw new StakingEligibility_InsufficientStakeError(`Error: attempting to unstake more than staker has staked`);
                    }
                    case "StakingEligibility_CooldownNotEnded": {
                        throw new StakingEligibility_CooldownNotEndedError(`Error: attempting to complete an unstake before the cooldown period has elapsed`);
                    }
                    case "StakingEligibility_NoCooldownEnded": {
                        throw new StakingEligibility_NoCooldownError(`Error: attempting to complete an unstake before beginning a cooldown period`);
                    }
                    case "StakingEligibility_AlreadySlashed": {
                        throw new StakingEligibility_AlreadySlashedError(`Error: attempting to slash an already-slashed wearer, or a slashed staker tries to unstake`);
                    }
                    case "StakingEligibility_NotJudge": {
                        throw new StakingEligibility_NotJudgeError(`Error: caller is not wearing the Judge Hat`);
                    }
                    case "StakingEligibility_NotRecipient": {
                        throw new StakingEligibility_NotRecipientError(`Error: caller is not wearing the Recipient Hat`);
                    }
                    case "StakingEligibility_NotHatAdmin": {
                        throw new StakingEligibility_NotHatAdminError(`Error: caller is not the hat's admin`);
                    }
                    case "StakingEligibility_HatImmutable": {
                        throw new StakingEligibility_HatImmutableError(`Error: a change to the minStake is attempted on an immutable hat`);
                    }
                    case "StakingEligibility_TransferFailed": {
                        throw new StakingEligibility_TransferFailedError(`Error: staking token transfer has failed`);
                    }
                    case "StakingEligibility_NothingToWithdraw": {
                        throw new StakingEligibility_NothingToWithdrawError(`Error: nothing to withdraw`);
                    }
                    case "StakingEligibility_NotSlashed": {
                        throw new StakingEligibility_NotSlashedError(`Error: attempting to forgive an unslashed staker`);
                    }
                    default: {
                        throw err;
                    }
                }
            }
            // Error from an unknown module
            throw new ModuleFunctionRevertedError(`Error: module function reverted with error name ${errorName}`);
        }
    }
    else {
        if (err instanceof Error) {
            throw err;
        }
        else {
            throw new Error("Unexpected error occured");
        }
    }
}

// Uint
const Uint8Schema = zod.z
    .number()
    .int()
    .nonnegative()
    .lte(255)
    .describe("number");
const Uint16Schema = zod.z
    .number()
    .int()
    .nonnegative()
    .lte(65535)
    .describe("number");
const Uint24Schema = zod.z
    .number()
    .int()
    .nonnegative()
    .lte(16777215)
    .describe("number");
const Uint32Schema = zod.z
    .number()
    .int()
    .nonnegative()
    .lte(4294967295)
    .describe("number");
const Uint40Schema = zod.z
    .number()
    .int()
    .nonnegative()
    .lte(1099511627775)
    .describe("number");
const Uint48Schema = zod.z
    .number()
    .int()
    .nonnegative()
    .lte(281474976710655)
    .describe("number");
const Uint56Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(72057594037927935n)
    .describe("bigint");
const Uint64Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(18446744073709551615n)
    .describe("bigint");
const Uint72Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(4722366482869645213695n)
    .describe("bigint");
const Uint80Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(1208925819614629174706175n)
    .describe("bigint");
const Uint88Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(309485009821345068724781055n)
    .describe("bigint");
const Uint96Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(79228162514264337593543950335n)
    .describe("bigint");
const Uint104Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(20282409603651670423947251286015n)
    .describe("bigint");
const Uint112Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(5192296858534827628530496329220095n)
    .describe("bigint");
const Uint120Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(1329227995784915872903807060280344575n)
    .describe("bigint");
const Uint128Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(340282366920938463463374607431768211455n)
    .describe("bigint");
const Uint136Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(87112285931760246646623899502532662132735n)
    .describe("bigint");
const Uint144Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(22300745198530623141535718272648361505980415n)
    .describe("bigint");
const Uint152Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(5708990770823839524233143877797980545530986495n)
    .describe("bigint");
const Uint160Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(1461501637330902918203684832716283019655932542975n)
    .describe("bigint");
const Uint168Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(374144419156711147060143317175368453031918731001855n)
    .describe("bigint");
const Uint176Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(95780971304118053647396689196894323976171195136475135n)
    .describe("bigint");
const Uint184Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(24519928653854221733733552434404946937899825954937634815n)
    .describe("bigint");
const Uint192Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(6277101735386680763835789423207666416102355444464034512895n)
    .describe("bigint");
const Uint200Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(1606938044258990275541962092341162602522202993782792835301375n)
    .describe("bigint");
const Uint208Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(411376139330301510538742295639337626245683966408394965837152255n)
    .describe("bigint");
const Uint216Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(105312291668557186697918027683670432318895095400549111254310977535n)
    .describe("bigint");
const Uint224Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(26959946667150639794667015087019630673637144422540572481103610249215n)
    .describe("bigint");
const Uint232Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(6901746346790563787434755862277025452451108972170386555162524223799295n)
    .describe("bigint");
const Uint240Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(1766847064778384329583297500742918515827483896875618958121606201292619775n)
    .describe("bigint");
const Uint248Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(452312848583266388373324160190187140051835877600158453279131187530910662655n)
    .describe("bigint");
const Uint256Schema = zod.z
    .bigint()
    .nonnegative()
    .lte(115792089237316195423570985008687907853269984665640564039457584007913129639935n)
    .describe("bigint");
// Int
const Int8Schema = zod.z
    .number()
    .int()
    .gte(-128)
    .lte(127)
    .describe("number");
const Int16Schema = zod.z
    .number()
    .int()
    .gte(-32768)
    .lte(32767)
    .describe("number");
const Int24Schema = zod.z
    .number()
    .int()
    .gte(-8388608)
    .lte(8388607)
    .describe("number");
const Int32Schema = zod.z
    .number()
    .int()
    .gte(-2147483648)
    .lte(2147483647)
    .describe("number");
const Int40Schema = zod.z
    .number()
    .int()
    .gte(-549755813888)
    .lte(549755813887)
    .describe("number");
const Int48Schema = zod.z
    .number()
    .int()
    .gte(-140737488355328)
    .lte(140737488355327)
    .describe("number");
const Int56Schema = zod.z
    .bigint()
    .gte(-36028797018963968n)
    .lte(36028797018963967n)
    .describe("bigint");
const Int64Schema = zod.z
    .bigint()
    .gte(-9223372036854775808n)
    .lte(9223372036854775807n)
    .describe("bigint");
const Int72Schema = zod.z
    .bigint()
    .gte(-2361183241434822606848n)
    .lte(2361183241434822606847n)
    .describe("bigint");
const Int80Schema = zod.z
    .bigint()
    .gte(-604462909807314587353088n)
    .lte(604462909807314587353088n)
    .describe("bigint");
const Int88Schema = zod.z
    .bigint()
    .gte(-154742504910672534362390528n)
    .lte(154742504910672534362390527n)
    .describe("bigint");
const Int96Schema = zod.z
    .bigint()
    .gte(-39614081257132168796771975168n)
    .lte(39614081257132168796771975168n)
    .describe("bigint");
const Int104Schema = zod.z
    .bigint()
    .gte(-10141204801825835211973625643008n)
    .lte(10141204801825835211973625643007n)
    .describe("bigint");
const Int112Schema = zod.z
    .bigint()
    .gte(-2596148429267413814265248164610048n)
    .lte(2596148429267413814265248164610047n)
    .describe("bigint");
const Int120Schema = zod.z
    .bigint()
    .gte(-664613997892457936451903530140172288n)
    .lte(664613997892457936451903530140172287n)
    .describe("bigint");
const Int128Schema = zod.z
    .bigint()
    .gte(-170141183460469231731687303715884105728n)
    .lte(170141183460469231731687303715884105727n)
    .describe("bigint");
const Int136Schema = zod.z
    .bigint()
    .gte(-43556142965880123323311949751266331066368n)
    .lte(43556142965880123323311949751266331066367n)
    .describe("bigint");
const Int144Schema = zod.z
    .bigint()
    .gte(-11150372599265311570767859136324180752990208n)
    .lte(11150372599265311570767859136324180752990208n)
    .describe("bigint");
const Int152Schema = zod.z
    .bigint()
    .gte(-2854495385411919762116571938898990272765493248n)
    .lte(2854495385411919762116571938898990272765493247n)
    .describe("bigint");
const Int160Schema = zod.z
    .bigint()
    .gte(-730750818665451459101842416358141509827966271488n)
    .lte(730750818665451459101842416358141509827966271487n)
    .describe("bigint");
const Int168Schema = zod.z
    .bigint()
    .gte(-187072209578355573530071658587684226515959365500928n)
    .lte(187072209578355573530071658587684226515959365500927n)
    .describe("bigint");
const Int176Schema = zod.z
    .bigint()
    .gte(-47890485652059026823698344598447161988085597568237568n)
    .lte(47890485652059026823698344598447161988085597568237567n)
    .describe("bigint");
const Int184Schema = zod.z
    .bigint()
    .gte(-12259964326927110866866776217202473468949912977468817408n)
    .lte(12259964326927110866866776217202473468949912977468817407n)
    .describe("bigint");
const Int192Schema = zod.z
    .bigint()
    .gte(-3138550867693340381917894711603833208051177722232017256448n)
    .lte(3138550867693340381917894711603833208051177722232017256447n)
    .describe("bigint");
const Int200Schema = zod.z
    .bigint()
    .gte(-803469022129495137770981046170581301261101496891396417650688n)
    .lte(803469022129495137770981046170581301261101496891396417650687n)
    .describe("bigint");
const Int208Schema = zod.z
    .bigint()
    .gte(-205688069665150755269371147819668813122841983204197482918576128n)
    .lte(205688069665150755269371147819668813122841983204197482918576128n)
    .describe("bigint");
const Int216Schema = zod.z
    .bigint()
    .gte(-52656145834278593348959013841835216159447547700274555627155488768n)
    .lte(52656145834278593348959013841835216159447547700274555627155488767n)
    .describe("bigint");
const Int224Schema = zod.z
    .bigint()
    .gte(-13479973333575319897333507543509815336818572211270286240551805124608n)
    .lte(13479973333575319897333507543509815336818572211270286240551805124607n)
    .describe("bigint");
const Int232Schema = zod.z
    .bigint()
    .gte(-3450873173395281893717377931138512726225554486085193277581262111899648n)
    .lte(3450873173395281893717377931138512726225554486085193277581262111899647n)
    .describe("bigint");
const Int240Schema = zod.z
    .bigint()
    .gte(-883423532389192164791648750371459257913741948437809479060803100646309888n)
    .lte(883423532389192164791648750371459257913741948437809479060803100646309887n)
    .describe("bigint");
const Int248Schema = zod.z
    .bigint()
    .gte(-226156424291633194186662080095093570025917938800079226639565593765455331328n)
    .lte(226156424291633194186662080095093570025917938800079226639565593765455331327n)
    .describe("bigint");
const Int256Schema = zod.z
    .bigint()
    .gte(-57896044618658097711785492504343953926634992332820282019728792003956564819968n)
    .lte(57896044618658097711785492504343953926634992332820282019728792003956564819967n)
    .describe("bigint");
const AddressSchema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{40}$/)
    .describe("string");
const BooleanSchema = zod.z.boolean().describe("boolean");
const StringSchema = zod.z.string().describe("string");
const Bytes1Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{2}$/)
    .describe("bigint");
const Bytes2Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{4}$/)
    .describe("bigint");
const Bytes3Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{6}$/)
    .describe("bigint");
const Bytes4Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{8}$/)
    .describe("bigint");
const Bytes5Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{10}$/)
    .describe("bigint");
const Bytes6Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{12}$/)
    .describe("bigint");
const Bytes7Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{14}$/)
    .describe("bigint");
const Bytes8Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{16}$/)
    .describe("bigint");
const Bytes9Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{18}$/)
    .describe("bigint");
const Bytes10Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{20}$/)
    .describe("bigint");
const Bytes11Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{22}$/)
    .describe("bigint");
const Bytes12Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{24}$/)
    .describe("bigint");
const Bytes13Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{26}$/)
    .describe("bigint");
const Bytes14Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{28}$/)
    .describe("bigint");
const Bytes15Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{30}$/)
    .describe("bigint");
const Bytes16Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{32}$/)
    .describe("bigint");
const Bytes17Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{34}$/)
    .describe("bigint");
const Bytes18Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{36}$/)
    .describe("bigint");
const Bytes19Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{38}$/)
    .describe("bigint");
const Bytes20Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{40}$/)
    .describe("bigint");
const Bytes21Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{42}$/)
    .describe("bigint");
const Bytes22Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{44}$/)
    .describe("bigint");
const Bytes23Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{46}$/)
    .describe("bigint");
const Bytes24Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{48}$/)
    .describe("bigint");
const Bytes25Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{50}$/)
    .describe("bigint");
const Bytes26Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{52}$/)
    .describe("bigint");
const Bytes27Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{54}$/)
    .describe("bigint");
const Bytes28Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{56}$/)
    .describe("bigint");
const Bytes29Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{58}$/)
    .describe("bigint");
const Bytes30Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{60}$/)
    .describe("bigint");
const Bytes31Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{62}$/)
    .describe("bigint");
const Bytes32Schema = zod.z
    .string()
    .regex(/^0x[a-fA-F0-9]{64}$/)
    .describe("bigint");
const BytesSchema = zod.z
    .string()
    .regex(/^0x([a-fA-F0-9][a-fA-F0-9])*$/)
    .describe("bigint");
// Uint array
const ArrayUint8Schema = zod.z.array(Uint8Schema).describe("number[]");
const ArrayUint16Schema = zod.z.array(Uint16Schema).describe("number[]");
const ArrayUint24Schema = zod.z.array(Uint24Schema).describe("number[]");
const ArrayUint32Schema = zod.z.array(Uint32Schema).describe("number[]");
const ArrayUint40Schema = zod.z.array(Uint40Schema).describe("number[]");
const ArrayUint48Schema = zod.z.array(Uint48Schema).describe("number[]");
const ArrayUint56Schema = zod.z.array(Uint56Schema).describe("bigint[]");
const ArrayUint64Schema = zod.z.array(Uint64Schema).describe("bigint[]");
const ArrayUint72Schema = zod.z.array(Uint72Schema).describe("bigint[]");
const ArrayUint80Schema = zod.z.array(Uint80Schema).describe("bigint[]");
const ArrayUint88Schema = zod.z.array(Uint88Schema).describe("bigint[]");
const ArrayUint96Schema = zod.z.array(Uint96Schema).describe("bigint[]");
const ArrayUint104Schema = zod.z.array(Uint104Schema).describe("bigint[]");
const ArrayUint112Schema = zod.z.array(Uint112Schema).describe("bigint[]");
const ArrayUint120Schema = zod.z.array(Uint120Schema).describe("bigint[]");
const ArrayUint128Schema = zod.z.array(Uint128Schema).describe("bigint[]");
const ArrayUint136Schema = zod.z.array(Uint136Schema).describe("bigint[]");
const ArrayUint144Schema = zod.z.array(Uint144Schema).describe("bigint[]");
const ArrayUint152Schema = zod.z.array(Uint152Schema).describe("bigint[]");
const ArrayUint160Schema = zod.z.array(Uint160Schema).describe("bigint[]");
const ArrayUint168Schema = zod.z.array(Uint168Schema).describe("bigint[]");
const ArrayUint176Schema = zod.z.array(Uint176Schema).describe("bigint[]");
const ArrayUint184Schema = zod.z.array(Uint184Schema).describe("bigint[]");
const ArrayUint192Schema = zod.z.array(Uint192Schema).describe("bigint[]");
const ArrayUint200Schema = zod.z.array(Uint200Schema).describe("bigint[]");
const ArrayUint208Schema = zod.z.array(Uint208Schema).describe("bigint[]");
const ArrayUint216Schema = zod.z.array(Uint216Schema).describe("bigint[]");
const ArrayUint224Schema = zod.z.array(Uint224Schema).describe("bigint[]");
const ArrayUint232Schema = zod.z.array(Uint232Schema).describe("bigint[]");
const ArrayUint240Schema = zod.z.array(Uint240Schema).describe("bigint[]");
const ArrayUint248Schema = zod.z.array(Uint248Schema).describe("bigint[]");
const ArrayUint256Schema = zod.z.array(Uint256Schema).describe("bigint[]");
// Int array
const ArrayInt8Schema = zod.z.array(Int8Schema).describe("number[]");
const ArrayInt16Schema = zod.z.array(Int16Schema).describe("number[]");
const ArrayInt24Schema = zod.z.array(Int24Schema).describe("number[]");
const ArrayInt32Schema = zod.z.array(Int32Schema).describe("number[]");
const ArrayInt40Schema = zod.z.array(Int40Schema).describe("number[]");
const ArrayInt48Schema = zod.z.array(Int48Schema).describe("number[]");
const ArrayInt56Schema = zod.z.array(Int56Schema).describe("bigint[]");
const ArrayInt64Schema = zod.z.array(Int64Schema).describe("bigint[]");
const ArrayInt72Schema = zod.z.array(Int72Schema).describe("bigint[]");
const ArrayInt80Schema = zod.z.array(Int80Schema).describe("bigint[]");
const ArrayInt88Schema = zod.z.array(Int88Schema).describe("bigint[]");
const ArrayInt96Schema = zod.z.array(Int96Schema).describe("bigint[]");
const ArrayInt104Schema = zod.z.array(Int104Schema).describe("bigint[]");
const ArrayInt112Schema = zod.z.array(Int112Schema).describe("bigint[]");
const ArrayInt120Schema = zod.z.array(Int120Schema).describe("bigint[]");
const ArrayInt128Schema = zod.z.array(Int128Schema).describe("bigint[]");
const ArrayInt136Schema = zod.z.array(Int136Schema).describe("bigint[]");
const ArrayInt144Schema = zod.z.array(Int144Schema).describe("bigint[]");
const ArrayInt152Schema = zod.z.array(Int152Schema).describe("bigint[]");
const ArrayInt160Schema = zod.z.array(Int160Schema).describe("bigint[]");
const ArrayInt168Schema = zod.z.array(Int168Schema).describe("bigint[]");
const ArrayInt176Schema = zod.z.array(Int176Schema).describe("bigint[]");
const ArrayInt184Schema = zod.z.array(Int184Schema).describe("bigint[]");
const ArrayInt192Schema = zod.z.array(Int192Schema).describe("bigint[]");
const ArrayInt200Schema = zod.z.array(Int200Schema).describe("bigint[]");
const ArrayInt208Schema = zod.z.array(Int208Schema).describe("bigint[]");
const ArrayInt216Schema = zod.z.array(Int216Schema).describe("bigint[]");
const ArrayInt224Schema = zod.z.array(Int224Schema).describe("bigint[]");
const ArrayInt232Schema = zod.z.array(Int232Schema).describe("bigint[]");
const ArrayInt240Schema = zod.z.array(Int240Schema).describe("bigint[]");
const ArrayInt248Schema = zod.z.array(Int248Schema).describe("bigint[]");
const ArrayInt256Schema = zod.z.array(Int256Schema).describe("bigint[]");
// Bytes Array
const ArrayBytes1Schema = zod.z.array(Bytes1Schema).describe("string[]");
const ArrayBytes2Schema = zod.z.array(Bytes2Schema).describe("string[]");
const ArrayBytes3Schema = zod.z.array(Bytes3Schema).describe("string[]");
const ArrayBytes4Schema = zod.z.array(Bytes4Schema).describe("string[]");
const ArrayBytes5Schema = zod.z.array(Bytes5Schema).describe("string[]");
const ArrayBytes6Schema = zod.z.array(Bytes6Schema).describe("string[]");
const ArrayBytes7Schema = zod.z.array(Bytes7Schema).describe("string[]");
const ArrayBytes8Schema = zod.z.array(Bytes8Schema).describe("string[]");
const ArrayBytes9Schema = zod.z.array(Bytes9Schema).describe("string[]");
const ArrayBytes10Schema = zod.z.array(Bytes10Schema).describe("string[]");
const ArrayBytes11Schema = zod.z.array(Bytes11Schema).describe("string[]");
const ArrayBytes12Schema = zod.z.array(Bytes12Schema).describe("string[]");
const ArrayBytes13Schema = zod.z.array(Bytes13Schema).describe("string[]");
const ArrayBytes14Schema = zod.z.array(Bytes14Schema).describe("string[]");
const ArrayBytes15Schema = zod.z.array(Bytes15Schema).describe("string[]");
const ArrayBytes16Schema = zod.z.array(Bytes16Schema).describe("string[]");
const ArrayBytes17Schema = zod.z.array(Bytes17Schema).describe("string[]");
const ArrayBytes18Schema = zod.z.array(Bytes18Schema).describe("string[]");
const ArrayBytes19Schema = zod.z.array(Bytes19Schema).describe("string[]");
const ArrayBytes20Schema = zod.z.array(Bytes20Schema).describe("string[]");
const ArrayBytes21Schema = zod.z.array(Bytes21Schema).describe("string[]");
const ArrayBytes22Schema = zod.z.array(Bytes22Schema).describe("string[]");
const ArrayBytes23Schema = zod.z.array(Bytes23Schema).describe("string[]");
const ArrayBytes24Schema = zod.z.array(Bytes24Schema).describe("string[]");
const ArrayBytes25Schema = zod.z.array(Bytes25Schema).describe("string[]");
const ArrayBytes26Schema = zod.z.array(Bytes26Schema).describe("string[]");
const ArrayBytes27Schema = zod.z.array(Bytes27Schema).describe("string[]");
const ArrayBytes28Schema = zod.z.array(Bytes28Schema).describe("string[]");
const ArrayBytes29Schema = zod.z.array(Bytes29Schema).describe("string[]");
const ArrayBytes30Schema = zod.z.array(Bytes30Schema).describe("string[]");
const ArrayBytes31Schema = zod.z.array(Bytes31Schema).describe("string[]");
const ArrayBytes32Schema = zod.z.array(Bytes32Schema).describe("string[]");
const ArrayBytesSchema = zod.z.array(BytesSchema).describe("string[]");
// String array
const ArrayStringSchema = zod.z.array(StringSchema).describe("string[]");
// Boolean array
const ArrayBooleanSchema = zod.z.array(BooleanSchema).describe("boolean[]");
// Address array
const ArrayAddressSchema = zod.z.array(AddressSchema).describe("string[]");
const typeToSchema = {
    uint256: Uint256Schema,
    uint248: Uint248Schema,
    uint240: Uint240Schema,
    uint232: Uint232Schema,
    uint224: Uint224Schema,
    uint216: Uint216Schema,
    uint208: Uint208Schema,
    uint200: Uint200Schema,
    uint192: Uint192Schema,
    uint184: Uint184Schema,
    uint176: Uint176Schema,
    uint168: Uint168Schema,
    uint160: Uint160Schema,
    uint152: Uint152Schema,
    uint144: Uint144Schema,
    uint136: Uint136Schema,
    uint128: Uint128Schema,
    uint120: Uint120Schema,
    uint112: Uint112Schema,
    uint104: Uint104Schema,
    uint96: Uint96Schema,
    uint88: Uint88Schema,
    uint80: Uint80Schema,
    uint72: Uint72Schema,
    uint64: Uint64Schema,
    uint56: Uint56Schema,
    uint48: Uint48Schema,
    uint40: Uint40Schema,
    uint32: Uint32Schema,
    uint24: Uint24Schema,
    uint16: Uint16Schema,
    uint8: Uint8Schema,
    int256: Int256Schema,
    int248: Int248Schema,
    int240: Int240Schema,
    int232: Int232Schema,
    int224: Int224Schema,
    int216: Int216Schema,
    int208: Int208Schema,
    int200: Int200Schema,
    int192: Int192Schema,
    int184: Int184Schema,
    int176: Int176Schema,
    int168: Int168Schema,
    int160: Int160Schema,
    int152: Int152Schema,
    int144: Int144Schema,
    int136: Int136Schema,
    int128: Int128Schema,
    int120: Int120Schema,
    int112: Int112Schema,
    int104: Int104Schema,
    int96: Int96Schema,
    int88: Int88Schema,
    int80: Int80Schema,
    int72: Int72Schema,
    int64: Int64Schema,
    int56: Int56Schema,
    int48: Int48Schema,
    int40: Int40Schema,
    int32: Int32Schema,
    int24: Int24Schema,
    int16: Int16Schema,
    int8: Int8Schema,
    bytes1: Bytes1Schema,
    bytes2: Bytes2Schema,
    bytes3: Bytes3Schema,
    bytes4: Bytes4Schema,
    bytes5: Bytes5Schema,
    bytes6: Bytes6Schema,
    bytes7: Bytes7Schema,
    bytes8: Bytes8Schema,
    bytes9: Bytes9Schema,
    bytes10: Bytes10Schema,
    bytes11: Bytes11Schema,
    bytes12: Bytes12Schema,
    bytes13: Bytes13Schema,
    bytes14: Bytes14Schema,
    bytes15: Bytes15Schema,
    bytes16: Bytes16Schema,
    bytes17: Bytes17Schema,
    bytes18: Bytes18Schema,
    bytes19: Bytes19Schema,
    bytes20: Bytes20Schema,
    bytes21: Bytes21Schema,
    bytes22: Bytes22Schema,
    bytes23: Bytes23Schema,
    bytes24: Bytes24Schema,
    bytes25: Bytes25Schema,
    bytes26: Bytes26Schema,
    bytes27: Bytes27Schema,
    bytes28: Bytes28Schema,
    bytes29: Bytes29Schema,
    bytes30: Bytes30Schema,
    bytes31: Bytes31Schema,
    bytes32: Bytes32Schema,
    bytes: BytesSchema,
    address: AddressSchema,
    bool: BooleanSchema,
    string: StringSchema,
    "uint256[]": ArrayUint256Schema,
    "uint248[]": ArrayUint248Schema,
    "uint240[]": ArrayUint240Schema,
    "uint232[]": ArrayUint232Schema,
    "uint224[]": ArrayUint224Schema,
    "uint216[]": ArrayUint216Schema,
    "uint208[]": ArrayUint208Schema,
    "uint200[]": ArrayUint200Schema,
    "uint192[]": ArrayUint192Schema,
    "uint184[]": ArrayUint184Schema,
    "uint176[]": ArrayUint176Schema,
    "uint168[]": ArrayUint168Schema,
    "uint160[]": ArrayUint160Schema,
    "uint152[]": ArrayUint152Schema,
    "uint144[]": ArrayUint144Schema,
    "uint136[]": ArrayUint136Schema,
    "uint128[]": ArrayUint128Schema,
    "uint120[]": ArrayUint120Schema,
    "uint112[]": ArrayUint112Schema,
    "uint104[]": ArrayUint104Schema,
    "uint96[]": ArrayUint96Schema,
    "uint88[]": ArrayUint88Schema,
    "uint80[]": ArrayUint80Schema,
    "uint72[]": ArrayUint72Schema,
    "uint64[]": ArrayUint64Schema,
    "uint56[]": ArrayUint56Schema,
    "uint48[]": ArrayUint48Schema,
    "uint40[]": ArrayUint40Schema,
    "uint32[]": ArrayUint32Schema,
    "uint24[]": ArrayUint24Schema,
    "uint16[]": ArrayUint16Schema,
    "uint8[]": ArrayUint8Schema,
    "int256[]": ArrayInt256Schema,
    "int248[]": ArrayInt248Schema,
    "int240[]": ArrayInt240Schema,
    "int232[]": ArrayInt232Schema,
    "int224[]": ArrayInt224Schema,
    "int216[]": ArrayInt216Schema,
    "int208[]": ArrayInt208Schema,
    "int200[]": ArrayInt200Schema,
    "int192[]": ArrayInt192Schema,
    "int184[]": ArrayInt184Schema,
    "int176[]": ArrayInt176Schema,
    "int168[]": ArrayInt168Schema,
    "int160[]": ArrayInt160Schema,
    "int152[]": ArrayInt152Schema,
    "int144[]": ArrayInt144Schema,
    "int136[]": ArrayInt136Schema,
    "int128[]": ArrayInt128Schema,
    "int120[]": ArrayInt120Schema,
    "int112[]": ArrayInt112Schema,
    "int104[]": ArrayInt104Schema,
    "int96[]": ArrayInt96Schema,
    "int88[]": ArrayInt88Schema,
    "int80[]": ArrayInt80Schema,
    "int72[]": ArrayInt72Schema,
    "int64[]": ArrayInt64Schema,
    "int56[]": ArrayInt56Schema,
    "int48[]": ArrayInt48Schema,
    "int40[]": ArrayInt40Schema,
    "int32[]": ArrayInt32Schema,
    "int24[]": ArrayInt24Schema,
    "int16[]": ArrayInt16Schema,
    "int8[]": ArrayInt8Schema,
    "bytes1[]": ArrayBytes1Schema,
    "bytes2[]": ArrayBytes2Schema,
    "bytes3[]": ArrayBytes3Schema,
    "bytes4[]": ArrayBytes4Schema,
    "bytes5[]": ArrayBytes5Schema,
    "bytes6[]": ArrayBytes6Schema,
    "bytes7[]": ArrayBytes7Schema,
    "bytes8[]": ArrayBytes8Schema,
    "bytes9[]": ArrayBytes9Schema,
    "bytes10[]": ArrayBytes10Schema,
    "bytes11[]": ArrayBytes11Schema,
    "bytes12[]": ArrayBytes12Schema,
    "bytes13[]": ArrayBytes13Schema,
    "bytes14[]": ArrayBytes14Schema,
    "bytes15[]": ArrayBytes15Schema,
    "bytes16[]": ArrayBytes16Schema,
    "bytes17[]": ArrayBytes17Schema,
    "bytes18[]": ArrayBytes18Schema,
    "bytes19[]": ArrayBytes19Schema,
    "bytes20[]": ArrayBytes20Schema,
    "bytes21[]": ArrayBytes21Schema,
    "bytes22[]": ArrayBytes22Schema,
    "bytes23[]": ArrayBytes23Schema,
    "bytes24[]": ArrayBytes24Schema,
    "bytes25[]": ArrayBytes25Schema,
    "bytes26[]": ArrayBytes26Schema,
    "bytes27[]": ArrayBytes27Schema,
    "bytes28[]": ArrayBytes28Schema,
    "bytes29[]": ArrayBytes29Schema,
    "bytes30[]": ArrayBytes30Schema,
    "bytes31[]": ArrayBytes31Schema,
    "bytes32[]": ArrayBytes32Schema,
    "bytes[]": ArrayBytesSchema,
    "address[]": ArrayAddressSchema,
    "bool[]": ArrayBooleanSchema,
    "string[]": ArrayStringSchema,
};
/**
 * Get the Zod schema for a Solidity type.
 *
 * @param solidityType - A string matching the name of a Solidity type.
 * @returns A Zod schema for the provided Solidity type.
 */
const getSchema = (solidityType) => {
    const schema = typeToSchema[solidityType];
    if (schema === undefined) {
        return zod.z.any();
    }
    return schema;
};
/**
 * Verify a given value according to its matching Solidity type.
 *
 * @param val - The value to be verified.
 * @param type - The Solidity type for the verification.
 * @returns True if the value is verified for the given type, false otherwise.
 */
const verify = (val, type) => {
    const schema = typeToSchema[type];
    if (schema === undefined) {
        return true;
    }
    const res = schema.safeParse(val);
    return res.success;
};
/**
 * Get the Typescript type which is compatible with an expected Solidity type.
 *
 * @param type - The Solidity type for for which the compatible Typedcript type should be returned.
 * @returns A string matching the compatible Typescript type for the provided Solidity type.
 */
const solidityToTypescriptType = (type) => {
    const schema = typeToSchema[type];
    if (schema === undefined) {
        return "unknown";
    }
    const tsType = schema.description;
    if (tsType === "number" ||
        tsType === "bigint" ||
        tsType === "string" ||
        tsType === "boolean" ||
        tsType === "number[]" ||
        tsType === "bigint[]" ||
        tsType === "string[]" ||
        tsType === "boolean[]") {
        return tsType;
    }
    else {
        throw new Error("Unexpected error: typescript type of schema");
    }
};

const HATS_MODULES_FACTORY_ADDRESS = "0x0a3f85fa597B6a967271286aA0724811acDF5CD9";
const HATS_ELIGIBILITIES_CHAIN_MODULE_ADDRESS = {
    11155111: "0x8aded513a191e3fee91bb192aba20fcc9c16af2e",
    10: "0x8aded513a191e3fee91bb192aba20fcc9c16af2e",
    1: "0x8aded513a191e3fee91bb192aba20fcc9c16af2e",
    100: "0x8aded513a191e3fee91bb192aba20fcc9c16af2e",
    137: "0x8aded513a191e3fee91bb192aba20fcc9c16af2e",
    42220: "0x8aded513a191e3fee91bb192aba20fcc9c16af2e",
    42161: "0x8aded513a191e3fee91bb192aba20fcc9c16af2e",
    8453: "0x8aded513a191e3fee91bb192aba20fcc9c16af2e",
};
const HATS_TOGGLES_CHAIN_MODULE_ADDRESS = {
    11155111: "0x841Bc396ad88A9C6b78F05b7754a9d22E3fB264b",
    10: "0x841Bc396ad88A9C6b78F05b7754a9d22E3fB264b",
    1: "0x841Bc396ad88A9C6b78F05b7754a9d22E3fB264b",
    100: "0x841Bc396ad88A9C6b78F05b7754a9d22E3fB264b",
    137: "0x841Bc396ad88A9C6b78F05b7754a9d22E3fB264b",
    42220: "0x841Bc396ad88A9C6b78F05b7754a9d22E3fB264b",
    42161: "0x841Bc396ad88A9C6b78F05b7754a9d22E3fB264b",
    8453: "0x841Bc396ad88A9C6b78F05b7754a9d22E3fB264b",
};
const HATS_ELIGIBILITIES_CHAIN_MODULE_ADDRESS_ADDITIONAL = "0x83200f1633cdb6c8f28f202cea1b6a9105862d83";
const HATS_TOGGLES_CHAIN_MODULE_ADDRESS_ADDITIONAL = "0x2f1388e095bec051db9f1b226faf222ef5c33f16";
const HATS_TOGGLES_CHAIN_MODULE_ABI = [
    {
        inputs: [{ internalType: "string", name: "_version", type: "string" }],
        stateMutability: "nonpayable",
        type: "constructor",
    },
    {
        anonymous: false,
        inputs: [
            { indexed: false, internalType: "uint8", name: "version", type: "uint8" },
        ],
        name: "Initialized",
        type: "event",
    },
    {
        inputs: [],
        name: "CONJUNCTION_CLAUSE_LENGTHS",
        outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [],
        name: "HATS",
        outputs: [{ internalType: "contract IHats", name: "", type: "address" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [],
        name: "IMPLEMENTATION",
        outputs: [{ internalType: "address", name: "", type: "address" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [],
        name: "MODULES",
        outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [],
        name: "NUM_CONJUNCTION_CLAUSES",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [{ internalType: "uint256", name: "_hatId", type: "uint256" }],
        name: "getHatStatus",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "hatId",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [{ internalType: "bytes", name: "_initData", type: "bytes" }],
        name: "setUp",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "version",
        outputs: [{ internalType: "string", name: "", type: "string" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "version_",
        outputs: [{ internalType: "string", name: "", type: "string" }],
        stateMutability: "view",
        type: "function",
    },
];
const HATS_ELIGIBILITIES_CHAIN_MODULE_ABI = [
    {
        inputs: [{ internalType: "string", name: "_version", type: "string" }],
        stateMutability: "nonpayable",
        type: "constructor",
    },
    {
        anonymous: false,
        inputs: [
            { indexed: false, internalType: "uint8", name: "version", type: "uint8" },
        ],
        name: "Initialized",
        type: "event",
    },
    {
        inputs: [],
        name: "CONJUNCTION_CLAUSE_LENGTHS",
        outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [],
        name: "HATS",
        outputs: [{ internalType: "contract IHats", name: "", type: "address" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [],
        name: "IMPLEMENTATION",
        outputs: [{ internalType: "address", name: "", type: "address" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [],
        name: "MODULES",
        outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [],
        name: "NUM_CONJUNCTION_CLAUSES",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [
            { internalType: "address", name: "_wearer", type: "address" },
            { internalType: "uint256", name: "_hatId", type: "uint256" },
        ],
        name: "getWearerStatus",
        outputs: [
            { internalType: "bool", name: "eligible", type: "bool" },
            { internalType: "bool", name: "standing", type: "bool" },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "hatId",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [{ internalType: "bytes", name: "_initData", type: "bytes" }],
        name: "setUp",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "version",
        outputs: [{ internalType: "string", name: "", type: "string" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "version_",
        outputs: [{ internalType: "string", name: "", type: "string" }],
        stateMutability: "view",
        type: "function",
    },
];
const HATS_MODULES_FACTORY_ABI = [
    {
        inputs: [
            { internalType: "contract IHats", name: "_hats", type: "address" },
            { internalType: "string", name: "_version", type: "string" },
        ],
        stateMutability: "nonpayable",
        type: "constructor",
    },
    { inputs: [], name: "BatchArrayLengthMismatch", type: "error" },
    {
        inputs: [
            { internalType: "address", name: "implementation", type: "address" },
            { internalType: "uint256", name: "hatId", type: "uint256" },
            { internalType: "bytes", name: "otherImmutableArgs", type: "bytes" },
            { internalType: "uint256", name: "saltNonce", type: "uint256" },
        ],
        name: "HatsModuleFactory_ModuleAlreadyDeployed",
        type: "error",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "address",
                name: "implementation",
                type: "address",
            },
            {
                indexed: false,
                internalType: "address",
                name: "instance",
                type: "address",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "hatId",
                type: "uint256",
            },
            {
                indexed: false,
                internalType: "bytes",
                name: "otherImmutableArgs",
                type: "bytes",
            },
            {
                indexed: false,
                internalType: "bytes",
                name: "initData",
                type: "bytes",
            },
            {
                indexed: false,
                internalType: "uint256",
                name: "saltNonce",
                type: "uint256",
            },
        ],
        name: "HatsModuleFactory_ModuleDeployed",
        type: "event",
    },
    {
        inputs: [],
        name: "HATS",
        outputs: [{ internalType: "contract IHats", name: "", type: "address" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "address[]",
                name: "_implementations",
                type: "address[]",
            },
            { internalType: "uint256[]", name: "_hatIds", type: "uint256[]" },
            {
                internalType: "bytes[]",
                name: "_otherImmutableArgsArray",
                type: "bytes[]",
            },
            { internalType: "bytes[]", name: "_initDataArray", type: "bytes[]" },
            { internalType: "uint256[]", name: "_saltNonces", type: "uint256[]" },
        ],
        name: "batchCreateHatsModule",
        outputs: [{ internalType: "bool", name: "success", type: "bool" }],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            { internalType: "address", name: "_implementation", type: "address" },
            { internalType: "uint256", name: "_hatId", type: "uint256" },
            { internalType: "bytes", name: "_otherImmutableArgs", type: "bytes" },
            { internalType: "bytes", name: "_initData", type: "bytes" },
            { internalType: "uint256", name: "_saltNonce", type: "uint256" },
        ],
        name: "createHatsModule",
        outputs: [{ internalType: "address", name: "_instance", type: "address" }],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [
            { internalType: "address", name: "_implementation", type: "address" },
            { internalType: "uint256", name: "_hatId", type: "uint256" },
            { internalType: "bytes", name: "_otherImmutableArgs", type: "bytes" },
            { internalType: "uint256", name: "_saltNonce", type: "uint256" },
        ],
        name: "deployed",
        outputs: [{ internalType: "bool", name: "", type: "bool" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [
            { internalType: "address", name: "_implementation", type: "address" },
            { internalType: "uint256", name: "_hatId", type: "uint256" },
            { internalType: "bytes", name: "_otherImmutableArgs", type: "bytes" },
            { internalType: "uint256", name: "_saltNonce", type: "uint256" },
        ],
        name: "getHatsModuleAddress",
        outputs: [{ internalType: "address", name: "", type: "address" }],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "version",
        outputs: [{ internalType: "string", name: "", type: "string" }],
        stateMutability: "view",
        type: "function",
    },
];
const HATS_MODULE_ABI = [
    {
        inputs: [
            {
                internalType: "string",
                name: "_version",
                type: "string",
            },
        ],
        stateMutability: "nonpayable",
        type: "constructor",
    },
    {
        anonymous: false,
        inputs: [
            {
                indexed: false,
                internalType: "uint8",
                name: "version",
                type: "uint8",
            },
        ],
        name: "Initialized",
        type: "event",
    },
    {
        inputs: [],
        name: "HATS",
        outputs: [
            {
                internalType: "contract IHats",
                name: "",
                type: "address",
            },
        ],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [],
        name: "IMPLEMENTATION",
        outputs: [
            {
                internalType: "address",
                name: "",
                type: "address",
            },
        ],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [],
        name: "hatId",
        outputs: [
            {
                internalType: "uint256",
                name: "",
                type: "uint256",
            },
        ],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [
            {
                internalType: "bytes",
                name: "_initData",
                type: "bytes",
            },
        ],
        name: "setUp",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
    },
    {
        inputs: [],
        name: "version",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
    {
        inputs: [],
        name: "version_",
        outputs: [
            {
                internalType: "string",
                name: "",
                type: "string",
            },
        ],
        stateMutability: "view",
        type: "function",
    },
];
const CHAIN_ABI = [
    {
        inputs: [],
        name: "CONJUNCTION_CLAUSE_LENGTHS",
        outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [],
        name: "MODULES",
        outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
        stateMutability: "pure",
        type: "function",
    },
    {
        inputs: [],
        name: "NUM_CONJUNCTION_CLAUSES",
        outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
        stateMutability: "pure",
        type: "function",
    },
];

/**
 * Check and encode the immutable and mutable arguments for module creation.
 *
 * @param module - The module object of the module that will be created.
 * @param immutableArgs - The module's immutable arguments.
 * @param mutableArgs - The module's mutable arguments.
 * @returns An object containing the encoded immutable and mutable arguments.
 *
 * @throws InvalidParamError
 * Thrown if one of the immutable/mutable args is invalid.
 *
 * @throws ParametersLengthsMismatchError
 * Thrown if one of the immutable/mutable args array's length doens't match the module's schema.
 */
const checkAndEncodeArgs = ({ module, immutableArgs, mutableArgs, }) => {
    checkImmutableArgs({ module, immutableArgs });
    checkMutableArgs({ module, mutableArgs });
    const mutableArgsTypes = module.creationArgs.mutable.map((arg) => {
        return { type: arg.type };
    });
    const immutableArgsTypes = module.creationArgs.immutable.map((arg) => {
        return arg.type;
    });
    const encodedMutableArgs = mutableArgs.length > 0
        ? viem.encodeAbiParameters(mutableArgsTypes, mutableArgs)
        : "0x";
    const encodedImmutableArgs = immutableArgs.length > 0
        ? viem.encodePacked(immutableArgsTypes, immutableArgs)
        : "0x";
    return { encodedImmutableArgs, encodedMutableArgs };
};
/**
 * Check the immutable arguments for module creation.
 *
 * @param module - The module object of the module that will be created.
 * @param immutableArgs - The module's immutable arguments.
 *
 * @throws InvalidParamError
 * Thrown if one of the immutable args is invalid.
 *
 * @throws ParametersLengthsMismatchError
 * Thrown if the immutable args array's length doens't match the module's schema.
 */
const checkImmutableArgs = ({ module, immutableArgs, }) => {
    if (immutableArgs.length !== module.creationArgs.immutable.length) {
        throw new ParametersLengthsMismatchError("Error: not all creation arguments were provided");
    }
    for (let i = 0; i < immutableArgs.length; i++) {
        const val = immutableArgs[i];
        const type = module.creationArgs.immutable[i].type;
        if (!verify(val, type)) {
            throw new InvalidParamError(`Error: received an invalid value for parameter '${module.creationArgs.immutable[i].name}'`);
        }
    }
};
/**
 * Check the mutable arguments for module creation.
 *
 * @param module - The module object of the module that will be created.
 * @param mutableArgs - The module's mutable arguments.
 *
 * @throws InvalidParamError
 * Thrown if one of the mutable args is invalid.
 *
 * @throws ParametersLengthsMismatchError
 * Thrown if the mutable args array's length doens't match the module's schema.
 */
const checkMutableArgs = ({ module, mutableArgs, }) => {
    if (mutableArgs.length !== module.creationArgs.mutable.length) {
        throw new ParametersLengthsMismatchError("Error: not all creation arguments were provided");
    }
    for (let i = 0; i < mutableArgs.length; i++) {
        const val = mutableArgs[i];
        const type = module.creationArgs.mutable[i].type;
        if (!verify(val, type)) {
            throw new InvalidParamError(`Error: received an invalid value for parameter '${module.creationArgs.mutable[i].name}'`);
        }
    }
};
const checkWriteFunctionArgs = ({ func, args, }) => {
    if (args.length !== func.args.length) {
        throw new ParametersLengthsMismatchError("Error: not all function arguments were provided");
    }
    for (let i = 0; i < args.length; i++) {
        const val = args[i];
        const type = func.args[i].type;
        if (!verify(val, type)) {
            throw new InvalidParamError(`Error: received an invalid value for parameter '${func.args[i].name}'`);
        }
    }
};
/**
 * Get the addresses of newly created module instances from the creation transaction receipt.
 *
 * @param receipt - The transaction receipt as a TransactionReceipt Viem object.
 */
const getNewInstancesFromReceipt = (receipt) => {
    const instances = [];
    for (let eventIndex = 0; eventIndex < receipt.logs.length; eventIndex++) {
        try {
            const event = viem.decodeEventLog({
                abi: [
                    {
                        anonymous: false,
                        inputs: [
                            {
                                indexed: false,
                                internalType: "address",
                                name: "implementation",
                                type: "address",
                            },
                            {
                                indexed: false,
                                internalType: "address",
                                name: "instance",
                                type: "address",
                            },
                            {
                                indexed: false,
                                internalType: "uint256",
                                name: "hatId",
                                type: "uint256",
                            },
                            {
                                indexed: false,
                                internalType: "bytes",
                                name: "otherImmutableArgs",
                                type: "bytes",
                            },
                            {
                                indexed: false,
                                internalType: "bytes",
                                name: "initData",
                                type: "bytes",
                            },
                            {
                                indexed: false,
                                internalType: "uint256",
                                name: "saltNonce",
                                type: "uint256",
                            },
                        ],
                        name: "HatsModuleFactory_ModuleDeployed",
                        type: "event",
                    },
                ],
                eventName: "HatsModuleFactory_ModuleDeployed",
                data: receipt.logs[eventIndex].data,
                topics: receipt.logs[eventIndex].topics,
            });
            instances.push(event.args.instance);
            continue;
        }
        catch (err) {
            // continue
        }
        try {
            const event = viem.decodeEventLog({
                abi: [
                    {
                        anonymous: false,
                        inputs: [
                            {
                                indexed: false,
                                internalType: "address",
                                name: "implementation",
                                type: "address",
                            },
                            {
                                indexed: false,
                                internalType: "address",
                                name: "instance",
                                type: "address",
                            },
                            {
                                indexed: false,
                                internalType: "uint256",
                                name: "hatId",
                                type: "uint256",
                            },
                            {
                                indexed: false,
                                internalType: "bytes",
                                name: "otherImmutableArgs",
                                type: "bytes",
                            },
                            {
                                indexed: false,
                                internalType: "bytes",
                                name: "initData",
                                type: "bytes",
                            },
                        ],
                        name: "HatsModuleFactory_ModuleDeployed",
                        type: "event",
                    },
                ],
                eventName: "HatsModuleFactory_ModuleDeployed",
                data: receipt.logs[eventIndex].data,
                topics: receipt.logs[eventIndex].topics,
            });
            instances.push(event.args.instance);
        }
        catch (err) {
            // continue
        }
    }
    return instances;
};

class HatsModulesClient {
    /**
     * Initialize a HatsModulesClient.
     *
     * @param publicClient - Viem Public Client.
     * @param walletClient - Viem Wallet Client.
     * @returns A HatsModulesClient instance.
     */
    constructor({ publicClient, walletClient, }) {
        if (publicClient === undefined) {
            throw new MissingPublicClientError("Error: Public client is required");
        }
        if (publicClient.chain === undefined) {
            throw new MissingPublicClientChainError("Error: Public client must be initialized with a chain");
        }
        this._publicClient = publicClient;
        this._walletClient = walletClient;
        this._chainId = publicClient.chain.id;
    }
    /**
     * Fetches the modules registry and prepares the client for usage.
     *
     * @param registry - Optional registry object. If provided, then these modules will be used instead of fetching from the registry.
     */
    async prepare(registry) {
        let registryToUse;
        if (registry !== undefined) {
            registryToUse = registry;
        }
        else {
            try {
                const result = await axios.get("https://raw.githubusercontent.com/Hats-Protocol/modules-registry/v1/modules.json");
                registryToUse = result.data;
            }
            catch (err) {
                throw new ModulesRegistryFetchError("Error: Could not fetch modules from the registry");
            }
        }
        this._modules = {};
        for (let moduleIndex = 0; moduleIndex < registryToUse.modules.length; moduleIndex++) {
            const module = registryToUse.modules[moduleIndex];
            let moduleSupportedInChain = false;
            module.deployments.forEach((deployment) => {
                if (deployment.chainId === this._publicClient.chain?.id.toString()) {
                    moduleSupportedInChain = true;
                }
            });
            if (moduleSupportedInChain) {
                const moduleId = module.implementationAddress;
                if (this._modules !== undefined) {
                    this._modules[moduleId] = module;
                }
            }
        }
    }
    /**
     * Create a new module instance.
     *
     * @param account - A Viem account.
     * @param moduleId - The module ID.
     * @param hatId - The hat ID for which the module is created.
     * @param immutableArgs - The module's immutable arguments.
     * @param mutableArgs - The module's mutable arguments.
     * @param saltNonce - Optional salt nonce to use. If not provided, will be randomly generated.
     * @returns An object containing the status of the call, the transaction hash and the new module instance address.
     */
    async createNewInstance({ account, moduleId, hatId, immutableArgs, mutableArgs, saltNonce, }) {
        if (this._modules === undefined) {
            throw new ClientNotPreparedError("Error: Client has not been initialized, requires a call to the prepare function");
        }
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Error: the client was initialized without a wallet client, which is required for this function");
        }
        const module = this.getModuleById(moduleId);
        if (module === undefined) {
            throw new ModuleNotAvailableError(`Error: Module with id ${moduleId} does not exist`);
        }
        // verify hat ID
        if (!verify(hatId, "uint256")) {
            throw new InvalidParamError(`Error: Invalid hat ID parameter`);
        }
        const { encodedImmutableArgs, encodedMutableArgs } = checkAndEncodeArgs({
            module,
            immutableArgs,
            mutableArgs,
        });
        let saltNonceToUse;
        if (saltNonce !== undefined) {
            // verify salt nonce
            if (!verify(saltNonce, "uint256")) {
                throw new InvalidParamError(`Error: Invalid salt nonce parameter`);
            }
            saltNonceToUse = saltNonce;
        }
        else {
            saltNonceToUse = BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER));
        }
        try {
            const hash = await this._walletClient.writeContract({
                address: HATS_MODULES_FACTORY_ADDRESS,
                abi: HATS_MODULES_FACTORY_ABI,
                functionName: "createHatsModule",
                account,
                args: [
                    module.implementationAddress,
                    hatId,
                    encodedImmutableArgs,
                    encodedMutableArgs,
                    saltNonceToUse,
                ],
                chain: this._walletClient.chain,
            });
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            const instances = getNewInstancesFromReceipt(receipt);
            if (instances.length != 1) {
                throw new Error("Unexpected error: instance address was not found");
            }
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
                newInstance: instances[0],
            };
        }
        catch (err) {
            console.log(err);
            throw new TransactionRevertedError("Error: Transaction reverted");
        }
    }
    /**
     * Batch create new module instances.
     *
     * @param account - A Viem account.
     * @param moduleIds - The module IDs.
     * @param hatIds - The hat IDs for which the modules are created.
     * @param immutableArgsArray - Each module's immutable arguments.
     * @param mutableArgsArray - Each module's mutable arguments.
     * @param saltNonces - Optional salt nonces to use. If not provided, will be randomly generated.
     * @returns An object containing the status of the call, the transaction hash and the new module instances addresses.
     */
    async batchCreateNewInstances({ account, moduleIds, hatIds, immutableArgsArray, mutableArgsArray, saltNonces, }) {
        if (this._modules === undefined) {
            throw new ClientNotPreparedError("Error: Client has not been initialized, requires a call to the prepare function");
        }
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Error: the client was initialized without a wallet client, which is required for this function");
        }
        const implementations = [];
        const encodedImmutableArgsArray = [];
        const encodedMutableArgsArray = [];
        const saltNoncesToUse = [];
        for (let i = 0; i < moduleIds.length; i++) {
            const module = this.getModuleById(moduleIds[i]);
            if (module === undefined) {
                throw new ModuleNotAvailableError(`Error: Module with id ${moduleIds[i]} does not exist`);
            }
            // verify hat ID
            if (!verify(hatIds[i], "uint256")) {
                throw new InvalidParamError(`Error: Invalid hat ID parameter`);
            }
            if (saltNonces !== undefined) {
                // verify salt nonce
                if (!verify(saltNonces[i], "uint256")) {
                    throw new InvalidParamError(`Error: Invalid salt nonce parameter`);
                }
                saltNoncesToUse.push(saltNonces[i]);
            }
            else {
                saltNoncesToUse.push(BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
            }
            const { encodedImmutableArgs, encodedMutableArgs } = checkAndEncodeArgs({
                module,
                immutableArgs: immutableArgsArray[i],
                mutableArgs: mutableArgsArray[i],
            });
            encodedMutableArgsArray.push(encodedMutableArgs);
            encodedImmutableArgsArray.push(encodedImmutableArgs);
            implementations.push(module.implementationAddress);
        }
        let receipt;
        try {
            const hash = await this._walletClient.writeContract({
                address: HATS_MODULES_FACTORY_ADDRESS,
                abi: HATS_MODULES_FACTORY_ABI,
                functionName: "batchCreateHatsModule",
                account,
                args: [
                    implementations,
                    hatIds,
                    encodedImmutableArgsArray,
                    encodedMutableArgsArray,
                    saltNoncesToUse,
                ],
                chain: this._walletClient.chain,
            });
            receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
        }
        catch (err) {
            console.log(err);
            throw new TransactionRevertedError("Error: Transaction reverted");
        }
        const instances = getNewInstancesFromReceipt(receipt);
        return {
            status: receipt.status,
            transactionHash: receipt.transactionHash,
            newInstances: instances,
        };
    }
    /**
     * Predict a module's address.
     *
     * @param moduleId - The module ID.
     * @param hatId - The hat ID for which the module is created.
     * @param immutableArgs - The module's immutable arguments.
     * @param saltNonce - Salt nonce to use.
     * @returns The module's predicted address.
     */
    async predictHatsModuleAddress({ moduleId, hatId, immutableArgs, saltNonce, }) {
        if (this._modules === undefined) {
            throw new ClientNotPreparedError("Error: Client has not been initialized, requires a call to the prepare function");
        }
        const module = this.getModuleById(moduleId);
        if (module === undefined) {
            throw new ModuleNotAvailableError(`Module with id ${moduleId} does not exist`);
        }
        // verify hat ID
        if (!verify(hatId, "uint256")) {
            throw new InvalidParamError(`Invalid hat ID parameter`);
        }
        checkImmutableArgs({ module, immutableArgs });
        const immutableArgsTypes = module.creationArgs.immutable.map((arg) => {
            return arg.type;
        });
        const immutableArgsEncoded = immutableArgs.length > 0
            ? viem.encodePacked(immutableArgsTypes, immutableArgs)
            : "0x";
        const predictedAddress = (await this._publicClient.readContract({
            address: HATS_MODULES_FACTORY_ADDRESS,
            abi: HATS_MODULES_FACTORY_ABI,
            functionName: "getHatsModuleAddress",
            args: [
                module.implementationAddress,
                hatId,
                immutableArgsEncoded,
                saltNonce,
            ],
        }));
        return predictedAddress;
    }
    /**
     * Check if a module is already deployed.
     *
     * @param moduleId - The module ID.
     * @param hatId - The hat ID for which the module is created.
     * @param immutableArgs - The module's immutable arguments.
     * @param saltNonce - Salt nonce to use.
     * @returns The module's predicted address.
     */
    async isModuleDeployed({ moduleId, hatId, immutableArgs, saltNonce, }) {
        if (this._modules === undefined) {
            throw new ClientNotPreparedError("Error: Client has not been initialized, requires a call to the prepare function");
        }
        const module = this.getModuleById(moduleId);
        if (module === undefined) {
            throw new ModuleNotAvailableError(`Error: Module with id ${moduleId} does not exist`);
        }
        // verify hat ID
        if (!verify(hatId, "uint256")) {
            throw new InvalidParamError(`Invalid hat ID parameter`);
        }
        checkImmutableArgs({ module, immutableArgs });
        const immutableArgsTypes = module.creationArgs.immutable.map((arg) => {
            return arg.type;
        });
        const immutableArgsEncoded = immutableArgs.length > 0
            ? viem.encodePacked(immutableArgsTypes, immutableArgs)
            : "0x";
        const deployed = (await this._publicClient.readContract({
            address: HATS_MODULES_FACTORY_ADDRESS,
            abi: HATS_MODULES_FACTORY_ABI,
            functionName: "deployed",
            args: [
                module.implementationAddress,
                hatId,
                immutableArgsEncoded,
                saltNonce,
            ],
        }));
        return deployed;
    }
    /**
     * Get module instance's parameters.
     * The parameters to fetch are listed in the module's registry object. If the given address is not a registry module, returns 'undefined'.
     *
     * @param instance - The module instace address.
     * @returns A list of objects, for each parameter. Each object includes the parameter's value, label, Solidity type and display type. If
     * the given address is not an instance of a registry module, then returns 'undefined'.
     */
    async getInstanceParameters(instance) {
        if (this._modules === undefined) {
            throw new ClientNotPreparedError("Error: Client has not been initialized, requires a call to the prepare function");
        }
        const moduleParameters = [];
        const module = await this.getModuleByInstance(instance);
        // check if instance is a registry module
        if (module === undefined) {
            return undefined;
        }
        for (let paramIndex = 0; paramIndex < module.parameters.length; paramIndex++) {
            const param = module.parameters[paramIndex];
            for (let abiItemIndex = 0; abiItemIndex < module.abi.length; abiItemIndex++) {
                const abiItem = module.abi[abiItemIndex];
                if (abiItem.type === "function" &&
                    abiItem.name === param.functionName) {
                    if (abiItem.inputs.length > 0 || abiItem.outputs.length !== 1) {
                        break;
                    }
                    let parameterValue;
                    try {
                        parameterValue = await this._publicClient.readContract({
                            address: instance,
                            abi: module.abi,
                            functionName: param.functionName,
                        });
                    }
                    catch (err) {
                        throw new ModuleParameterError(`Error: Failed reading function ${param.functionName} from the module instance ${instance}`);
                    }
                    const solidityType = abiItem.outputs[0].type;
                    moduleParameters.push({
                        label: param.label,
                        value: parameterValue,
                        solidityType: solidityType,
                        displayType: param.displayType,
                    });
                }
            }
        }
        return moduleParameters;
    }
    /*//////////////////////////////////////////////////////////////
                         Chain Modules
    //////////////////////////////////////////////////////////////*/
    /**
     * Create a new eligibilities chain module.
     *
     * @param account - A Viem account.
     * @param hatId - The hat ID for which the module is created.
     * @param numClauses - Number of conjunction clauses.
     * @param clausesLengths - Lengths of each clause.
     * @param modules - Array of module instances to chain, at the order corresponding to the provided clauses.
     * @param saltNonce - Optional salt nonce to use. If not provided, will be randomly generated.
     * @returns An object containing the status of the call, the transaction hash and the new module instance address.
     */
    async createEligibilitiesChain({ account, hatId, numClauses, clausesLengths, modules, saltNonce, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Error: the client was initialized without a wallet client, which is required for this function");
        }
        const numModules = clausesLengths.reduce((partialSum, len) => partialSum + len, 0);
        const immutableArgsTypes = ["uint256", "uint256[]"];
        const immutableArgs = [numClauses, clausesLengths];
        for (let i = 0; i < numModules; i++) {
            immutableArgsTypes.push("address");
            immutableArgs.push(modules[i]);
        }
        const mutableArgsEncoded = "0x";
        const immutableArgsEncoded = viem.encodePacked(immutableArgsTypes, immutableArgs);
        let saltNonceToUse;
        if (saltNonce !== undefined) {
            // verify salt nonce
            if (!verify(saltNonce, "uint256")) {
                throw new InvalidParamError(`Error: Invalid salt nonce parameter`);
            }
            saltNonceToUse = saltNonce;
        }
        else {
            saltNonceToUse = BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER));
        }
        try {
            const hash = await this._walletClient.writeContract({
                address: HATS_MODULES_FACTORY_ADDRESS,
                abi: HATS_MODULES_FACTORY_ABI,
                functionName: "createHatsModule",
                account,
                args: [
                    HATS_ELIGIBILITIES_CHAIN_MODULE_ADDRESS[this._chainId],
                    hatId,
                    immutableArgsEncoded,
                    mutableArgsEncoded,
                    saltNonceToUse,
                ],
                chain: this._walletClient.chain,
            });
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            let instance = "0x";
            for (let eventIndex = 0; eventIndex < receipt.logs.length; eventIndex++) {
                try {
                    const event = viem.decodeEventLog({
                        abi: HATS_MODULES_FACTORY_ABI,
                        eventName: "HatsModuleFactory_ModuleDeployed",
                        data: receipt.logs[eventIndex].data,
                        topics: receipt.logs[eventIndex].topics,
                    });
                    instance = event.args.instance;
                    break;
                }
                catch (err) {
                    // continue
                }
            }
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
                newInstance: instance,
            };
        }
        catch (err) {
            console.log(err);
            throw new TransactionRevertedError("Error: Transaction reverted");
        }
    }
    /**
     * Create a new toggles chain module.
     *
     * @param account - A Viem account.
     * @param hatId - The hat ID for which the module is created.
     * @param numClauses - Number of conjunction clauses.
     * @param clausesLengths - Lengths of each clause.
     * @param modules - Array of module instances to chain, at the order corresponding to the provided clauses.
     * @param saltNonce - Optional salt nonce to use. If not provided, will be randomly generated.
     * @returns An object containing the status of the call, the transaction hash and the new module instance address.
     */
    async createTogglesChain({ account, hatId, numClauses, clausesLengths, modules, saltNonce, }) {
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Error: the client was initialized without a wallet client, which is required for this function");
        }
        const numModules = clausesLengths.reduce((partialSum, len) => partialSum + len, 0);
        const immutableArgsTypes = ["uint256", "uint256[]"];
        const immutableArgs = [numClauses, clausesLengths];
        for (let i = 0; i < numModules; i++) {
            immutableArgsTypes.push("address");
            immutableArgs.push(modules[i]);
        }
        const mutableArgsEncoded = "0x";
        const immutableArgsEncoded = viem.encodePacked(immutableArgsTypes, immutableArgs);
        let saltNonceToUse;
        if (saltNonce !== undefined) {
            // verify salt nonce
            if (!verify(saltNonce, "uint256")) {
                throw new InvalidParamError(`Error: Invalid salt nonce parameter`);
            }
            saltNonceToUse = saltNonce;
        }
        else {
            saltNonceToUse = BigInt(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER));
        }
        try {
            const hash = await this._walletClient.writeContract({
                address: HATS_MODULES_FACTORY_ADDRESS,
                abi: HATS_MODULES_FACTORY_ABI,
                functionName: "createHatsModule",
                account,
                args: [
                    HATS_TOGGLES_CHAIN_MODULE_ADDRESS[this._chainId],
                    hatId,
                    immutableArgsEncoded,
                    mutableArgsEncoded,
                    saltNonceToUse,
                ],
                chain: this._walletClient.chain,
            });
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            let instance = "0x";
            for (let eventIndex = 0; eventIndex < receipt.logs.length; eventIndex++) {
                try {
                    const event = viem.decodeEventLog({
                        abi: HATS_MODULES_FACTORY_ABI,
                        eventName: "HatsModuleFactory_ModuleDeployed",
                        data: receipt.logs[eventIndex].data,
                        topics: receipt.logs[eventIndex].topics,
                    });
                    instance = event.args.instance;
                    break;
                }
                catch (err) {
                    // continue
                }
            }
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
                newInstance: instance,
            };
        }
        catch (err) {
            console.log(err);
            throw new TransactionRevertedError("Error: Transaction reverted");
        }
    }
    /**
     * Get the rulesets of a module instance.
     *
     * @param address - instance address.
     * @returns the module's rulesets, or 'undefined' if the provided address is not a module.
     */
    async getRulesets(address, config) {
        const isChain = await this.isChain(address);
        if (isChain) {
            const rulesets = this.getChain(address, config?.includeLiveParams);
            return rulesets;
        }
        else {
            const module = await this.getModuleByInstance(address);
            if (module === undefined) {
                return module;
            }
            else {
                if (config?.includeLiveParams) {
                    const liveParams = (await this.getInstanceParameters(address));
                    return [
                        [{ module: module, address: address, liveParams: liveParams }],
                    ];
                }
                else {
                    return [[{ module: module, address: address }]];
                }
            }
        }
    }
    /**
     * Get the rulesets of multiple module instances.
     *
     * @param addresses - instances addresses.
     * @returns for each instance, returns the module's rulesets, or 'undefined' if the provided address is not a module.
     */
    async getRulesetsBatched(addresses, config) {
        if (addresses.length === 0) {
            return [];
        }
        const res = new Array(addresses.length);
        const isChains = await this.isChainBatched(addresses);
        const chainAddressesAndPos = [];
        const nonChainAddressesAndPos = [];
        for (let i = 0; i < addresses.length; i++) {
            if (isChains[i]) {
                chainAddressesAndPos.push({ pos: i, address: addresses[i] });
            }
            else {
                nonChainAddressesAndPos.push({ pos: i, address: addresses[i] });
            }
        }
        // handle chains
        const chains = await this.getChainBatched(chainAddressesAndPos.map((elem) => elem.address), config?.includeLiveParams);
        for (let chainIndex = 0; chainIndex < chainAddressesAndPos.length; chainIndex++) {
            const rulesets = chains[chainIndex];
            res[chainAddressesAndPos[chainIndex].pos] = rulesets;
        }
        // handle non chains
        const modules = await this.getModulesByInstances(nonChainAddressesAndPos.map((elem) => elem.address));
        for (let nonChainIndex = 0; nonChainIndex < nonChainAddressesAndPos.length; nonChainIndex++) {
            const address = nonChainAddressesAndPos[nonChainIndex].address;
            const module = modules[nonChainIndex];
            if (module === undefined) {
                res[nonChainAddressesAndPos[nonChainIndex].pos] = undefined;
            }
            else {
                let liveParams = [];
                if (config?.includeLiveParams) {
                    liveParams = (await this.getInstanceParameters(address));
                }
                res[nonChainAddressesAndPos[nonChainIndex].pos] = [
                    [
                        {
                            module: module,
                            address: nonChainAddressesAndPos[nonChainIndex].address,
                            liveParams: config?.includeLiveParams ? liveParams : undefined,
                        },
                    ],
                ];
            }
        }
        return res;
    }
    /**
     * Check whether a module instance is a modules chain.
     *
     * @param address - instance address.
     * @returns 'true' if the instance is a chain, 'false' otherwise.
     */
    async isChain(address) {
        try {
            const implementationAddress = await this._publicClient.readContract({
                address: address,
                abi: HATS_MODULE_ABI,
                functionName: "IMPLEMENTATION",
            });
            if (implementationAddress.toLowerCase() ===
                HATS_ELIGIBILITIES_CHAIN_MODULE_ADDRESS[this._chainId] ||
                implementationAddress.toLowerCase() ===
                    HATS_TOGGLES_CHAIN_MODULE_ADDRESS[this._chainId] ||
                implementationAddress.toLowerCase() ===
                    HATS_ELIGIBILITIES_CHAIN_MODULE_ADDRESS_ADDITIONAL ||
                implementationAddress.toLowerCase() ===
                    HATS_TOGGLES_CHAIN_MODULE_ADDRESS_ADDITIONAL) {
                return true;
            }
            else {
                return false;
            }
        }
        catch (err) {
            // not a module
            return false;
        }
    }
    /**
     * Check whether multiple module instances are modules chains.
     *
     * @param addresses - instances addresses.
     * @returns for each instance, 'true' if the instance is a chain, 'false' otherwise.
     */
    async isChainBatched(addresses) {
        if (addresses.length === 0) {
            return [];
        }
        const calls = [];
        addresses.forEach((address) => {
            calls.push({
                address,
                abi: HATS_MODULE_ABI,
                functionName: "IMPLEMENTATION",
            });
        });
        try {
            const res = [];
            const multicallResults = await this._publicClient.multicall({
                contracts: calls,
            });
            for (let addressIndex = 0; addressIndex < addresses.length; addressIndex++) {
                if (multicallResults[addressIndex].status == "failure") {
                    // not a module
                    res.push(false);
                    continue;
                }
                else {
                    const implementationAddress = multicallResults[addressIndex]
                        .result;
                    if (implementationAddress.toLowerCase() ===
                        HATS_ELIGIBILITIES_CHAIN_MODULE_ADDRESS[this._chainId] ||
                        implementationAddress.toLowerCase() ===
                            HATS_TOGGLES_CHAIN_MODULE_ADDRESS[this._chainId] ||
                        implementationAddress.toLowerCase() ===
                            HATS_ELIGIBILITIES_CHAIN_MODULE_ADDRESS_ADDITIONAL ||
                        implementationAddress.toLowerCase() ===
                            HATS_TOGGLES_CHAIN_MODULE_ADDRESS_ADDITIONAL) {
                        res.push(true);
                        continue;
                    }
                    else {
                        res.push(false);
                        continue;
                    }
                }
            }
            return res;
        }
        catch (err) {
            throw new Error("Error: multicall failed");
        }
    }
    /**
     * Get the rulesets of a chain module instance.
     *
     * @param address - instance address.
     * @returns the array of ruleset in the chain, or 'undefined' if the provided address is not a valid chain.
     */
    async getChain(address, includeLiveParams) {
        if (this._modules === undefined) {
            throw new ClientNotPreparedError("Error: Client has not been initialized, requires a call to the prepare function");
        }
        const calls = [
            {
                address: address,
                abi: CHAIN_ABI,
                functionName: "NUM_CONJUNCTION_CLAUSES",
            },
            {
                address: address,
                abi: CHAIN_ABI,
                functionName: "CONJUNCTION_CLAUSE_LENGTHS",
            },
            {
                address: address,
                abi: CHAIN_ABI,
                functionName: "MODULES",
            },
        ];
        try {
            const results = await this._publicClient.multicall({
                contracts: calls,
            });
            if (results[0].status === "failure" ||
                results[1].status === "failure" ||
                results[2].status === "failure") {
                return undefined;
            }
            const numRulesets = results[0].result;
            const rulesetsLengths = results[1].result;
            const modulesAddresses = results[2]
                .result;
            // get the module types
            const moduleTypes = await this.getModulesByInstances(modulesAddresses);
            if (moduleTypes.includes(undefined) ||
                modulesAddresses.length !== moduleTypes.length) {
                return undefined;
            }
            let liveParams = [];
            if (includeLiveParams) {
                const liveParamsCalls = modulesAddresses.map((moduleAddress) => {
                    return this.getInstanceParameters(moduleAddress);
                });
                liveParams = (await Promise.all(liveParamsCalls));
            }
            const res = [];
            let rulesetModulesOffset = 0;
            for (let rulesetIndex = 0; rulesetIndex < numRulesets; rulesetIndex++) {
                const rulesset = [];
                for (let rulesetModuleIndex = 0; rulesetModuleIndex < rulesetsLengths[rulesetIndex]; rulesetModuleIndex++) {
                    const rulesetModuleAddress = modulesAddresses[rulesetModulesOffset + rulesetModuleIndex];
                    const rulesetModuleType = moduleTypes[rulesetModulesOffset + rulesetModuleIndex];
                    const rulesetModuleLiveParams = includeLiveParams
                        ? liveParams[rulesetModulesOffset + rulesetModuleIndex]
                        : undefined;
                    rulesset.push({
                        module: rulesetModuleType,
                        address: rulesetModuleAddress,
                        liveParams: rulesetModuleLiveParams,
                    });
                }
                res.push(rulesset);
                rulesetModulesOffset += Number(rulesetsLengths[rulesetIndex]);
            }
            return res;
        }
        catch (err) {
        }
    }
    /**
     * Get the rulesets of multiple chain module instances.
     *
     * @param addresses - instances addresses.
     * @returns for each instance, the array of ruleset in the chain, or 'undefined' if the provided address is not a valid chain.
     */
    async getChainBatched(addresses, includeLiveParams) {
        if (addresses.length === 0) {
            return [];
        }
        if (this._modules === undefined) {
            throw new ClientNotPreparedError("Error: Client has not been initialized, requires a call to the prepare function");
        }
        const calls = [];
        addresses.forEach((address) => {
            calls.push({
                address: address,
                abi: CHAIN_ABI,
                functionName: "NUM_CONJUNCTION_CLAUSES",
            });
            calls.push({
                address: address,
                abi: CHAIN_ABI,
                functionName: "CONJUNCTION_CLAUSE_LENGTHS",
            });
            calls.push({
                address: address,
                abi: CHAIN_ABI,
                functionName: "MODULES",
            });
        });
        try {
            const res = [];
            const multicallResults = await this._publicClient.multicall({
                contracts: calls,
            });
            for (let addressIndex = 0; addressIndex < addresses.length; addressIndex++) {
                const multicallPos = addressIndex * 3;
                if (multicallResults[multicallPos].status === "failure" ||
                    multicallResults[multicallPos + 1].status === "failure" ||
                    multicallResults[multicallPos + 2].status === "failure") {
                    res.push(undefined);
                    continue;
                }
                const numRulesets = multicallResults[multicallPos].result;
                const rulesetsLengths = multicallResults[multicallPos + 1]
                    .result;
                const modulesAddresses = multicallResults[multicallPos + 2].result;
                let liveParams = [];
                if (includeLiveParams) {
                    const liveParamsCalls = modulesAddresses.map((moduleAddress) => {
                        return this.getInstanceParameters(moduleAddress);
                    });
                    liveParams = (await Promise.all(liveParamsCalls));
                }
                // get the module types
                const moduleTypes = await this.getModulesByInstances(modulesAddresses);
                if (moduleTypes.includes(undefined) ||
                    modulesAddresses.length !== moduleTypes.length) {
                    res.push(undefined);
                    continue;
                }
                const rulesets = [];
                let rulesetModulesOffset = 0;
                for (let rulesetIndex = 0; rulesetIndex < numRulesets; rulesetIndex++) {
                    const rulesset = [];
                    for (let rulesetModuleIndex = 0; rulesetModuleIndex < rulesetsLengths[rulesetIndex]; rulesetModuleIndex++) {
                        const rulesetModuleAddress = modulesAddresses[rulesetModulesOffset + rulesetModuleIndex];
                        const rulesetModuleType = moduleTypes[rulesetModulesOffset + rulesetModuleIndex];
                        const rulesetModuleLiveParams = includeLiveParams
                            ? liveParams[rulesetModulesOffset + rulesetModuleIndex]
                            : undefined;
                        rulesset.push({
                            module: rulesetModuleType,
                            address: rulesetModuleAddress,
                            liveParams: rulesetModuleLiveParams,
                        });
                    }
                    rulesets.push(rulesset);
                    rulesetModulesOffset += Number(rulesetsLengths[rulesetIndex]);
                }
                res.push(rulesets);
            }
            return res;
        }
        catch (err) {
            throw new Error("Error: multicall failed");
        }
    }
    /*//////////////////////////////////////////////////////////////
                         Module Getters
    //////////////////////////////////////////////////////////////*/
    /**
     * Get a module by its ID.
     *
     * @param moduleId - The module ID.
     * @returns The module matching the provided ID.
     */
    getModuleById(moduleId) {
        if (this._modules === undefined) {
            throw new ClientNotPreparedError("Error: Client has not been initialized, requires a call to the prepare function");
        }
        return this._modules[moduleId];
    }
    /**
     * Get a module by its implementation address.
     *
     * @param address - The implementation address.
     * @returns The module matching the provided implementation address. If no matching, returns 'undefined'.
     */
    getModuleByImplementation(address) {
        if (this._modules === undefined) {
            throw new ClientNotPreparedError("Error: Client has not been initialized, requires a call to the prepare function");
        }
        for (const [, module] of Object.entries(this._modules)) {
            if (module.implementationAddress === address) {
                return module;
            }
        }
    }
    /**
     * Get the module object of an instance.
     *
     * @param address - Instance address.
     * @returns The module matching the provided instance address. If the given address is not an insance of a registry module, then returns
     * 'undefined'.
     */
    async getModuleByInstance(address) {
        if (this._modules === undefined) {
            throw new ClientNotPreparedError("Error: Client has not been initialized, requires a call to the prepare function");
        }
        try {
            const implementationAddress = await this._publicClient.readContract({
                address: address,
                abi: HATS_MODULE_ABI,
                functionName: "IMPLEMENTATION",
            });
            const res = this.getModuleByImplementation(implementationAddress);
            return res;
        }
        catch (err) {
            return undefined;
        }
    }
    /**
     * Get the module objects of instances.
     *
     * @param addresses - Module Instances addresses.
     * @returns The modules matching the provided instances addresses. For every address that is not an instance of a registry module, the corresponding
     * return value in the array will be 'undefined'.
     */
    async getModulesByInstances(addresses) {
        if (this._modules === undefined) {
            throw new ClientNotPreparedError("Error: Client has not been initialized, requires a call to the prepare function");
        }
        const calls = addresses.map((address) => {
            return {
                address: address,
                abi: HATS_MODULE_ABI,
                functionName: "IMPLEMENTATION",
            };
        });
        try {
            const results = await this._publicClient.multicall({
                contracts: calls,
            });
            const modules = [];
            for (let i = 0; i < results.length; i++) {
                if (results[i].status === "failure") {
                    modules.push(undefined);
                    continue;
                }
                const module = this.getModuleByImplementation(results[i].result);
                modules.push(module);
            }
            return modules;
        }
        catch (err) {
            throw new Error("Error: multicall unexpected error");
        }
    }
    /**
     * Get all available modules, optionally use a filter function.
     *
     * @param filter Optional filter function
     * @returns An object which keys are module IDs and the values are the corresponding modules.
     */
    getModules(filter) {
        if (this._modules === undefined) {
            throw new ClientNotPreparedError("Error: Client has not been initialized, requires a call to the prepare function");
        }
        if (filter !== undefined) {
            return Object.fromEntries(Object.entries(this._modules).filter(([, module]) => {
                return filter(module);
            }));
        }
        return this._modules;
    }
    /*//////////////////////////////////////////////////////////////
                      Module Write Functions
    //////////////////////////////////////////////////////////////*/
    /**
     * Call a module's instance write function.
     *
     * @param account - A Viem account.
     * @param moduleId - Module's ID.
     * @param instance - Module instance.
     * @param func - Function to call.
     * @param args - Function's input arguments.
     * @returns An object containing the status of the call and the transaction hash.
     */
    async callInstanceWriteFunction({ account, moduleId, instance, func, args, }) {
        if (this._modules === undefined) {
            throw new ClientNotPreparedError("Error: Client has not been initialized, requires a call to the prepare function");
        }
        if (this._walletClient === undefined) {
            throw new MissingWalletClientError("Error: the client was initialized without a wallet client, which is required for this function");
        }
        const module = this.getModuleById(moduleId);
        if (module === undefined) {
            throw new ModuleNotAvailableError(`Error: Module with id ${moduleId} does not exist`);
        }
        checkWriteFunctionArgs({ func, args });
        try {
            const { request } = await this._publicClient.simulateContract({
                address: instance,
                abi: module.abi,
                functionName: func.functionName,
                args: args,
                account,
            });
            const hash = await this._walletClient.writeContract(request);
            const receipt = await this._publicClient.waitForTransactionReceipt({
                hash,
            });
            return {
                status: receipt.status,
                transactionHash: receipt.transactionHash,
            };
        }
        catch (err) {
            getModuleFunctionError(err, moduleId);
        }
    }
}

exports.HATS_ELIGIBILITIES_CHAIN_MODULE_ABI = HATS_ELIGIBILITIES_CHAIN_MODULE_ABI;
exports.HATS_ELIGIBILITIES_CHAIN_MODULE_ADDRESS = HATS_ELIGIBILITIES_CHAIN_MODULE_ADDRESS;
exports.HATS_MODULES_FACTORY_ABI = HATS_MODULES_FACTORY_ABI;
exports.HATS_MODULES_FACTORY_ADDRESS = HATS_MODULES_FACTORY_ADDRESS;
exports.HATS_MODULE_ABI = HATS_MODULE_ABI;
exports.HATS_TOGGLES_CHAIN_MODULE_ABI = HATS_TOGGLES_CHAIN_MODULE_ABI;
exports.HATS_TOGGLES_CHAIN_MODULE_ADDRESS = HATS_TOGGLES_CHAIN_MODULE_ADDRESS;
exports.HatsModulesClient = HatsModulesClient;
exports.checkAndEncodeArgs = checkAndEncodeArgs;
exports.checkImmutableArgs = checkImmutableArgs;
exports.checkMutableArgs = checkMutableArgs;
exports.getNewInstancesFromReceipt = getNewInstancesFromReceipt;
exports.getSchema = getSchema;
exports.solidityToTypescriptType = solidityToTypescriptType;
exports.verify = verify;
